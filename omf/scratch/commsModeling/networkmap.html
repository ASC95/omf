<!DOCTYPE html>
<html>
<head>
	<title>Communications Network</title>
<head>
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css" integrity="sha512-07I2e+7D8p6he1SIM+1twR5TIrhUQn9+I6yjqD53JQjFiMf8EtC93ty0/5vJTZGF8aAocvHYNEDJajGdNx1IsQ=="
		crossorigin="" />
	<script src="https://unpkg.com/leaflet@1.0.3/dist/leaflet.js" integrity="sha512-A7vV8IFfih/D732iSSKi20u/ooOfj/AGehOKq0f4vLT1Zr2Y+RX7C+w8A1gaSasGtRUZpF/NZgzSAu4/Gc41Lg=="
		crossorigin=""></script>
</head>
	<style>html, body {
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;}
	</style>
	<style>#map{
		position: relative;
		width: 100.0%;
		height: 100.0%;
		left: 0.0%;
		top: 0.0%;
		}
	</style>
	<style>

		.selectedControl{
		background-color: yellow;
		}

		.mapControl{
		height: 25px;
		width: 200px;
		}


	</style>
</head>
<body>
	<div id="map"></div>
	<script type="text/javascript" src="comms.js"></script>
	<script type="text/javascript">
	var map = L.map('map').setView([32.992370484, -102.762594414], 17);
	//renderer tbd with larger sets
	var myRenderer = L.svg();

	/*
	mapLink = '<a href="http://openstreetmap.org">OpenStreetMap</a>';
	L.tileLayer(
		'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
		attribution: '&copy; ' + mapLink + ' Contributors',
		maxZoom: 20,
		}).addTo(map);
	*/
	var circleColors = {
		"substation": '#ffa433',
		"recloser": '#fdff33',
		"gateway": '#3aff33',
		"meter": '#3366FF'
	}

	var lineColors = {
		"fiber": '#a133ff',
		"rf": '#ff3333'
	}
	//stroke-dasharray = 3
	function onEachFeature(feature, layer) {
		if (feature.geometry['type'] == 'LineString'){
			feature.properties['segmentCost'] = (calcDistance(feature) * feature.properties['cost']).toFixed(2);
		}
		var popupContent = '';
		for (const key in feature.properties) {
			if (feature.properties.hasOwnProperty(key)) {
				popupContent += key + ': ' + feature.properties[key] + '\n';
				layer.bindPopup(popupContent);
			}
		}
	}
	function pointToLayerNode(feature, latlng) {
		let fillColorValue = 'black';
		if (feature.properties.pointType){
			fillColorValue = circleColors[feature.properties.pointType];
		}
		return L.circleMarker(latlng, {
			radius: 8,
			fillColor: fillColorValue,
			color: "#000",
			weight: 1,
			opacity: 1,
			fillOpacity: 0.8
		})
		;
	}

	function lineStyle(feature){
		if (feature.geometry['type'] == 'LineString'){
			if (feature.properties.edgeType == 'rf'){
				return {
					"color": lineColors[feature.properties.edgeType],
					"dashArray": "6"
				}
			}
			else if (feature.properties.edgeType){
				return {
					"color": lineColors[feature.properties.edgeType]
				}
			}
			else{
				return {
					"color": "black"
				}
			}
		}
	}
	geojsonLayer = L.geoJSON(false, {
				pointToLayer: pointToLayerNode,
				onEachFeature: onEachFeature,
				style: lineStyle,
			});
	geojson.features.forEach(function(feature){
		if (feature.geometry['type'] == 'Point'){
			geojsonLayer.addData(feature);
		}
		else if (feature.geometry['type'] == 'LineString'){
			geojsonLayer.addData(feature);
		}
		else if (feature.geometry['type'] == 'Polygon'){
			geojsonLayer.addData(feature);
		}
	});
	L.control.scale().addTo(map);
	geojsonLayer.addTo(map);
	/*
	geojson.features.forEach(function(feature){
		if (feature.geometry['type'] == 'Point'){
			L.circleMarker( [feature.geometry.coordinates[1],
				feature.geometry.coordinates[0]],
				{ renderer: myRenderer } )
			.on('click', removeMarker)
			.bindPopup('circle')
			.addTo(map);
		}
		else if (feature.geometry['type'] == 'LineString'){
			L.polyline( [[feature.geometry.coordinates[0][1], feature.geometry.coordinates[0][0]],
			[feature.geometry.coordinates[1][1], feature.geometry.coordinates[1][0]] ], { renderer: myRenderer } )
			.on('click', changeColor)
			.bindPopup('line')
			.addTo(map);
		}
	});
	*/
	
	//Add marker to map at click location; add popup window
	function addMarker(e){
		L.circleMarker(e.latlng).addTo(map);
	}

	function changeColor(e){
		console.log(e.target._popup._content);
		e.target._path.style.fill = '#dd55ff';
		e.target._path.style.stroke = '#dd55ff';
		//e.target._popup._content = 'has been selected'
		//e.target._radius = 's40';
		console.log(e.target._path.style.fill);
	}

	L.Control.Toolbox = L.Control.extend({
	    onAdd: function(map) {
	        var toolDiv = L.DomUtil.create('div');
	        toolDiv.id = 'toolDiv';
	        toolDiv.style.height = '100px';
	        toolDiv.style.width = '200px';
	        //toolDiv.style.background = 'white';
	        return toolDiv;
	    },
	    onRemove: function(map) {
	        // Nothing to do here
	    }
	});

	L.control.toolbox = function(opts) {
	    return new L.Control.Toolbox(opts);
	}

	
	L.control.toolbox({ position: 'topright'}).addTo(map);
	
	//create new control box in toolbox
	//look more how to toggle events on and off
	function newMarkerToggle(e){
		//how to check if there is event listener
		if (e.target.classList.contains('selectedControl')) {
			e.target.classList.remove("class","selectedControl");
			map.on('click', addMarker);	
		}
		else {
			document.getElementById(e.target.id).setAttribute("class","selectedControl");
			map.off('click', addMarker);
		}
		//console.log(e.target.class);
	}
	//how do you set the status of a button
	var newMarker = L.DomUtil.create('button');
	L.DomEvent.disableClickPropagation(newMarker);
	newMarker.id = 'newMarker';
	newMarker.classList.add('mapControl');
	newMarker.innerHTML = 'New Marker';
	document.getElementById('toolDiv').appendChild(newMarker);
	newMarker.addEventListener('click', newMarkerToggle);

	function addLine(source, target){
		//Select first node
		//Select Second Node
		//may need to be able to handle two clicks - start and end node that generates line
	}

	function removeLine(e){
	}

	function removeMarker(e){
		map.removeLayer(e.target);
	}

	function setValue(e){
		//be able to toggle different values here
		//type, frequency, data rate
	}
	function calcDistance(feature){
		//use distanceTo
		return L.latLng(feature.geometry['coordinates'][0]).distanceTo(L.latLng(feature.geometry['coordinates'][1]))
		//may ned to calc multiple lines or full graph - traversal method needed
	}

	function toggleMap(layer){
		//turn map on or off in background
	}

	function isolatedItem(){
		//check if any edges are dangling ie not connected to a node at the end
		//maybe this is a list thats is added to when a node is deleted
		//keep track of the line as well
	}

</script>
</body>
</html>