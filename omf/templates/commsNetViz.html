<!DOCTYPE html>
<html>
<head>
	<title>GeoJSON Map</title>
<head>
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css" integrity="sha512-07I2e+7D8p6he1SIM+1twR5TIrhUQn9+I6yjqD53JQjFiMf8EtC93ty0/5vJTZGF8aAocvHYNEDJajGdNx1IsQ=="
		crossorigin="" />
	<script src="https://unpkg.com/leaflet@1.0.3/dist/leaflet.js" integrity="sha512-A7vV8IFfih/D732iSSKi20u/ooOfj/AGehOKq0f4vLT1Zr2Y+RX7C+w8A1gaSasGtRUZpF/NZgzSAu4/Gc41Lg=="
		crossorigin=""></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
</head>
	<style>html, body {
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;}
	</style>
	<style>#map{
		position: relative;
		width: 100.0%;
		height: 100.0%;
		left: 0.0%;
		top: 0.0%;
		}

		.selectedControl{
		background-color: yellow;
		}

	</style>
</head>
<body>
	<div id="map"></div>
	<script>var geojson={% if geojson %}{{geojson | tojson}}{% else %}null{% endif %}</script>
	<script type="text/javascript" src="commsGeoJson.js"></script>
	<script type="text/javascript">

	//Add popup to each node/edge with the properties
	function onEachFeature(feature, layer) {
		let popupContent = '';
		for (let key in feature.properties) {
			if (feature.properties.hasOwnProperty(key)) {
				popupContent += (key + ': ' + feature.properties[key] + '<br>');
				layer.bindPopup(popupContent);
			}
		}
	}

	//Set how comms nodes are displayed
	function pointToLayerNode(feature, latlng) {
		let fillColorValue = 'black';
		if (feature.properties['substation']){
			fillColorValue = 'orange';
		return L.circleMarker(latlng, {
			radius: 8,
			fillColor: fillColorValue,
			color: "#000",
			weight: 1,
			opacity: 1,
			fillOpacity: 0.8
		});
		}
		else if (feature.properties.pointType == 'meter' || feature.properties.pointType == 'triplex_meter'){
			fillColorValue = 'blue';
		return L.circleMarker(latlng, {
			radius: 8,
			fillColor: fillColorValue,
			color: "#000",
			weight: 1,
			opacity: 1,
			fillOpacity: 0.8
		});
		}
		else if (feature.properties['rfCollector']){
			fillColorValue = 'green';
		return L.circleMarker(latlng, {
			radius: 8,
			fillColor: fillColorValue,
			color: "#000",
			weight: 1,
			opacity: 1,
			fillOpacity: 0.8
		});
		}
		else {
			fillColorValue = 'white';
		return L.circleMarker(latlng, {
			radius: 8,
			fillColor: fillColorValue,
			color: "#000",
			weight: 1,
			opacity: 1,
			fillOpacity: 0.2
		});
		}
	}

	//Set the line style for edges
	function lineStyle(feature){
		if (feature.geometry['type'] == 'LineString'){
			if (feature.properties['rf']){
				return {
					"color": "red",
					"dashArray": "10"
				}
			}
			else if (feature.properties['fiber']){
				return {
					"color": "yellow",
				}
			}
			else {
				return {
					"color": "black",
					"opacity": "0.2"
				}
			}
		}
	}
	var geojsonLayer = L.geoJSON(false, {
				pointToLayer: pointToLayerNode,
				onEachFeature: onEachFeature,
				style: lineStyle,
			});
	geojson.features.forEach(function(feature){
		if (feature.geometry['type'] == 'Point'){
			geojsonLayer.addData(feature);
		}
		else if (feature.geometry['type'] == 'LineString'){
			geojsonLayer.addData(feature);
		}
	});
	var bounds = geojsonLayer.getBounds();
	// Optional forcing of canvas renderer:
	var map = L.map('map', {renderer: L.canvas()}).fitBounds(bounds);
	// LayerGroup might be a good option here
	mapLink = '<a href="http://openstreetmap.org">OpenStreetMap</a>';
	L.tileLayer(
		'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
		attribution: '&copy; ' + mapLink + ' Contributors',
		maxZoom: 20,
		}).addTo(map);
	L.control.scale().addTo(map);
	geojsonLayer.addTo(map);

	//Control box
	L.Control.Toolbox = L.Control.extend({
	    onAdd: function(map) {
	        var toolDiv = L.DomUtil.create('div');
	        toolDiv.id = 'toolDiv';
	        toolDiv.style.width = '200px';
	        toolDiv.style.background = 'white';
	        return toolDiv;
	    },
	    onRemove: function(map) {
	    }
	});

	L.control.toolbox = function(opts) {
	    return new L.Control.Toolbox(opts);
	}

	L.control.toolbox({ position: 'topright'}).addTo(map);

	//Get all comms objects in the network
	function selectCommsObjects(){
		let commsObjects = [];
		geojsonLayer.eachLayer(function (layer) {
			if (layer.feature.geometry['type'] == 'LineString'){
				if ((layer.feature.properties.rf) || (layer.feature.properties.fiber)){
					commsObjects.push(layer);
				}
			}
			else if (layer.feature.geometry['type'] == 'Point'){
				if ((layer.feature.properties.rfCollector) || (layer.feature.properties.substation) || (layer.feature.properties.smartMeter)){
					commsObjects.push(layer);
				}
			};
		});
		return commsObjects;
	}

	//get all non communications objects in the grid
	function selectNonCommsObjects(){
		let nonCommsObjects = [];
		geojsonLayer.eachLayer(function (layer) {
			if (layer.feature.geometry['type'] == 'LineString'){
				if (!(layer.feature.properties.rf) & !(layer.feature.properties.fiber)){
					nonCommsObjects.push(layer);
				}
			}
			else if (layer.feature.geometry['type'] == 'Point'){
				if (!(layer.feature.properties.rfCollector) && !(layer.feature.properties.substation) && !(layer.feature.properties.smartMeter)){
					nonCommsObjects.push(layer);
				}
			};
		});
		return nonCommsObjects;
	}

	//Hide non objects on the grid from an input array of layers
	function hideGridObjects(gridObject){
		gridObject.forEach(function (layer) {
			if (layer.feature.geometry['type'] == 'LineString'){
				layer.setStyle({"opacity": 0, "interactive": false});
			}
			else if (layer.feature.geometry['type'] == 'Point'){
				layer.setStyle({"fillOpacity": 0,"opacity": 0, "interactive": false});
			};
		});
	}

	//Resets hidden grid objects
	function showGridObjects(gridObject){
		gridObject.forEach(function (layer) {
			if (layer.feature.geometry['type'] == 'LineString'){
				geojsonLayer.resetStyle(layer);
			}
			else if (layer.feature.geometry['type'] == 'Point'){
				geojsonLayer.resetStyle(layer);
			};
		});
	}

	//to do create a loop to automate process for additonal controls
	var displayNonComms = L.DomUtil.create('button');
	L.DomEvent.disableClickPropagation(displayNonComms);
	displayNonComms.id = 'displayNonComms';
	displayNonComms.classList.add('mapControl');
	displayNonComms.innerHTML = 'Show full grid';
	document.getElementById('toolDiv').appendChild(displayNonComms);
	displayNonComms.addEventListener('click', function(){showGridObjects(selectNonCommsObjects())});

	
	var hideNonComms = L.DomUtil.create('button');
	L.DomEvent.disableClickPropagation(hideNonComms);
	hideNonComms.id = 'hideNonComms';
	hideNonComms.classList.add('mapControl');
	hideNonComms.innerHTML = 'Show comms grid';
	document.getElementById('toolDiv').appendChild(hideNonComms);
	hideNonComms.addEventListener('click', function(){hideGridObjects(selectNonCommsObjects())});

	//Add new object to map example
	function addGeoObject(feature){
		if (feature.geometry['type'] == 'Point'){
			geojsonLayer.addData(feature);
		}
		else if (feature.geometry['type'] == 'LineString'){
			geojsonLayer.addData(feature);
		}
	}

	//Form div for updating geojson
	L.Control.Form = L.Control.extend({
	    onAdd: function(map) {
	        var formDiv = L.DomUtil.create('div');
	        formDiv.id = 'formDiv';
	        formDiv.style.height = 'auto';
	        formDiv.style.width = '200px';
	        formDiv.style.background = 'white';
	        return formDiv;
	    },
	    onRemove: function(map) {
	    }
	});

	L.control.form = function(opts) {
	    return new L.Control.Form(opts);
	}

	L.control.form({ position: 'topright'}).addTo(map);

	//Create form container
	var geoForm = L.DomUtil.create('form');
	L.DomEvent.disableClickPropagation(geoForm);
	geoForm.id = 'geoForm';
	geoForm.name = 'geoForm';
	geoForm.classList.add('mapControl');
	document.getElementById('formDiv').appendChild(geoForm);

	var geoName = L.DomUtil.create('input');
	geoName.id = 'geoName';
	geoName.type = 'text';
	geoName.name = 'geoName';
	geoName.placeholder = 'Name';
	document.getElementById('geoForm').appendChild(geoName);

	var geoLat = L.DomUtil.create('input');
	geoLat.id = 'geoLat';
	geoLat.type = 'text';
	geoLat.name = 'geoLat';
	geoLat.placeholder = 'Latitude';
	document.getElementById('geoForm').appendChild(geoLat);

	var geoLng = L.DomUtil.create('input');
	geoLng.id = 'geoLng';
	geoLng.type = 'text';
	geoLng.name = 'geoLng';
	geoLng.placeholder = 'Longitude';
	document.getElementById('geoForm').appendChild(geoLng);

	var geoSubstationLabel = L.DomUtil.create('label');
	geoSubstationLabel.id = 'geoSubstationLabel';
	geoSubstationLabel.name = 'geoSubstationLabel';
	geoSubstationLabel.innerHTML = 'Is substation?';
	document.getElementById('geoForm').appendChild(geoSubstationLabel);

	var geoSubstation = L.DomUtil.create('input');
	geoSubstation.id = 'geoSubstation';
	geoSubstation.type = 'checkbox';
	geoSubstation.name = 'geoSubstation';
	document.getElementById('geoForm').appendChild(geoSubstation);

	var geoRfCollectorLabel = L.DomUtil.create('label');
	geoRfCollectorLabel.id = 'geoRfCollectorLabel';
	geoRfCollectorLabel.name = 'geoRfCollectorLabel';
	geoRfCollectorLabel.innerHTML = 'Is RF Collector?';
	document.getElementById('geoForm').appendChild(geoRfCollectorLabel);

	var geoRfCollector = L.DomUtil.create('input');
	geoRfCollector.id = 'geoRfCollector';
	geoRfCollector.type = 'checkbox';
	geoRfCollector.name = 'geoRfCollector';
	document.getElementById('geoForm').appendChild(geoRfCollector);

	var geoSmartMeterLabel = L.DomUtil.create('label');
	geoSmartMeterLabel.id = 'geoSmartMeterLabel';
	geoSmartMeterLabel.name = 'geoSmartMeterLabel';
	geoSmartMeterLabel.innerHTML = 'Is Smart Meter?';
	document.getElementById('geoForm').appendChild(geoSmartMeterLabel);

	var geoSmartMeter = L.DomUtil.create('input');
	geoSmartMeter.id = 'geoSmartMeter';
	geoSmartMeter.type = 'checkbox';
	geoSmartMeter.name = 'geoSmartMeter';
	document.getElementById('geoForm').appendChild(geoSmartMeter);

	var geoBandwidthCapacity = L.DomUtil.create('input');
	geoBandwidthCapacity.id = 'geoBandwidthCapacity';
	geoBandwidthCapacity.type = 'text';
	geoBandwidthCapacity.name = 'geoBandwidthCapacity';
	geoBandwidthCapacity.placeholder = 'Bandwidth Capacity';
	document.getElementById('geoForm').appendChild(geoBandwidthCapacity);

	var geoBandwidthUse = L.DomUtil.create('input');
	geoBandwidthUse.id = 'geoBandwidthUse';
	geoBandwidthUse.type = 'text';
	geoBandwidthUse.name = 'geoBandwidthUse';
	geoBandwidthUse.placeholder = 'Bandwidth Use';
	document.getElementById('geoForm').appendChild(geoBandwidthUse);

	var geoPointType = L.DomUtil.create('input');
	geoPointType.id = 'geoPointType';
	geoPointType.type = 'text';
	geoPointType.name = 'geoPointType';
	geoPointType.placeholder = 'Point Type';
	document.getElementById('geoForm').appendChild(geoPointType);

	var geoSubmit = L.DomUtil.create('input');
	L.DomEvent.disableClickPropagation(geoSubmit);
	geoSubmit.id = 'geoSubmit';
	geoSubmit.type = 'submit';
	geoSubmit.value = 'Submit Geo Form';
	geoSubmit.classList.add('mapControl');
	document.getElementById('geoForm').appendChild(geoSubmit);
	geoSubmit.addEventListener('click', geoUpdate)

	function existingFeature(feature){
		return feature.properties.name == document.getElementById('geoName').value;
	}

	function geoUpdate(e){
		e.preventDefault();
		let currentElement = geojson.features.findIndex(existingFeature); 
		//create a new point
		if (currentElement === -1) {
			let feature = {
			    "type": "Feature",
			    "properties": {
			        "name": document.getElementById('geoName').value,
			        "substation": document.getElementById('geoSubstation').checked,
			        "rfCollector": document.getElementById('geoRfCollector').checked,
			        "smartMeter": document.getElementById('geoSmartMeter').checked,
			        "bandwidthCapacity": parseFloat(document.getElementById('geoBandwidthCapacity').value),
			        "bandwidthUse": parseFloat(document.getElementById('geoBandwidthUse').value),
			        "pointType": document.getElementById('geoPointType').value,
			    },
			    "geometry": {
			        "type": "Point",
			        "coordinates": [parseFloat(document.getElementById('geoLng').value), parseFloat(document.getElementById('geoLat').value)] 
			    }
			};
			geojson.features.push(feature);
			geojsonLayer.addData(feature);
		}
		//edit an existing point
		else{
			geojson.features[currentElement].properties.substation = document.getElementById('geoSubstation').checked;
			geojson.features[currentElement].properties.rfCollector = document.getElementById('geoRfCollector').checked;
			geojson.features[currentElement].properties.smartMeter = document.getElementById('geoSmartMeter').checked;
			geojson.features[currentElement].properties.bandwidthCapacity = parseFloat(document.getElementById('geoBandwidthCapacity').value);
			geojson.features[currentElement].properties.bandwidthUse = parseFloat(document.getElementById('geoBandwidthUse').value);
			geojson.features[currentElement].properties.pointType = document.getElementById('geoPointType').value;
			geojson.features[currentElement].geometry.coordinates = [parseFloat(document.getElementById('geoLng').value), parseFloat(document.getElementById('geoLat').value)];

			//remove and old layer
			geojsonLayer.eachLayer(function(feature){
				if (feature.feature.properties.name == document.getElementById('geoName').value){
					feature.remove();
				}
			});
			//add layer with new data
			geojsonLayer.addData(geojson.features[currentElement]);
		}
	}

	//Form div for searching for geojson object by name
	L.Control.Search = L.Control.extend({
	    onAdd: function(map) {
	        var searchDiv = L.DomUtil.create('div');
	        searchDiv.id = 'searchDiv';
	        searchDiv.style.height = 'auto';
	        searchDiv.style.width = '200px';
	        searchDiv.style.background = 'white';
	        return searchDiv;
	    },
	    onRemove: function(map) {
	    }
	});

	L.control.search = function(opts) {
	    return new L.Control.Search(opts);
	}

	L.control.search({ position: 'topright'}).addTo(map);

	var searchForm = L.DomUtil.create('form');
	L.DomEvent.disableClickPropagation(searchForm);
	searchForm.id = 'searchForm';
	searchForm.name = 'searchForm';
	searchForm.classList.add('mapControl');
	document.getElementById('searchDiv').appendChild(searchForm);

	var featureName = L.DomUtil.create('input');
	featureName.id = 'featureName';
	featureName.type = 'text';
	featureName.name = 'featureName';
	featureName.placeholder = 'Name';
	document.getElementById('searchForm').appendChild(featureName);

	var searchSubmit = L.DomUtil.create('input');
	L.DomEvent.disableClickPropagation(searchSubmit);
	searchSubmit.id = 'searchSubmit';
	searchSubmit.type = 'submit';
	searchSubmit.value = 'Find object';
	searchSubmit.classList.add('mapControl');
	document.getElementById('searchForm').appendChild(searchSubmit);
	searchSubmit.addEventListener('click', featureSearch);

	//opens popup for name entered in search field
	function featureSearch(e){
		e.preventDefault();
		geojsonLayer.eachLayer(function(feature){
			if (feature.feature.properties.name == document.getElementById('featureName').value){
				feature.openPopup();
			}
		});
	}
	
	//redisplay grid with edits
	function redisplayGrid(){
		$.ajax({
		    type: 'POST',
		    url: '/redisplayGrid',
		    dataType: 'json',
		    contentType: 'application/json; charset=utf-8',
		    data: JSON.stringify(geojson),
		    success: function(callback) {
		    	console.log('success');
		    	geojson = callback.newgeojson;
		    	geojsonLayer.eachLayer(function(layer){
		    		layer.remove();
		    	});
		    	geojsonLayer.clearLayers();
				geojson.features.forEach(function(feature){
					if (feature.geometry['type'] == 'Point'){
						geojsonLayer.addData(feature);
					}
					else if (feature.geometry['type'] == 'LineString'){
						geojsonLayer.addData(feature);
					}
				});
		    },
		    error: function() {
		        $(this).html("error!");
		    }
		});
	}
	var gridRedisplay = L.DomUtil.create('button');
	L.DomEvent.disableClickPropagation(gridRedisplay);
	gridRedisplay.id = 'gridRedisplay';
	gridRedisplay.classList.add('mapControl');
	gridRedisplay.innerHTML = 'Redisplay grid';
	document.getElementById('toolDiv').appendChild(gridRedisplay);
	gridRedisplay.addEventListener('click', function(){redisplayGrid()});


</script>
</body>
</html>