<head>
	<script type="text/javascript" src="/static/d3.v3.js"></script>
	<script type="text/javascript" src="/static/omf.js"></script>
	<script type="text/javascript" src="/static/jquery-1.9.1.js"></script>
	<script type="text/javascript" src="/static/tablescript.js"></script>
	<link rel="stylesheet" href="/static/omf.css" />
	<link rel="shortcut icon" href="/static/favicon.ico" />
	<link rel="stylesheet" type="text/css" href="/static/gridEdit.css"/>
</head>
<body onkeypress='hotkeys()' onload="showProgressDialog('Rendering feeder.')">
<div id='title'>
	<div id='logoBox'><a href='/'>&#10059;</a></div>
	<p>Grid Editor: </p>
	<p id='gridName'>{{feederName}}</p>
</div>
<div id='toolbar'>
	<div class='buttonGroup leftToolbar'>
		<button class='pill' onclick='dropPill(this, "Add")'>Add ▾</button>
		<ul id='newObjectMenu' class='menu'></ul>
	</div>
	<div class='buttonGroup leftToolbar'>
		<button class='pill' onclick='dropPillAndStay(this, "Edit")'>Edit ▾</button>
		<ul class='menu'>
		<table style='padding:4px;word-wrap:break-word;white-space:nowrap;width:200px'>
			<tr>
				<td>Zoom Reset</td>
				<td><button onclick='javascript:zoomReset()'>Go</button></td>
			</tr>
			<tr>
				<td>Static Loads to Houses</td>
				<td><button onclick='javascript:staticLoadsToHouses()'>Go</button></td>
			</tr>
			<tr>
				<td>Solar at Meters <input type='text' style='width:20px' id='solarAddingPercentage'>%</td>
				<td><button onclick='javascript:solarAdding()'>Go</button></td>
			</tr>
			  
		</table>
		</ul>
	</div>
	<div class='buttonGroup leftToolbar'>
		<button class='pill' onclick='dropPill(this, "Pinning")'>Pinning ▾</button>
		<ul class='menu'>
		<li><a href='javascript:pinAll()' id='pinUnpinAll'>Pin All</a></li>
		<li><a href='javascript:unPinAll()'>Unpin All</a></li>
		<li><a href='javascript:toggleSelectedPin()'>Toggle Selected Pin (p)</a></li>
		</ul>
	</div>
	<div class='buttonGroup leftToolbar'>
		<button class='pill' onclick='dropPill(this, "Folding")'>Folding ▾</button>
		<ul class='menu'>
		<li><a href='javascript:foldOneLevel()'>One Level Fold</a></li>
		<li><a href='javascript:unfoldOneLevel()'>One Level Unfold</a></li>
		<li><a href='javascript:unfoldAll()'>Unfold All</a></li>
		<li><a href='javascript:foldAtSelected()'>Fold at Selected (f)</a></li>
		<li><a href='javascript:unfoldAtSelected()'>Unfold at Selected (u)</a></li>
		</ul>
	</div>
	<div class='buttonGroup leftToolbar'>
		<button class='pill' onclick='dropPillAndStay(this, "Find")'>Find ▾</button>
		<ul class='menu'>
		<table style='padding:4px;word-wrap:break-word'>
			<tr>
				<td>Term</td>
				<td><input id='searchTerm' type='text'></td>
			</tr>
			<tr>
				<td><button onclick='backButton()'>Back</button></td>
				<td id='searchHitCount' style='font-size:8pt;text-align:center'></td>
			</tr>
			<tr>
				<td style='padding-top:10px'><button onclick='findPrevious()'>Previous</button></td>
				<td style='padding-top:10px'><button onclick='findNext()'>Next</button></td>
			</tr>
		</table>
		</ul>
	</div>
	<div class='buttonGroup rightToolbar'>
		<button class='pill' onclick='dropPill(this, "Grid")'>Grid ▾</button>
		<ul class='menu right'>
			{% if public %}
			<li><a href="javascript:savePrivateFeeder()">Save Private Copy</a></li>
			{% endif %}
			{% if not public %}
			<li><a href="javascript:publishFeeder()">Make Public </a></li>
			{% endif %}
			{% if is_admin or not public %}
			<li><a href='javascript:deleteFeeder()'>Delete</a></li>
			<li><a href='javascript:duplicateFeeder()'>Duplicate</a></li>
			<li><a href='javascript:saveFeeder()'>Save</a></li>
			<li><a href='javascript:history.back()'>Leave &#x2192;</a></li>
			{% endif %}
		</ul>
	</div>
	<div class='buttonGroup rightToolbar'>
		<button class='pill' onclick='dropPillAndStay(this, "Layout")'>Layout ▾</button>
		<ul class='menu right'>
		<table style='padding:4px;word-wrap:break-word'>
			<tr>
				<td>GraphNodes</td>
				<td id='nodesBox'></td>
			</tr>
			<tr>
				<td colspan=2 style='padding:0px 0px 10px 0px'>
				<div id='nodesPercShown' style='background:black;width:30%;height:3px;display:inline-block'></div><div id='nodesPercHidden' style='background:gray;width:70%;height:3px;display:inline-block'></div>
				</td>
				<tr>
				<tr>
			<td>Gravity</td>
			<td><input id='gravityBox' type='text'></td>
				</tr>
				<tr>
			<td>Theta</td>
			<td><input id='thetaBox' type='text'></td>
				</tr>
				<tr>
			<td>Friction</td>
			<td><input id='frictionBox' type='text'></td>
				</tr>
				<tr>
			<td>Link Strength</td>
			<td><input id='linkStrengthBox' type='text'></td>
				</tr>
				<tr>
			<td>Link Distance</td>
			<td><input id='linkDistanceBox' type='text'></td>
				</tr>
				<tr>
			<td>Charge</td>
			<td><input id='chargeBox' type='text'></td>
				</tr>
				<tr>
			<td></td>
			<td style='padding-top:10px'><button onclick='layoutMenuApply()'>Apply</button></td>
				</tr>
			</table>
		</ul>
		</div>
	</div>
	<div id="selected">
		<table id="selHead">
			<tr>
			<td id="objmod" colspan="2"></td>
			<td id="value" colspan="2"></td>
			</tr>
		</table>
		<table id="daButtons">
			<tr id="editButtonRow">
			<td colspan="4"><button id="editButton">Edit</button></td>
			</tr>
			<tr id="otherButtons">
			<td><button id="deleteObject" class="deleteButton">Delete</button></td>
			<td><button id="addAttribute">Add Attribute</button></td>
			<td><button id="saveObject">Save</button></td>
			<td><button id="cancelButton">Cancel</button></td>
			</tr>
		</table>
		<div id="selBody">
			<table id="body">
			</table>
		</div>
	</div>
</div>
	  
<script type="text/javascript">
// GLOBAL VARIABLES:
feeder = '{{ feederName }}'
var w = 1000
var h = 1000
var tree
var components
var zoomer = d3.behavior.zoom()

// Graph size global variable
var NODE_STROKE_WIDTH = 0.4 
var LINE_LINK_STROKE_WIDTH = 3 /5
var LINE_PARENTCHILD_STROKE_WIDTH = 3/5
var LINE_SELECTED_STROKE_WIDTH = 3/5
var NODE_SELECTED_STROKE_WIDTH = 4/5
var NODE_CIRCLE_RADIUS = 3/5
var PINNED_NODE_STROKE_SIZE = 1/5
var PINNED_NODE_CIRCLE_RADIUS = 0.5/5
var UNPINNED_NODE_CIRCLE_RADIUS = 3/5
var TEXT_FONT_SIZE = 30

// SCALE DRAW GLOBAL LAYOUT VARIABLES
var xScale = 1, yScale = 1;
var width = window.screen.availWidth-45;
var height = window.screen.availHeight-100;

// CREATE LAYOUT
var body = d3.select('body')
	.append('svg:svg')
	.attr('id','graphSvg')
	.on('click', onSvgBlankCanvasClick)
	.call(zoomer.on('zoom', zoomRedraw))

// add powergrid to the upper layer
var vis = body.append('svg:g')
	.attr('id', 'powerGrid')
// add marker data
vis.append('svg:defs').selectAll('marker')
	.data(['transformerMarker', 'regulatorMarker', 'fuseMarker'])
	.enter().append('svg:marker')
	.attr('id', String)
	.attr('viewBox', '0 0 15 15')
	.attr('refX', -10)
	.attr('refY', 6)
	.attr('markerUnits','strokeWidth')
	.attr('markerWidth', 3)
	.attr('markerHeight', 3)
	.attr('stroke', 'gray')
	.attr('stroke-width', 1)
	.attr('fill', 'black')
	.attr('orient', 'auto')
	.append('svg:circle')
	.attr('r', 5)
	.attr('cx', 6)
	.attr('cy', 6)
vis.selectAll('marker')
	.append('svg:text')
	.attr('class','markerText')
	.attr('x',4)
	.attr('y',8)
	.text(function(d) {return d[0].toUpperCase()})
// add a layer to force the links to the bottom. 
vis.append('svg:g').attr('id','linkLayer')
var force = d3.layout.force()
	.linkDistance(30)
	.size([w, h])

// D3 FORCE GLOBAL VARIABLES.
var nodes = force.nodes()
var links = force.links()
var hiddenNodes = []
var hiddenLinks = []

// FUNCTIONS FOR DRAWING:
function draw() {
	// d3.js bookkeeping to set what happens on each time tick in the simulation:
	force.on('tick', function() {
		vis.selectAll('line.link')
		.attr('x1', function(d) { return d.source.x; })
		.attr('y1', function(d) { return d.source.y; })
		.attr('x2', function(d) { return d.target.x; })
		.attr('y2', function(d) { return d.target.y; });
		vis.selectAll('.node')
		.attr("fixed", function(d){return d.fixed }) // fixed a node
		.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
	});
	var name2nodeIndex = {}
	if (nodes.length == 0) {
		// Go through the first time and set up the nodes with indices:
		for (x in tree) {
			if ((tree[x].name != undefined || tree[x].module != undefined) && tree[x].from == undefined) {
				//TODO: Think about allowing access to other objects here.
				nodeName = tree[x].name
				nodeObject = tree[x].object
				if (tree[x].latitude != undefined && tree[x].longitude != undefined){
					x_pixel = tree[x].latitude
					y_pixel = tree[x].longitude
					isfixed = true
				}else{
					x_pixel = tree[x].latitude
					y_pixel = tree[x].longitude
					isfixed = false
				}

				// Hack to make sure electrical nodes are classed differently than graph nodes for coloring purposes:
				if (nodeObject == 'node') 
					nodeObject = 'gridNode'
				if (undefined != tree[x].bustype && tree[x].bustype == 'SWING') 
					nodeObject += ' swingNode'
				nodeIndex = nodes.length
				nodes.push({
					name : nodeName,
					treeIndex : parseInt(x),
					objectType : nodeObject,
					chargeMultiple : 1,
					x : x_pixel,
					y : y_pixel,
					fixed : isfixed })
				name2nodeIndex[nodeName] = nodeIndex
			}
		}

		// Go through a second time and set up the links:
		for (x in tree) {
			if (tree[x].name != undefined) {
				if (tree[x].from != undefined && tree[x].to != undefined) {
					name2nodeIndex[tree[x].name] = links.length
					links.push({
						source:name2nodeIndex[tree[x].from],
						target:name2nodeIndex[tree[x].to],
						treeIndex:parseInt(x),
						objectType:'fromTo' })
				} else if (tree[x].parent != undefined) {
					links.push({
						source:name2nodeIndex[tree[x].name],
						target:name2nodeIndex[tree[x].parent],
						objectType:'parentChild'})
				}
			}
		}    
	}
	// This makes a fancy fade-in.
	vis.style('opacity', 1e-6)
		.transition()
		.duration(1500)
		.style('opacity', 1);
	// Start the layout.
	force.start();
	
	// Run the layout in the background until performance is acceptable.
	// preLayout()
	
	// Feeder loading
	var interval = setInterval(function(){
		if(force.alpha() < 0.02){
			removeProgressDialog()
			clearInterval(interval)
		}
		else if (nodes[parseInt(Math.random()*nodes.length)].fixed){
			removeProgressDialog()
			clearInterval(interval)
		}
	}, 1500)

	// Start drawing.
	redraw()
}

function redraw() {
	link = d3.select('#linkLayer').selectAll('line.link')
		.data(links, function(d) {return d.source.treeIndex + '-' + d.target.treeIndex})
	
	link.enter().append('svg:line')
		.on('click', onCompClick)
		.attr('class', function(d) { return 'link ' + d.objectType })
		.attr('id', function(d) { return 'n' + d.treeIndex })
		.style('stroke-width', LINE_LINK_STROKE_WIDTH)
		.attr('marker-start',
			function(d) {
				// console.log(d);
				treeData = tree[d.treeIndex]
				if (d.objectType=='fromTo') {
					if (treeData.object == "transformer") {return "url(#transformerMarker)"};
					if (treeData.object == "fuse") {return "url(#fuseMarker)"};
					if (treeData.object == "regulator") {return "url(#regulatorMarker)"};
				};
			})
	link.exit().remove()

	node = vis.selectAll('.node').data(nodes, function(d) {return d.treeIndex}).enter()
		.append("g")
		.call(force.drag)
		.attr('class', function(d) {return 'node ' + d.objectType})
		.attr('id', function(d) {return 'n' + d.treeIndex})
		.on('click', onCompClick)

	node.append("svg:text")
			.attr("class", "nodetext");
			
	d3.selectAll('.nodetext').style('font-size', TEXT_FONT_SIZE / zoomer.scale())
			.text(function(d) { 
				if (d.chargeMultiple != 1){
					return d.objectType + ' has hidden children'}
				else {return d.objectType}})
	// Put the main circle on there, sized according to its size.
	node.append('svg:circle')
		.attr('id', function(d) {return 'circ' + d.treeIndex})
		.attr('class', 'nodeCircle')
		.attr('cx', 0)
		.attr('cy', 0)
		.attr('r', function(d) {return d.chargeMultiple * NODE_CIRCLE_RADIUS })
		// .attr("r", 100)
		.style('stroke-width', NODE_STROKE_WIDTH-0.2);

	node.append('svg:circle')
		.attr('class', function(d) {if(d.fixed) {return 'nodeIsPinned'} else {return 'nodeNotPinned'}})
		
	node.selectAll('.nodeIsPinned')
		.attr('id', function(d) {return 'pin' + d.treeIndex})
	node.selectAll('.nodeNotPinned')
		.attr('id', function(d) {return 'pin' + d.treeIndex})

	// Get rid of deleted nodes.
	vis.selectAll('.node').data(nodes, function(d) {return d.treeIndex}).exit().remove()

	d3.selectAll('.nodeIsPinned')
					.attr('cx', 0)
					.attr('cy', 0)
					.attr('r', PINNED_NODE_CIRCLE_RADIUS)
					.style('stroke-width', PINNED_NODE_STROKE_SIZE);
	d3.selectAll('.nodeNotPinned').attr('r', null)
	d3.selectAll('.node.selected').style('stroke-width', NODE_SELECTED_STROKE_WIDTH)

	// Updata sizes
	vis.selectAll('.nodeCircle').data(nodes, function(d){return d.treeIndex})
		.attr('r', function(d){ return d.chargeMultiple * NODE_CIRCLE_RADIUS})
	
	// Show scalegrid. 
	force.start()
}

var previourLevel = 1
var dynamicShow = false
function zoomRedraw() {
	// console.log(d3.event.scale, d3.event.translate)
	vis.attr('transform', 'translate(' + d3.event.translate + ')' + ' scale('+ d3.event.scale + ')')
	if (d3.event.scale<1){
		d3.selectAll('.link').style("stroke-width", LINE_LINK_STROKE_WIDTH/d3.event.scale);
	}
	if (dynamicShow)
		dynamicFoldAndUnfold()
	d3.selectAll('.nodetext').style('font-size', TEXT_FONT_SIZE/d3.event.scale)
			.text(function(d) { 
				if (d.chargeMultiple != 1){
					return d.objectType + ' has hidden children'}
				else {return d.objectType}})
	previourLevel = d3.event.scale;

	function dynamicFoldAndUnfold() {
		if (previourLevel > d3.event.scale){
			foldOneLevel();
		}else if (previourLevel < d3.event.scale) {
			unfoldOneLevel();
		}
	}
}

function changeDynamicShow() {
	if (!dynamicShow)
		dynamicShow = true
	else 
		dynamicShow = false
}

function preLayout() {
	function fiveTicks() {for (i=0; i<5; ++i) force.tick()}
	fiveTicksTime = 1000
	// while performance is bad keep rendering in the background:
	while (fiveTicksTime > 200) {
		fiveTicksTime = time(fiveTicks)
		console.log(fiveTicksTime)
	}
}

function zoom(x,y,s) {
	vis.transition().duration(1000).attr('transform','translate(' + x + ',' + y + ') scale(' + s + ')')
	// Set the behavior scale and translate to the current condition.
	zoomer.scale(s)
	zoomer.translate([x, y])
	// reset link width
	if (s < 1){
		d3.selectAll('.link').style("stroke-width", LINE_LINK_STROKE_WIDTH/s);
	}
	// redraw font-size
	d3.selectAll('.nodetext').style('font-size', TEXT_FONT_SIZE/s)
			.text(function(d) { 
				if (d.chargeMultiple != 1){
					return d.objectType + ' has hidden children'}
				else {return d.objectType}})
}

function zoomReset() {
	var scale = zoomer.scale()
	// TODO: rework our algorithm so we can zoom to fill the screen with the graph, not just go back to zoom level zero.
	zoom(0,0,1)
}
function zoomToFit() {
	// If this function zooms out, the lines may become much lighter, and if this function is used to zoom in, the lines may become much thicker.  Probably a Chrome bug.  The display goes back to normal after using the mouse wheel to zoom.
	function fly(attr_func, comp_func) {
		var largest;
		var my_n;
		for (i=0; i<nodes.length;i++){
			if (!largest || comp_func(attr_func(nodes[i]), largest)) {
				largest = attr_func(nodes[i])
				my_n = nodes[i]
			}
		}
		return my_n;
	}
	function actual_scale(){
		return $(window).height()/1000
	}
	function the_center(bounds, i){
	return ((bounds[0][i] + bounds[1][i])/2)
	}
	function xcenter(){
	return the_center(get_bounds(), 0) * zoomer.scale()
	}
	function ycenter(){
	return the_center(get_bounds(), 1) * zoomer.scale()
	}
	function window_hoz_center(){
	return ($(window).width()/2)/actual_scale()
	}
	function window_vert_center(){
		var extra = $("#title").outerHeight() + $("#toolbar").outerHeight()
		var win_height = $(window).height() - extra
		return (win_height/2 + extra)/actual_scale();
	}
	function center_feeder(){
		var trans_amt_x = window_hoz_center() - xcenter();
		var trans_amt_y = window_vert_center() - ycenter();
		zoom(trans_amt_x, trans_amt_y, zoomer.scale())
	}
	var rets_x = function(n){return n.x;};
	var rets_y = function(n){return n.y;};
	var lt = function (a,b){return a<b;};
	var gt = function(a,b){return a>b;};
	function get_bounds(){
		low_x = fly(rets_x, lt).x;
		high_x = fly(rets_x, gt).x;
		low_y = fly(rets_y, lt).y;
		high_y = fly(rets_y, gt).y;
		return [[low_x, low_y], [high_x, high_y]];
	}
	function win_h(){
		var extra = $("#title").outerHeight() + $("#toolbar").outerHeight()
		var win_h = $(window).height() - extra
		return win_h/actual_scale()
	}
	function get_width(bounds, i){
	return bounds[1][i] - bounds[0][i];
	}
	function xwidth(){
	return get_width(get_bounds(), 0)
	}
	function ywidth(){
		return get_width(get_bounds(), 1)
	}
	zoom(0,0, win_h()/ywidth())
	center_feeder()
}

function zoomToSelection() {
	domTargets = document.getElementsByClassName('selected')
	if (domTargets.length != 1) {return false}
	if (domTargets[0].nodeName == 'line') {
		x = getSelectedLink()['source']['x']
		y = getSelectedLink()['source']['y']
	}
	else {
		x = getSelectedNode()['x']
		y = getSelectedNode()['y']
	}
	console.log(x)
	var scale = 15 
	var xNew = -x*scale+graphSvg.clientWidth/2
	var yNew = -y*scale+graphSvg.clientHeight/2
	// Zooming to a node's coordinates
	zoom(xNew, yNew, scale)
}

function getCenterCoordinates() {
	try {
		x = zoomer.translate()[0]
		y = zoomer.translate()[1]
		s = 1/zoomer.scale()
		xMod = graphSvg.clientWidth/2
		yMod = graphSvg.clientHeight/2
		return [s*(xMod-x), s*(yMod-y)]
	} catch(err) {
		// Probably haven't transformed yet.
		return [0,0]
	}
}

// SELECT AND SEARCH FUNCTIONS
	var ti;
function onCompClick(d, i) {
	function classify(d, c) {
		svg = d3.select('#graphSvg')
		// turn off the old styled one, then style the new one
		svg.select('.' + c).classed(c, false);
		svg.select("#n" + d.treeIndex).classed(c, true);
	}
	// Start showing the table.
	// gebi('selected').className = ''
	// Abort if we try to select a parentChild relationship.
	if (d.objectType == 'parentChild') return false;
	// Multiselection case handled first:
	if (d3.event && d3.event.altKey) {
		classify(d,'multiselected')
		return false
	}
	console.log(['treeIndex=' + d.treeIndex,'name=' + d.name,'obType=' + d.objectType])
	// Visually identify the selected node.
	classify(d,'selected')
	// clear the selected table
	table = gebi('selected')
	table.setAttribute('keypress', "hotkeys()")
	tableClear(table)
	treeData = tree[d.treeIndex]
		ti = d.treeIndex;
		selectNode();
}

function clearSelection() {
	try {
		svg.select('.selected').classed('selected',false)
		svg.select('.multiselected').classed('multiselected',false)    
	} catch(err) {
		// ignore the error we get because we use svg before we define it--it'll be generated very fast after page load.
	}
	deselect()
}

function selectViaTreeIndex(treeIndex) {
	if (tree[treeIndex].hasOwnProperty('from')) {
		// That particular tree item is a link:
		linkI = findIndex(links,'treeIndex',treeIndex)
		onCompClick(links[linkI],linkI)
	} else if (tree[treeIndex].hasOwnProperty('object') && tree[treeIndex]['object'] != 'player'){
		// Or it's a node:
		nodeI = findIndex(nodes,'treeIndex',treeIndex)
		onCompClick(nodes[nodeI],nodeI)
	} else {
		nodeI = findIndex(nodes,'treeIndex',treeIndex)
		onCompClick(nodes[nodeI],nodeI)
		// Degenerate case: object without visual representation.
	}
}

function onSvgBlankCanvasClick() {
	if (window.event.toElement.tagName == 'rect') {clearSelection()}
}

function getSelectedNode() {
	try {
		hits = document.getElementsByClassName('selected')
		nodeIndex = findIndex(nodes, 'treeIndex', hits[0]['id'].substr(1))
		return nodes[nodeIndex]
	} catch(err) {
		// We had no selection, or the selection wasn't in the links.
		return undefined
	}
}

function getAltSelectedNode() {
	try {
		hits = document.getElementsByClassName('multiselected')
		nodeIndex = findIndex(nodes, 'treeIndex', hits[0]['id'].substr(1))
		return nodes[nodeIndex]
	} catch(err) {
		// We had no selection, or the selection wasn't in the links.
		return undefined
	}
}

function getSelectedLink() {
	try {
		hits = document.getElementsByClassName('selected')
		linkIndex = findIndex(links, 'treeIndex', hits[0]['id'].substr(1))
		return links[linkIndex]
	} catch(err) {
		// We had no selection, or the selection wasn't in the links.
		return undefined
	}
}

// TODO: disable hotkey when edit in the input text field.
function hotkeys() {
	// IE8 and earlier
	if(window.event) {x = event.keyCode}
	// IE9/Firefox/Chrome/Opera/Safari
	else if(event.which) {x = event.which}
	keychar = String.fromCharCode(x);
	if(event.target.type != 'text'){
		// Dispatch the key:
		if (keychar == 'p') {toggleSelectedPin()}
		else if (keychar == 'f') {foldAtSelected()}
		else if (keychar == 'u') {unfoldAtSelected()}
	}
}	

function findElementsViaString(inString) {
	results = []
	for (key in tree) {
		subIndex = JSON.stringify(tree[key]).indexOf(inString)
		if (subIndex != -1 && tree[key]['object'] != 'player' && (tree[key].hasOwnProperty('object')||tree[key].hasOwnProperty('module'))) {
			results.push(key)
		}
	}
	return results
}


var prevObjName
function backButton(){
	if (!prevObjName){
		console.log("There is no previous object")
		return
	}
	$("#searchTerm").val("\"name\":\""+prevObjName+"\"")
	findNext()

}


// Public variable to hold the current search state. Todo: put in a closure.
var searchCursor
var oldSearchTerm

function findNext() {
	if ($(".selected").length && treeData.object.indexOf("configuration") < 0){ 
		// We don't want to store configuration objects in the history, right?
		prevObjName = treeData.name
	}else{
		prevObjName = undefined
	}

	term = gebi('searchTerm').value
	if (oldSearchTerm != term) {
		oldSearchTerm = term
		searchCursor = undefined
	}
	hits = findElementsViaString(term)
	// TODO: What if it is hidden(folded).

	gebi('searchHitCount').innerHTML = hits.length + ' Hits'
	try {
		if (hits.length == 0) {return false}
		if (searchCursor == undefined) {
			selectViaTreeIndex(hits[0])
			searchCursor = 0
		} else {
			searchCursor++
			if (searchCursor == hits.length) {searchCursor = 0}
			if (searchCursor == -1) {searchCursor = hits.length-2}
			selectViaTreeIndex(hits[searchCursor])
		}
		zoomToSelection()
	}
	catch(err){
		alert('Objects have been hidden in the layout, please unfold them first.\n' + err.message)
	}
}

function findPrevious() {
	if (searchCursor == undefined) {
		findNext()
	} else {
		searchCursor -= 2
		findNext()
	}
}

function deleteObject(treeIndex) {
	// Figure out whether we have a node or an link:
	var isNode = true
	for (prop in tree[treeIndex]) if (prop == 'from') isNode = false
	if (isNode) {
		// Check for connections and abort if we have them.
		nodeName = tree[treeIndex].name
		for (indexVar in tree) {
		if (tree[indexVar].from == nodeName || tree[indexVar].to == nodeName || tree[indexVar].parent == nodeName) {
			alert('We can only delete nodes that aren\'t connected')
			return false
		}
		}
		// No connection, so delete the node:
		var nodeIndex
		for (x=0;x<nodes.length;x++) {
		if (nodes[x].treeIndex == treeIndex) nodeIndex = x
		}
		nodes.splice(nodeIndex,1)
		// If we have a parent child situation, delete the link:
		if (tree[treeIndex].parent != undefined) {
		var linkIndex
		for (x=0;x<links.length;x++) {
			if (links[x].source.name == nodeName) linkIndex = x
		}
		links.splice(linkIndex,1)
		}
	} else {
		// Delete link:
		var linkIndex
		for (x=0;x<links.length;x++) {
		if (links[x].treeIndex == treeIndex) linkIndex = x
		}
		links.splice(linkIndex,1)
	}
	// Delete tree object:
	delete tree[treeIndex]
	clearSelection()
	redraw()  
}

function nextTreeKey() {
	keyList = Object.keys(tree)
	max = 0
	for (x in keyList) {
		intKey = parseInt(keyList[x]); 
		if (intKey > max) 
			max = intKey
	}
	return max + 1
}

function findIndex(inOb,field,val) {
	for (key in inOb) {
		if (inOb[key][field]==val) {
			return key
		}
	}
	// if we can't find an index:
	return ''
}

// ADDING COMPONENTS FUNCTIONS
function fillComponentMenu() {
	newObjectMenu = gebi('newObjectMenu')
	for (component in components) {
		if (undefined == components[component]['from'] && undefined == components[component]['parent']) {addingFunctionName = 'newNode'}
		else if (undefined == components[component]['from']) {addingFunctionName = 'newChildAtSelected'}
		else {addingFunctionName = 'newLink'}
		newObjectMenu.innerHTML += ('<li><a href="javascript:' + addingFunctionName + '(\'' + component + '\')">' + component + '</a></li>')
	}
}

function newNode(componentName) {
	// Get the stuff we need.
	component = clone(components[componentName])
	treeNewIndex = nextTreeKey()
	// Put the component in the tree with a new name.
	tree[treeNewIndex] = component
	tree[treeNewIndex].name = componentName + String(treeNewIndex)
	// Add to the nodes.
	newType = component.object
	// Hack to make sure we color nodes correctly:
	if (newType == 'node') newType = 'gridNode'
	if (undefined != tree[treeNewIndex].bustype && tree[treeNewIndex].bustype == 'SWING') newType += ' swingNode'
	coords = getCenterCoordinates()
	nodeToAdd = {name:component.name, objectType:newType, treeIndex:treeNewIndex, chargeMultiple:1, fixed: true, x:coords[0], y:coords[1], px:coords[0], py:coords[1]}
	nodes.push(nodeToAdd)
	redraw()
}

function newLink(componentName) {
	// Fail if we have an incorrect selection.
	function alreadyLinked(nodeName1, nodeName2) {
		for (linkId in links) {
		sourceName = links[linkId].source.name
		targetName = links[linkId].target.name
		if ((nodeName1 == sourceName && nodeName2 == targetName) || (nodeName1 == targetName && nodeName2 == sourceName)) {return true}
		}
		return false
	}
	try {
		selectedName = getSelectedNode()['name']
		altSelectedName = getAltSelectedNode()['name']
	} catch(err) {
		// Key error!
		selectedName = undefined
		altSelectedName = undefined
	}
	if (undefined == selectedName || undefined == altSelectedName || selectedName == altSelectedName || alreadyLinked(selectedName, altSelectedName)) {
		alert('I am sorry, but we cannot insert a link there.')
		return false
	}
	// Get the stuff we need.
	component = clone(components[componentName])
	treeNewIndex = nextTreeKey()
	// Make sure component's to and from are set.
	component['from'] = selectedName
	component['to'] = altSelectedName
	// Put the component in the tree with a new name.
	tree[treeNewIndex] = component
	tree[treeNewIndex].name = componentName + String(treeNewIndex)
	// TODO: make absolutely sure we're not clobbering a name. We should just come up with a unique naming convention.
	// Add to the links.
	linkToAdd = {source:nodes[findIndex(nodes,'name',selectedName)], target:nodes[findIndex(nodes,'name',altSelectedName)], treeIndex:treeNewIndex, objectType:'fromTo'}
	links.push(linkToAdd)
	redraw()
}

function newChildAtSelected(componentName) {
	if (undefined == getSelectedNode()) {
		alert('I am sorry, but we cannot insert a child element there.')
		return false
	}
	// Get the stuff we need.
	component = clone(components[componentName])
	newChildAtLocation(component, getSelectedNode()['treeIndex'])
	redraw()
}

function newChildAtLocation(component,treeIndex) {
	treeNewIndex = nextTreeKey()
	newName = component['object'] + String(treeNewIndex)
	
	// Make sure component's parent is set.
	component['parent'] = tree[treeIndex]['name']
	// decide which attribute should be put into node and tree
	if (tree[treeIndex].latitude != undefined && tree[treeIndex].longitude != undefined){
		component['latitude'] = tree[treeIndex].latitude + Math.random() * 4 - 2
		component['longitude'] = tree[treeIndex].longitude + Math.random() * 4 - 2
		// Put the component in the tree with a new name.
		tree[treeNewIndex] = component
		tree[treeNewIndex].name = newName
		// Add to the nodes.
		// TODO: when the previour graph is pinned, it should set fixed as false rather than true
		if (d3.selectAll('.node.gridNode').attr('fixed')=='true'){
			isfixed = true
		}else{
			isfixed = false
		}
		nodeToAdd = {name:component.name, 
				objectType:component.object, 
				treeIndex:treeNewIndex, 
				chargeMultiple:1, 
				x: component['latitude'],
				y: component['longitude'],
				fixed : isfixed}
		nodes.push(nodeToAdd)
	}else{
		if (d3.selectAll('.node.gridNode').attr('fixed')=='true' && tree[treeIndex].latitude != undefined){
			isfixed = true
		}else{
			isfixed = false
		}
		tree[treeNewIndex] = component
		tree[treeNewIndex].name = newName
		nodeToAdd = {name:component.name, 
			objectType:component.object, 
			treeIndex:treeNewIndex, 
			chargeMultiple:1,
			fixed: isfixed}
		nodes.push(nodeToAdd)
	}
	
	// Add to the links.
	linkToAdd = {source:nodes[findIndex(nodes,'name',newName)], target:nodes[findIndex(nodes,'name',tree[treeIndex]['name'])], objectType:'parentChild'}
	links.push(linkToAdd)
	return nodeToAdd
}

function staticLoadsToHouses() {
	function randomHouse() {
		newHouse = {}
		newHouse['object'] = 'house'
		newHouse['air_temperature'] = '70'
		newHouse['cooling_COP'] = randomInt(25,40)/10.0 + ''
		newHouse['cooling_setpoint'] = 'cooling' + randomInt(1,8) + '*1'
		newHouse['cooling_system_type'] = randomChoice(['ELECTRIC', 'HEAT_PUMP', 'NONE'])
		// House sizing distribution from http://www.census.gov/housing/ahs/
		// between 1100 and 3000. Probably needs a normal distribution.
		area = 1800 + 500*randomGaussian()
		if (area < 500) {area = 500}
		area = area.toPrecision(2) * 1.0 + ''
		newHouse['floor_area'] = area
		newHouse['heating_COP'] = randomInt(20,35)/10.0 + ''
		newHouse['heating_setpoint'] = 'heating' + randomInt(1,8) + '*1'
		newHouse['heating_system_type'] = randomChoice(['RESISTANCE', 'HEAT_PUMP', 'GAS'])
		newHouse['mass_temperature'] = '70'
		skew = 1200*randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHouse['schedule_skew'] = skew
		newHouse['thermal_integrity_level'] = randomChoice([1,2,2,2,3,3,3,4,4,4,4,4,4,5,5,5,5,5,5,5,6,6,6]) + ''
		treeNewIndex = nextTreeKey()
		newHouse['name'] = 'synhouse' + treeNewIndex
		return newHouse
	}
	function randomLights() {
		newLights = {}
		newLights['object'] = 'ZIPload'
		newLights['power_fraction'] = '0.400000'
		newLights['current_fraction'] = '0.300000'
		newLights['impedance_pf'] = '1.000'
		newLights['current_pf'] = '1.000'
		newLights['power_pf'] = '1.000'
		newLights['impedance_fraction'] = '0.300000'
		newLights['heatgain_fraction'] = '0.9'
		power = 1.2 + randomGaussian()
		if (power < 0) {power = -1*power}
		power = power.toPrecision(3) * 1.0 + ''
		newLights['base_power'] = 'LIGHTS*' + 1.33
		skew = 2000*randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newLights['schedule_skew'] = skew
		treeNewIndex = nextTreeKey()
		newLights['name'] = 'synLights' + treeNewIndex
		return newLights
	}
	function randomWaterHeater() {
		newHeater = {}
		if (randomChoice([1,2,3]) == 3) {return false}
		// Static properties.
		newHeater['object'] = 'waterheater'
		newHeater['temperature'] = '135'
		newHeater['tank_volume'] = '50'
		newHeater['location'] = 'INSIDE'
		// Uniformly distributed properties.
		newHeater['heating_element_capacity'] = randomInt(37,53)/10.0 + ''
		newHeater['thermostat_deadband'] = randomInt(20,60)/10.0 + ''
		newHeater['demand'] = 'water' + randomInt(1,20) + '*1'
		newHeater['tank_UA'] = randomInt(20,40)/10.0 + ''
		// Gaussian properties.
		skew = 2000*randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHeater['schedule_skew'] = skew
		newHeater['tank_setpoint'] = (randomGaussian()*2+130).toPrecision(3) + ''
		// between 1100 and 3000. Probably needs a normal distribution.
		treeNewIndex = nextTreeKey()
		newHeater['name'] = 'synwaterheater' + treeNewIndex
		return newHeater
	}
	i = 0
	percentage = 0
	in_use= false;
	// TODO: for secondary system has 'load', replace it with triplex_meter and triplex_node
	tkeys = Object.keys(tree)
	function replaceAllHouses() {
		progressBarUpdate(percentage)
		if (i<tkeys.length && !in_use && percentage != 100) {
			in_use = true
			var limit = i+100
			for(; i<tkeys.length && i < limit; i++){
				index = tkeys[i]
				if (tree[index].hasOwnProperty('object') && tree[index].hasOwnProperty('parent') && tree[index]['object']=='triplex_node') {
					//get the parent index in tree, actually it is triplex_meter index
					parentIndex = findIndex(tree, 'name', tree[index]['parent'])
					// delete the triplex_node
					deleteObject(index)
					// create a new node which parent is 
					newHouse = randomHouse()
					newLights = randomLights()
					newHeater = randomWaterHeater()
					newChildAtLocation(newHouse, parentIndex)
					houseIndex = findIndex(tree, 'name', newHouse['name'])
					newChildAtLocation(newLights, houseIndex)
					if (newHeater!=false) {newChildAtLocation(newHeater, houseIndex)}
				}
				percentage = Math.round(i/tkeys.length * 100).toFixed(2) 
			}
			in_use =false
		}
		else{
			redraw()
			removeProgressBar()
			in_use=false;
			clearInterval(inter)
		}
	}
	function progressBarUpdate(percentage) {
		if (document.getElementById('progBar') != undefined)
			document.getElementById('progColor').style.width = percentage + '%'
	}
	function noTriplexNode(){
		for (x in hiddenNodes){
			if (hiddenNodes[x].objectType != undefined && hiddenNodes[x].objectType == 'triplex_node')
				return true
		}
		return false
	}
	if (noTriplexNode()){
		alert('TRIPLEX NODES have been hidden by the layout, please unfold them first.')
	} else {
		showProgressBar('Please wait. Houses are being generated.')
		// set interval function to run replaceAllHouses every 10 ms, if it is running, will put one request in the queue.
		inter = setInterval(replaceAllHouses, 10)
	}
}

function replaceLoadWithTriplex () {
	var tkeys = Object.keys(tree)
	var count = tkeys.length
	// TODO: performance issue here, same with staticLoadsToHouses()
	for (var i = count - 1; i >= 0; i--) {
		if (tree[tkeys[i]].object != undefined && tree[tkeys[i]].object == 'load') {
			// Add triplex_meter
			parentIndex = findIndex(tree, 'name', tree[tkeys[i]]['parent'])
			triName = 'tri' + tree[tkeys[i]].name
			triPhases = tree[tkeys[i]].phases
			triObject = 'triplex_meter'
			triVol = tree[tkeys[i]].nominal_voltage 	
			triMeter = {'name': triName, 'phases': triPhases, 'object': triObject, 'nominal_voltage': triVol}
			newNode = newChildAtLocation(triMeter, parentIndex)

			// Add triplex_node
			parentIndex = findIndex(tree, 'name', newNode.name)
			triNodeName = 'triNode' + newNode.name
			triNodeParents = newNode.name
			triNodePower = Math.max(parseFloat(tree[tkeys[i]].constant_power_A),parseFloat(tree[tkeys[i]].constant_power_B),parseFloat(tree[tkeys[i]].constant_power_C))
			triNodePhases = tree[tkeys[i]].phases
			triNodeVol = tree[tkeys[i]].nominal_voltage
			triNode = {'name':triNodeName, 'phases':triNodePhases, 'power_12': triNodePower, 'object': 'triplex_node', 'nominal_voltage': triNodeVol}
			newChildAtLocation(triNode, parentIndex)
			
			// delete load object
			deleteObject(tkeys[i])
		}
	}
}

function solarAdding() {
	solarPerc = gebi('solarAddingPercentage').value/100.0
	function makeNewInverter(phases) {
		newInverter = {}
		newInverter['object'] = 'inverter'
		newInverter['phases'] = phases
		newInverter['generator_status'] = 'ONLINE'
		newInverter['inverter_type'] = 'PWM'
		newInverter['generator_mode'] = 'CONSTANT_PF'
		treeNewIndex = nextTreeKey()
		newInverter['name'] = 'synInverter' + treeNewIndex
		return newInverter
	}
	function newRandomPanels() {
		newPanels = {}
		newPanels['object'] = 'solar'
		newPanels['generator_mode'] = 'SUPPLY_DRIVEN'
		newPanels['generator_status'] = 'ONLINE'
		newPanels['panel_type'] = 'SINGLE_CRYSTAL_SILICON'
		newPanels['efficiency'] = '0.1' + randomInt(0,5)
		newPanels['area'] = randomInt(2,8) + '00 sf'
		treeNewIndex = nextTreeKey()
		newInverter['name'] = 'synSolar' + treeNewIndex
		return newPanels
	}
	i = 0;
	percentage = 0;
	in_use = false;
	tkeys = Object.keys(tree)
	function walkAndAddSolar() {
		progressBarUpdate(percentage)
		// for (index in tree) {
		if (i<tkeys.length && !in_use && percentage != 100){
			in_use = true
			var limit = i + 100
			for (;i<tkeys.length && i < limit; i++){
				index = tkeys[i]
				if (tree[index].hasOwnProperty('object') && tree[index]['object']=='house') {
					if (Math.random() < solarPerc) {
					meterIndex = findIndex(tree, 'name', tree[index]['parent'])
					newInverter = makeNewInverter(tree[index]['phases'])
					newPanels = newRandomPanels()
					newChildAtLocation(newInverter, meterIndex)
					inverterIndex = findIndex(tree, 'name', newInverter['name'])
					newChildAtLocation(newPanels, inverterIndex)
					redraw()  // fix overlap nodes
					}
				}
			}
			percentage = Math.round(i/tkeys.length * 100).toFixed(2)
			in_use = false
		}
		else{
			redraw()
			removeProgressBar()
			is_use = false
			clearInterval(inter2)
		}
	}

	function progressBarUpdate(percentage) {
		if (document.getElementById('progBar') != undefined)
			document.getElementById('progColor').style.width = percentage + '%'
	}

	function noHouse(){
		for (x in hiddenNodes){
			if (hiddenNodes[x].objectType != undefined && hiddenNodes[x].objectType == 'house')
				return true
		}
		return false
	}

	if (noHouse()){
		alert('Houses have been hidden in the layout, please unfold it first.')
	} else {
		showProgressBar('Please wait. Solar is being generated.')
		// HACK: we do this extra timeout so the DOM gets execution priority and redraws the page.
		// setTimeout(walkAndAddSolar, 1000);	
		inter2 = setInterval(walkAndAddSolar, 10)
	}
	
}

// MODEL SAVING
function savePoster(name, user) {
	feederObject = {tree:tree, nodes:nodes, hiddenNodes:hiddenNodes, links:links, hiddenLinks:hiddenLinks, layoutVars:{'gravity':force.gravity(),'theta':force.theta(),'friction':force.friction(),'linkStrength':force.linkStrength(),'charge':force.charge(),'linkDistance':force.linkDistance()}, 			attachments:attachments}
	payload = {'name':name,
		   'feederObjectJson':JSON.stringify(feederObject),
		   "_csrf_token":"{{ csrf_token() }}",
		   ref: "{{ ref }}"  }
	post_to_url("/saveFeeder/" + user + "/" + name, payload)
}

function saveFeeder() {
	savePoster("{{ feederName }}","{{ owner }}")
}

function duplicateFeeder() {
	newName = prompt("Save copy as", $("#gridName").html())
	if (newName) {
		$.ajax({url:"/uniqObjName/Feeder/{{ currUser }}/" + newName}).done(function(data) {
			if (data.exists) {
				alert("You already have a feeder named " + newName)
				duplicateFeeder()
			} else {
				savePoster(newName,"{{ currUser}}")
			}
		})
	}
}

function savePrivateFeeder(){
	// Saving a private feeder is the same as duplicating a public feeder.
	duplicateFeeder()
}

function deleteFeeder() {
	confirmation = confirm("Are you sure you want to delete?")
	if (confirmation) {
		post_to_url("/delete/Feeder/{{ owner }}/{{ feederName }}")
	}
}

function publishFeeder() {
	newName = prompt("Publish a copy with name", $("#gridName").html())
	if (newName) {
		$.ajax({url:"/uniqObjName/Feeder/public/" + newName}).done(function(data) {
			if (data.exists) {
				alert("There is already a public feeder named " + newName)
				publishFeeder()
			} else {
				savePoster(newName, "public")
			}
		})
	}
}

// PINNING FUNCTIONS

function pinAll() {
	for (node in nodes) {
		gebi('pin' + nodes[node].treeIndex).setAttribute('class','nodeIsPinned')
		nodes[node].fixed = true
	}
	for (hNode in hiddenNodes) {
		gebi('pin' + hiddenNodes[hNode].treeIndex).setAttribute('class','nodeIsPinned')
		hiddenNodes[hNode].fixed = true
	}
	redraw()
}

function unPinAll() {
	for (node in nodes) {
		gebi('pin' + nodes[node].treeIndex).setAttribute('class','nodeNotPinned')
		nodes[node].fixed = false
	}
	for (hNode in hiddenNodes) {
		gebi('pin' + hiddenNodes[hNode].treeIndex).setAttribute('class','nodeNotPinned')
		hiddenNodes[hNode].fixed = false
	}
	redraw()
}

function toggleSelectedPin() {
	selNode = getSelectedNode()
	pinCircle = gebi('pin' + selNode.treeIndex)
	if (pinCircle.getAttribute('class') == 'nodeIsPinned') {
		pinCircle.setAttribute('class','nodeNotPinned')
		selNode.fixed = false
	} else {
		pinCircle.setAttribute('class','nodeIsPinned')
		selNode.fixed = true
	}
	redraw()
}

// LAYOUT MENU FUNCTIONS
function layoutMenuInit() {
	nodeCount = nodes.length + hiddenNodes.length
	gebi('nodesBox').innerHTML = nodeCount
	gebi('nodesPercShown').style.width = nodes.length*100/nodeCount + '%'
	gebi('nodesPercHidden').style.width = hiddenNodes.length*100/nodeCount + '%'
	gebi('gravityBox').value = force.gravity()
	gebi('thetaBox').value = force.theta()
	gebi('frictionBox').value = force.friction()
	gebi('linkStrengthBox').value = force.linkStrength()
	gebi('linkDistanceBox').value = force.linkDistance()
	gebi('chargeBox').value = force.charge()
}

function layoutMenuApply() {
	force.gravity(gebi('gravityBox').value)
	force.theta(gebi('thetaBox').value)
	force.friction(gebi('frictionBox').value)
	force.linkStrength(gebi('linkStrengthBox').value)
	force.linkDistance(gebi('linkDistanceBox').value)
	force.charge(gebi('chargeBox').value)
	force.start()
}

function updateHiddenPerc() {
	gebi('nodesPercShown').style.width = nodes.length*100/nodeCount + '%'
	gebi('nodesPercHidden').style.width = hiddenNodes.length*100/nodeCount + '%'
}

// FUNCTIONS FOR GRAPH FOLDING:
function hideNode(node) {
	// helper function to hide links:
	function hideLink(link) {
		hiddenLinks.push(links.splice(links.indexOf(link),1)[0])
	}
	// Pop the node of the nodes list and push it onto the hiddenNodes list:
	hiddenNodes.push(nodes.splice(nodes.indexOf(node),1)[0])
	// Pop/push any connected Links:
	toHideLinks = links.filter(function (lin) {return node.name == lin.source.name || node.name == lin.target.name})
	toHideLinks.map(hideLink)
	// Make the parents big!
	linkedNames = toHideLinks.map(function (x) {return x.source.name}).concat(toHideLinks.map(function (y) {return y.target.name}))
	toGrow = nodes.filter(function(thisNode) {return linkedNames.indexOf(thisNode.name) != -1})
	toGrow.map(function(d) {d.chargeMultiple = 1.5})
}

function showNode(node) {
	toInsert = hiddenNodes.splice(hiddenNodes.indexOf(node),1)[0]
	// Actually reveal.
	nodes.push(toInsert)
}

function showLink(link) {
	toInsert = hiddenLinks.splice(hiddenLinks.indexOf(link),1)[0]
	links.push(toInsert)
}

function foldOneLevel() {
	function isChild(node) {
		// We can apply the property of node in D3: weight, indicate number of links associated with it.
		if (node.weight == 1)
			return true
		else
			return false
	}
	// Find all the children:
	toHide = nodes.filter(isChild)
	// Hide them:
	toHide.map(hideNode)
	updateHiddenPerc()
	redraw()
}

function unfoldOneLevel() {
	// Find the hidden links that are connected to visible nodes:
	function attachedToVizNode(link) {
		return nodes.some(function(d) {return d.name == link.source.name || d.name == link.target.name})
	}
	linksToReveal = hiddenLinks.filter(attachedToVizNode)
	// Find the nodes that are attached to the revealed links:
	function attachedToRevealed(node) {
		return linksToReveal.some(function(d) {return node.name == d.source.name || node.name == d.target.name})
	}
	// Size the parents of revealed elements correctly.
	nodesToResize = nodes.filter(attachedToRevealed)
	nodesToResize.map(function(d) {d.chargeMultiple = 1})
	// Actually do the revealing.
	nodesToReveal = hiddenNodes.filter(attachedToRevealed)
	linksToReveal.map(showLink)
	nodesToReveal.map(showNode)
	updateHiddenPerc()
	redraw()
	d3.selectAll('.node').attr('stroke-width', function(d){return d.chargeMultiple* NODE_STROKE_WIDTH})
}

function unfoldAll() {
	while (hiddenLinks.length != 0) {
		links.push(hiddenLinks.pop())
	}
	while (hiddenNodes.length != 0) {
		nodes.push(hiddenNodes.pop())
	}
	nodes.map(function(d) {d.chargeMultiple = 1})
	updateHiddenPerc()

	redraw()
}

function unfoldAtSelected() {
	selNode = getSelectedNode()
	function attachedToSelected(link) {
		return selNode.name == link.source.name || selNode.name == link.target.name
	}
	linksToReveal = hiddenLinks.filter(attachedToSelected)
	// Find the nodes that are attached to the revealed links:
	function attachedToRevealed(node) {
		return linksToReveal.some(function(d) {return node.name == d.source.name || node.name == d.target.name})
	}
	nodesToReveal = hiddenNodes.filter(attachedToRevealed)
	// Size the parents of revealed elements correctly.
	nodesToResize = nodes.filter(attachedToRevealed)
	nodesToResize.map(function(d) {d.chargeMultiple = 1})
	// Actually do the revealing.
	linksToReveal.map(showLink)
	nodesToReveal.map(showNode)
	updateHiddenPerc()
	redraw()
}

function foldAtSelected() {
	selNode = getSelectedNode()
	function attachedToSelected(link) {
		return selNode.name == link.source.name || selNode.name == link.target.name
	}
	linksToHide = links.filter(attachedToSelected)
	// Find the nodes that are attached to the revealed links:
	function attachedToRevealed(node) {
		return linksToHide.some(function(d) {return node.name == d.source.name || node.name == d.target.name})
	}
	attachedNodes = nodes.filter(attachedToRevealed)
	nodesToHide = attachedNodes.filter(function(node) {return node.weight == 1 && node.name != selNode.name})
	// Size the parent correctly.
	if (nodesToHide.length > 0) {selNode.chargeMultiple = 1}
	// Actually do the hiding.
	nodesToHide.map(hideNode)
	updateHiddenPerc()
	redraw()
}

// Fold 2nd System
function foldSecSys() {
	// filter out all links in secondary system, put them into hiddenLinks
	secLinks = links.filter(function (link) {
		if (link.objectType == 'parentChild') {
			hiddenLinks.push(link)
			nodes[link.target.index].chargeMultiple = 1.5
			return true;
		} else if (link.target.objectType == 'triplex_meter' && link.source.objectType == 'gridNode') {
			hiddenLinks.push(link)
			nodes[link.source.index].chargeMultiple = 1.5
			return true;
		} else if (link.target.objectType == 'triplex_meter' && link.source.objectType == 'triplex_meter') {
			hiddenLinks.push(link)
			nodes[link.source.index].chargeMultiple = 1.5
			return true
		} else if (link.target.objectType == 'triplex_meter' && link.source.objectType == 'triplex_node') {
			hiddenLinks.push(link)
			nodes[link.source.index].chargeMultiple = 1.5
			return true
		} else if (link.target.objectType == 'triplex_node' && link.source.objectType == 'gridNode') {
			hiddenLinks.push(link)
			nodes[link.target.index].chargeMultiple = 1.5
			return true
		}
		else return false;
	})

	// remove secLinks from links and its nodes from nodes 
	// TODO: bugs with handling secLinks
	for (var i=links.length -1; i>=0; i--) {
		if (links[i].objectType == 'parentChild') {
			links.splice(i, 1)
		} else if (links[i].target.objectType == 'triplex_meter' && links[i].source.objectType == 'gridNode') {
			links.splice(i, 1)
		} else if (links[i].target.objectType == 'triplex_meter' && links[i].source.objectType == 'triplex_meter') {
			links.splice(i, 1)
		} else if (links[i].target.objectType == 'triplex_meter' && links[i].source.objectType == 'triplex_node') {
			links.splice(i, 1)
		} else if (links[i].target.objectType == 'triplex_node' && links[i].source.objectType == 'gridNode') {
			links.splice(i, 1)
		}
	}

	// put nodes into hiddenNodes
	secLinks.filter(function (link){
		if (!hiddenNodes.some(function (d){return (d.index == link.target.index)})){
			hiddenNodes.push(link.target);
		}
			
		if (!hiddenNodes.some(function (d){return (d.index == link.source.index)}))
			if (link.source.objectType!= 'gridNode')
				hiddenNodes.push(link.source);
	})

	// remove nodes in secondary system
	// TODO: bugs with handling hiddenNodes
	for (var i = nodes.length - 1; i>=0; i--){
		if (nodes[i].objectType == 'triplex_meter' || nodes[i].objectType == 'triplex_node' || nodes[i].objectType == 'ZIPload' || nodes[i].objectType == 'waterheater' || nodes[i].objectType == 'inverter' || nodes[i].objectType == 'solar' || nodes[i].objectType == 'house' || nodes.objectType == 'capacitor')
			nodes.splice(nodes[i].index, 1)
	}
	redraw()
}

// INIT FUNCTIONS FOLLOW:
d3.json('/getComponents/', function(json){components=json;fillComponentMenu()})
var apiAddress = "/feederData/{{ owner }}/{{ feederName }}/{{ modelFeeder }}"
d3.json(apiAddress, function (json) {
	tree = json['tree']
	attachments = json['attachments']
	// Regenerate the layout from the saved layout. For some insane reason, just cloning the list doesn't work.
	nodepop = json['nodes']
	while (nodepop.length != 0) {nodes.push(nodepop.pop())}
	linkpop = json['links']
	while (linkpop.length != 0) {links.push(linkpop.pop())}  
	hiddenNodePop = json['hiddenNodes']
	while (hiddenNodePop.length != 0) {hiddenNodes.push(hiddenNodePop.pop())}
	hiddenLinkPop = json['hiddenLinks']
	while (hiddenLinkPop .length != 0) {hiddenLinks.push(hiddenLinkPop.pop())}  
	//Gotta go through and make the links connect to their actual source and target objects. BAD DESIGN, D3!  
	for (li=0;li<links.length;li++) {
		sourceName = links[li].source.name
		targetName = links[li].target.name
		links[li].source = nodes[findIndex(nodes,'name',sourceName)]
		links[li].target = nodes[findIndex(nodes,'name',targetName)]
	}
	for (li2=0;li2<hiddenLinks.length;li2++) {
		sourceName = hiddenLinks[li2].source.name
		targetName = hiddenLinks[li2].target.name
		realSource = nodes[findIndex(nodes,'name',sourceName)]
		realSourceHidden = hiddenNodes[findIndex(hiddenNodes,'name',sourceName)]
		realTarget = nodes[findIndex(nodes,'name',targetName)]
		realTargetHidden = hiddenNodes[findIndex(hiddenNodes,'name',targetName)]
		if (undefined == realSource) {hiddenLinks[li2].source = realSourceHidden} else {hiddenLinks[li2].source = realSource}
		if (undefined == realTarget) {hiddenLinks[li2].target = realTargetHidden} else {hiddenLinks[li2].target = realTarget} 
	}

	// Regenerate the layout variables:
	// TODO: make this whole layout variables code much less hackish. We get/set like 5 different ways and times in this file.
	if (undefined != json['layoutVars']) {
		function safeSet(value) {
			if (json['layoutVars'].hasOwnProperty(value)) {force[value](json['layoutVars'][value])}
		}
		safeSet('gravity')
		safeSet('theta')
		safeSet('friction')
		safeSet('linkStrength')
		safeSet('linkDistance')
		safeSet('charge')
		xScale = json['layoutVars']['xScale']
		yScale = json['layoutVars']['yScale']
	}
	// set scale range
	options = {
		"xmax" : window.innerWidth / xScale,
		"xmin" : 0,
		"ymax" : window.innerHeight / yScale,
		"ymin" : 0,
	}
	// And go at it:
	draw()
	layoutMenuInit()
})

</script>
</body>
