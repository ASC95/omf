<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<style >
            /* Define global css variables */
            :root {
                --header-height: 25px;
                --header-padding-top: 10px;
                --header-padding-bottom: 10px;
            }
			* { 
                font-family: Helvetica, Arial, Sans-Serif;
            }
			div.divButton {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				cursor: pointer;
				cursor: hand;
				position:fixed;
				width:30px;
				height:30px;
				text-align:center;
				font-size:30px;
				line-height:30px;
				color:white;
			}
			body {margin:0px;}
			a {
				text-decoration: none;
                color: mediumseagreen;
                /*color: black;*/
			}
            a:visited {
                color: seagreen;
            }

            /* SVG */

            /* This is the element that acts as a hook for svg-pan-zoom.js to attach a viewport, which it creates itself */
			svg#svgContainer {
                /* width must be 100%, meaning 100% of the document */
				width: 100%; 
                /* height must be manually set to a hard value */
				height: calc(100vh - var(--header-height) - var(--header-padding-bottom) - var(--header-padding-top) - 5px);
                /* overflow: hidden is set by svg-pan-zoom.js itself. No need to change that here. */
			}
			#saveButton {
				float:right;
			}

            div#loadingMessage {
                width: 100%;
                height: 100%;
				/*background-color: rgba(0,0,0,0.4); */
                background-color: white;
                position: fixed;
                top: 0px;
            }

			/* Load Spinner */

			.loader {
				margin: 60px auto;
				font-size: 10px;
				position: relative;
				text-indent: -9999em;
				border-top: 1.1em solid rgba(255, 255, 255, 0.2);
				border-right: 1.1em solid rgba(255, 255, 255, 0.2);
				border-bottom: 1.1em solid rgba(255, 255, 255, 0.2);
				border-left: 1.1em solid #ffffff;
				-webkit-transform: translateZ(0);
				-ms-transform: translateZ(0);
				transform: translateZ(0);
				-webkit-animation: load8 1.1s infinite linear;
				animation: load8 1.1s infinite linear;
			}
			.loader,
			.loader:after {
				border-radius: 50%;
				width: 10em;
				height: 10em;
			}
			@-webkit-keyframes load8 {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}
			@keyframes load8 {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}

            /**************************************************
            // Header and menu links
            **************************************************/

			#header {
				width:100%;
				height: var(--header-height);
				padding-top: var(--header-padding-top);
				padding-bottom: var(--header-padding-bottom);
				background:black;
                /*position: absolute;*/
				/*min-width:1000px;*/
			}
            #helpDiv a {
                color: white;
            }
			/*#menuLeft{ height:40px; float:left; font-size:medium; color:white; margin-left:5px;}*/
			#menuRight{ 
				/*height:40px;
				font-size:medium;
				color:white;*/
				float:right;
				display:flex;
				/*justify-content: space-between;
				width: 162px*/
			}
			/*#arrow { font-size:8pt; position:absolute; margin-top:2px; margin-left:4px; display:inline; }*/
            .headerDiv {
                margin-right: 15px;
                cursor: pointer;
            }
			ul.menu {
				position: absolute;
				top: 100%;
				left: 0;
				z-index: 1000;
				min-width: 100px;
				padding: 5px 0px 5px 0px;
				margin: 0px;
				list-style: none;
				display: none;
				text-align:left;
				background-color:#F8F8F8;
				padding:0;
				/*border: 1px solid #CCC;*/
				-webkit-border-radius: 5px;
				-moz-border-radius: 5px;
				border-radius: 5px 0px 5px 5px;
				-webkit-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				-moz-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				-webkit-background-clip: padding-box;
			}
			ul.menu.right { 
                right:0;
                left:auto;
                padding:5px 0px 5px 0px;
                overflow-y:auto;
                overflow-x:hidden;
                max-height:550px; 
                cursor: pointer;
            }
			ul.menu.left { right:auto; left:auto; padding:0 0 0 0; }
			ul.menu.center { right:auto; left:-45%; }
			ul.menu li { 
                padding: 4px; 
                }
			ul.menu li:hover { background:green; color:white; }
			ul.menu li:hover a { color:white; }
			ul.menu a { 
                display:block;
                color:black;
                /*padding:4px;*/
                }
			ul.menu a:hover {color:white;}
			ul.menu { display:block; color:black; padding:4px; }
			ul.menu ul.menu:hover, ul.menu:visited:hover { color:white; }
			div.buttonGroup { display:inline-block; position:relative; }
			button.pill {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				color:white;
				font-size:medium;
				width: auto;
				height:35px;
				margin: 0px;
				margin-top:-5px;
				padding:0.3em;
				border-radius: 5px 5px 0 0;
				background-color:#E0E0E0;
				display:inline-block;
				border:none;background:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;
				white-space: nowrap;
				display:inline-block;
                cursor: pointer;
			}
			button.pill:hover{background:transparent;}

            /**************************************************
            // Modal Dialogs
            **************************************************/

            #loadModalTable {
                width: 890px;
            }
            /*#milsoftInput {
                width: 100%;
            }*/
            #progressModalCancel {
                background-color: crimson;
            }
            #progressModal {
                z-index: 1;
            }
            #massAddModal .modalContent {
                width: 400px;
            }
            #climateModal label {
                white-space: nowrap;
            }
            #anonymizeModal {
                white-space: nowrap;
            }
			.modal {
                position: fixed;
                top: 0px;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
				background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
			}
	 		.modalContent {
                padding: 20px;
                border-radius: 10px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: space-evenly;
				background-color: #fefefe;
                /*height: 380px;*/
                overflow: hidden;
			}
            .modalInput {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
                width: 100%;
            }
            .modalInputLine {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
            }
            .modalButton {
                font-size: medium;
                background-color: seagreen;
                -webkit-border-radius: 5px;
                -moz-border-radius: 5px;
                border-radius: 5px;
                border: none;
                color: white;
                cursor: pointer;
                padding: 4px 6px 4px;
            }
            #cancelButton {
                background-color: crimson;
            }
            .modalContent td:nth-of-type(2) {
                text-align: right;
            }
            .modalTableHeader {
                text-align: left;
            }
            .modalTableRow {
                width: 50%;
            }
            .scrollableList {
                overflow: auto;
                height: 240px;
                list-style-type: none;
                margin: 0px 0px 0px 20px;
                padding: 0;
                cursor: pointer;
            }
            .feederItem {
                padding: 5px 5px 5px 5px;
                margin: 10px 0px 10px 0px;
            }
            .feederItem:hover {
                color: white;
                background-color: green;
            }
            /*
            input:valid {
                border: 1px solid white; 
            }
            */
            input:invalid {
                border: 1px solid red;
            }            

            /* Tree tables */

            .buttonRow {
                /*text-align: center;*/
            }
            .buttonRow button {
                margin-right: 5px;
            }
            /*
            .treeTable {
                background-color: white; 
            }
            .treeTable tr {
            }
            .treeTable tr:last-child {
                border: 0px;
            }
            */
            thead td {
                
            }
            .tableInput {
                font-size: small;
                background-color: gainsboro;
                padding: 3px;
                border: 0px;
            }
            .deleteButton {
                background-color: #CC0000;
                /*padding: 1px 7px 1px 7px;*/
            }
            /* TODO: might need to delete this rule */
            .editButton {
                font-size: small;
                /*width: 100%;*/
            }

			/* dataTable */

            #descriptionTables {
                position: absolute;
                top: 0px;
                height:0px;
            }

            #selectionTable {
                position: absolute;
                top: 0px;
                height:0px;
            }

            .formContainer {
				/*position: fixed;*/
				/*top: 55px;*/
                height:0px;
				/*right: 5px;*/
            }

			.dataTable {
                position: fixed;
				top: 55px;
				border:1px solid black;
				border-collapse: collapse;
                /*display: block;*/
                overflow-x: hidden;
				max-height: 80%;
			}
            .dataTable tr {
                border-bottom: 1px solid black;
            }
            .dataTable tr:last-child {
                border: 0px;
            }
            /*.dataTable p {
                margin: 0px;
            }*/
            .tableTitle {
                background-color: black;
                color: white;
            }
			tbody {
				/*border: 1px solid black;*/
                border-collapse: collapse;
			}
			td {
				background:white;
				padding: 5px;
				border-collapse: collapse;
			}
			th {
				/*font-weight: normal;*/
				/*background:black;*/
				/*color:white;*/
				padding: 5px;
			}
			/*
            #editButtonRow button {
				font-size: small;
				color: white;
				background: seagreen;
				padding: 5px;
				border-radius: 5px;
				width: 100%;
			}
            */
            /*
			#editButtonRow button:hover {
				outline:0;
				outline: none; 
				background:mediumseagreen;
			}
            */
        </style>
        <link rel="stylesheet" href="/static/jquery-ui.min.css">
        <script type="text/javascript" src="/static/jquery.js"></script>
        <script type="text/javascript" src="/static/jquery-ui.min.js"></script>
		<script type='text/javascript' src='/static/svg-pan-zoom.js'></script>
		{% if jasmine %}{{ jasmine | safe }}{% endif %}
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Largest.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Norfork.js'></script> -->
	</head>
	<!--<body onkeypress='hotkeys()' style='width:100%;height:100%'>-->
	<body style='width:100%;height:100%'>
        <div id="loadingMessage">
            <p style="font-size:60pt; text-align:center; width:100%;">Feeder Loading...</p>
        </div>
		<!-- Controls -->
		<div style='background:dimgrey; top:55px; left:5px' class='divButton' onclick='window.panZoom.zoomIn()' title='Zoom In'>+</div>
		<div style='background:dimgrey; top:95px; left:5px' class='divButton' onclick='window.panZoom.zoomOut()' title='Zoom Out'>-</div>
		<div style='background:dimgrey; top:135px; left:5px' class='divButton' onclick='window.panZoom.reset()' title='Reset Zoom'>R</div>
		<div style='background:dimgrey; top:175px; left:5px;' class='divButton' onclick='scaleTo(parseFloat(prompt("Scale line thickness by this multiple:", scaleLevel)))' title='Scale To'>S</div>
		<!-- <div style='background:navy; top:215px; left:5px' id='saveLink' class='divButton' onclick='saveSvg()' title='Save File' download>S</div> -->
		<!-- Menu Bar -->
		<div id='header'>
			<div id="menuRight">
				<div id="helpDiv" class="headerDiv">
					<div class="buttonGroup">
						<button class='pill' type = 'submit'>
							<a id='helpButton' href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit' target='_blank'>Help</a>
						</button>
					</div>
                </div>
                <div id="editDiv" class="headerDiv">
					<div class="buttonGroup">
                        <button id="addOps" class='pill' onclick='dropPill(this, "Edit")'>Edit &#x25BE;</button>
                        <ul id="editMenu" class='menu right' style="display: none">
                            <!--<li>Zoom To Fit</li>-->
                            <!--<li>Zoom Reset</li>-->
                            <li>Static Loads to Houses</li>
                            <li data-web>Scada Loadshapes...</li>
                            <li data-web>Add AMI Profiles...</li>
                            <li>Find...</li>
                            <li>Mass Add...</li>
                            <li>Mass Edit...</li>
                            <li>Attachments...</li>
                            <li data-web>Climate...</li>
                            <li data-web>Anonymization...</li>
                        </ul>
                    </div>
                </div>
				<div id="addDiv" class="headerDiv">
					<div class="buttonGroup">
						<button id="addOps" class='pill' onclick='dropPill(this, "Add")'>Add &#x25BE;</button>
						<ul id='componentList' class='menu right' style="display: none">
					</div>
				</div>
                {% if showFileMenu %}
				<div id="fileDiv" class="headerDiv">
					<div class='buttonGroup'>
						<button id="fileOps" class='pill' onclick='dropPill(this, "File")'>File &#x25BE;</button>
                        <ul id='fileMenu' class='menu right' style="display: none">
							<li data-web>Save</li>
							<li>View Raw Data</li>
							<li data-web>Rename</li>
                            <li data-web>Load from Model...</li>
							<li data-web>New Blank Feeder...</li>
							<li data-web>Windmil Conversion...</li>
							<li data-web>GridLAB-D Conversion...</li>
							<li data-web>CYMDIST Conversion...</li>
						</ul>
					</div>
                </div>
                {% endif %}
			</div>
        </div>
        <!-- Svg container -->
        <!--<div id="svgContainerWrapper" style="height: auto; background-color: blue;">-->
        <div id="svgContainerWrapper" style="height: auto;">
            <svg id='svgContainer' xmlns='http://www.w3.org/2000/svg'>
                <style type="text/css">
                    <![CDATA[
                    .house {fill:blue;}
                    .triplex_meter {fill:orange;}
                    .underground_line {stroke:gray;}
                    .transformer {stroke:orange;}
                    .regulator {stroke:red;}
                    line {stroke:black;}
                    line.parentChild {stroke:LightGrey;}
                    circle {stroke:white; fill:gray;}
                    line.selected, circle.selected {stroke:lime;}
                    ]]>
                </style>
            </svg>
        </div>
        <!-- Modals -->
		<div id='findModal' class="modal" style="display: none">
			<div class='modalContent'>
				<table>
					<tr>
                        <td>Term</td>
                        <td><input id='searchInput' type='text' value="Enter a search term" class="modalInput"></td>
                        <td id="searchCount"></td>
					</tr>
					<tr>
						<td><button id="findPrevious" class="modalButton">Previous</button></td>
						<td><button id="findNext" class="modalButton">Next</button></td>
						<td><button class="modalButton" onclick='toggleElementDisplay("findModal")'>Cancel</button></td>
					</tr>
				</table>
			</div>
        </div>
        <div id="progressModal" class="modal" style="display: none">
            <div class="modalContent">
                <img src="/static/spinner.gif">
                <h2>text...</h2>
                <button class="modalButton" id="progressModalCancel">Cancel</button>
            </div>
        </div>
        <div id="loadModal" class="modal" style="display: none">
            <div class="modalContent">
                <table id="loadModalTable">
                    <tbody>
                        <tr>
                            <th class="modalTableHeader modalTableRow">Public Feeders</th>
                            <th class="modalTableHeader modalTableRow">My Feeders</th>
                        </tr>	
                        <tr>
                            <td class="modalTableRow"> 
                                <ul id="publicFeederList" class="scrollableList"></ul>
                            </td>
                            <td class="modalTableRow"> 
                                <ul id="userFeederList" class="scrollableList"></ul>
                            </td>
                        </tr>
                    </tbody>
                </table>
                <button onclick="toggleElementDisplay('loadModal')" class="modalButton">Cancel</button>
            </div>
        </div>
        <div id="blankFeederModal" class="modal" style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm({formId:'blankFeederForm'}); return false;"
                 action="/newBlankFeeder/{{thisOwner}}" id="blankFeederForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <input type='hidden' name='referrer' value='distribution'/>
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Blank Feeder</th>
                            </tr>
                            <tr>
                                <td><label for="blankFeederInput">Name</label></td>
                                <td>
                                    <!-- TODO: add better validation than just the 'required' attribute-->
                                    <input type='text' required id="blankFeederInput" name='feederNameNew' class="modalInput"/>
                                </td>
                            </tr>
                            <tr>
                                <td><button type="button" onclick="toggleElementDisplay('blankFeederModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Create</button></td>
                            </tr>
                        </tbody>
                    </table>
                </form>
            </div>
        </div>
        <div id='milsoftModal' class='modal' style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm({formId:'milsoftForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'milsoftInput'}); return false;"
                 action="/milsoftImport/{{thisOwner}}" id="milsoftForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <!--<input type='hidden' name='referrer' value='distribution'/>-->
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Milsoft Conversion</th>
                            </tr>
                            <tr>
                                <td><label for="milsoftInput">Name</label></td>
                                <td>
                                    <!-- TODO: add better validation than just the 'required' attribute-->
                                    <input type='text' required id="milsoftInput" name='feederNameM' class="modalInput"/>
                                </td>
                            </tr>
                            <tr>
                                <td>Data File (.std)</td>
                                <td><input type='file' required id="stdFile" name='stdFile' accept='.std' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td>Equipment File (.seq)</td>
                                <td><input type='file' required id="seqFile" name='seqFile' accept='.seq' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td><button type="button" onclick="toggleElementDisplay('milsoftModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Import</button></td>
                            </tr>
                        </tbody>
                    </table> 
                </form>
            </div>
        </div>
        <div id='gridlabdModal' class='modal' style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm({formId:'gridlabdForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'gridlabdInput'}); return false;"
                 action="/gridlabdImport/{{thisOwner}}" id="gridlabdForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <!--<input type='hidden' name='referrer' value='distribution'/>-->
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">GridLab-D Conversion</th>
                            </tr>
                            <tr>
                                <td><label for="gridlabdInput">Name</label></td>
                                <td>
                                    <!-- TODO: add better validation than just the 'required' attribute-->
                                    <input type='text' required id="gridlabdInput" name='feederNameG' class="modalInput"/>
                                </td>
                            </tr>
                            <tr>
                                <td>Data File (.glm)</td>
                                <td><input type='file' required id="csvFile" name='glmFile' accept='.glm' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td><button type="button" onclick="toggleElementDisplay('gridlabdModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Import</button></td>
                            </tr>
                        </tbody>
                    </table>
                </form>
            </div>
        </div>
        <div id='cymeModal' class='modal' style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm({formId:'cymeForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'cymeInput'}); return false;"
                 action="/cymeImport/{{thisOwner}}" id="cymeForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <!--<input type='hidden' name='referrer' value='distribution'/>-->
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Cyme Conversion</th>
                            </tr>
                            <tr>
                                <td><label for="cymeInput">Name</label></td>
                                <td>
                                    <!-- TODO: add better validation than just the 'required' attribute-->
                                    <input type='text' required id="cymeInput" name='feederNameC' class="modalInput"/>
                                </td>
                            </tr>
                            <tr>
                                <td>Network File (.mdb)</td>
                                <td><input type='file' required id="mdbNetFile" name='mdbNetFile' accept='.mdb' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td><button type="button" onclick="toggleElementDisplay('cymeModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Import</button></td>
                            </tr>
                        </tbody>
                    </table>
                </form>
            </div>
        </div>
        <div id="scadaModal" class="modal" style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm({formId:'scadaForm', pollUrl:'/checkScadaLoadshape/{{thisModelName}}'}); return false;"
                 action="/scadaLoadshape/{{thisOwner}}/{{thisFeederName}}" id="scadaForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <!--<input type='hidden' name='referrer' value='distribution'/>-->
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Scada Loadshapes</th>
                                <th style='float:right;'>
                                    <a href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit#scada-loadshapes' target='_blank'>Format Help</a>
                                </th>
                            </tr>
                            <tr>
                                <td>File containing Scada load data (.csv)</td>
                                <td><input type='file' required id="scadaFile" name='scadaFile' accept='.csv' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td colspan='100%'>Note: Model "Simulation Start Date" should lie within the Scada load's dates.</td>
                            </tr>
                            <tr>
                                <td><button type="button" onclick="toggleElementDisplay('scadaModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Import</button></td>
                            </tr>
                        </tbody>
                    </table>
                </form>
            </div>
        </div>
        <div id='amiModal' class='modal' style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm({formId:'amiForm', pollUrl:'/checkLoadModelingAmi/{{thisModelName}}'}); return false;"
                 action="/loadModelingAmi/{{thisOwner}}/{{thisFeederName}}" id="amiForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <!--<input type='hidden' name='referrer' value='distribution'/>-->
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">AMI Profiles</th>
                                <th style='float:right;'>
                                    <a href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit' target='_blank'>Format Help</a>
                                </th>
                            </tr>
                            <tr>
                                <td>File containing AMI load data (.csv)</td>
                                <td><input type='file' required id="amiFile" name='amiFile' accept='.csv' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td colspan='100%'>Note: Model "Simulation Start Date" should lie within the AMI profiles's dates.</td>
                            </tr>
                            <tr>
                                <td><button type="button" onclick="toggleElementDisplay('amiModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Import</button></td>
                            </tr>
                        </tbody>
                    </table>
                </form>
            </div>
        </div>
        <div id='massAddModal' class='modal' style="display: none">
            <div class='modalContent'>
                <form onsubmit="massAdd(); toggleElementDisplay('massAddModal'); return false;">
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Mass Add</th>
                            </tr>
                            <tr>
                                <td>Add component:</td>
                                <td><select id='componentSelect'></select></td>
                            </tr>
                            <tr>
                                <td>To each:</td>
                                <td><select id='massAddTargetSelect'></select></td>
                            </tr>
                            <tr>
                                <td>With probability for each attachment (float between 0.0 and 1.0):</td>
                                <td><input type='text' pattern="^(1.0)|(0?(\.\d+))$" required id='percent' value='1.0' class="modalInput"/></td>

                            </tr>
                            <tr>
                                <td><button onclick="toggleElementDisplay('massAddModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Apply</button></td>
                            </tr>
                        </tbody>
                    </table>
                </form>
            </div>
        </div>
        <div id='massEditModal' class='modal' style="display: none">
            <div class='modalContent'>
                <table>
                    <tbody>
                        <tr>
                            <th class="modalTableHeader">Mass Edit</th>
                        </tr>
                        <tr>
                            <td>For each object of type</td>
                            <td><select id='massEditTargetSelect'></select></td>
                            <td>with attribute</td>
                            <td><input type='text' id='massEditAttribute' class="modalInput"></td>
                        </tr>
                        <tr>
                            <td><input type="radio" name="attributeOperation" value="addTo">Add value to attribute</td>
                            <td><input type='text' id='addToValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                        </tr>
                        <tr>
                            <td><input type="radio" name="attributeOperation" value="delete">Delete Attribute</td>
                        </tr>
                        <tr>
                            <td><input type="radio" name="attributeOperation" value="change">Change attribute to</td>
                            <td><input type='text' id='changeValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                        </tr>
                        </tr>
                        <tr>		
                            <td><input type="radio" name="attributeOperation" value="multiplyBy">Multiply attribute by</td>
                            <td><input type='text' id='multiplyValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            <td style="text-align: center" >and add</td>
                            <td><input type='text' id='andAddValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                        </tr>
                        <tr>
                            <td>Or</td>
                        </tr>
                        <tr>
                            <td><input type="radio" name="attributeOperation" value="addAttribute"> Add new attribute</td>
                            <td><input type='text' id='newAttributeKey' class="modalInput"></td>
                            <td style="text-align: center">with value</td>
                            <td><input type='text' id='newAttributeValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                        </tr>
                        <tr>
                            <td colspan="2">
                                <button onclick="toggleElementDisplay('massEditModal')" class="modalButton" style="float: right">Cancel</button>
                            </td>
                            <td>
                                <button onclick="massEdit(); toggleElementDisplay('massEditModal');" class="modalButton" style="float: left">Apply</button>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div id='attachmentsModal' class='modal' style="display: none">
            <div class='modalContent'>
                <table>
                    <tbody>
                        <tr>
                            <td><select id='attachmentSelect'></select></td>
                        </tr>
                        <tr>
                            <td><button onclick="toggleElementDisplay('attachmentsModal')" class="modalButton">Cancel</button></td>
                            <td><button onclick="toggleElementDisplay('attachmentsModal'); editAttachment()" class="modalButton">Select</button></td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div id='editAttachmentModal' class='modal' style="display: none">
            <div class='modalContent'>
                <table>
                    <tbody>
                        <tr>
                            <td id='attachmentTd'></td>
                        </tr>
                        <tr>
                            <td>
                                <textarea rows='25' cols='80' id='editAttachmentBox'></textarea>
                            </td>
                        </tr>
                        <tr>
                            <td><button onclick="toggleElementDisplay('editAttachmentModal')" class="modalButton">Cancel</button></td>
                            <td><button onclick="saveAttachment(); toggleElementDisplay('editAttachmentModal');" class="modalButton">Save</button></td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div id='climateModal' class='modal' style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm({formId:'climateForm', pollUrl:'/checkClimateChange/{{thisOwner}}/{{thisModelName}}'}); return false;"
                action="/climateChange/{{thisOwner}}/{{thisFeederName}}" id="climateForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <!--<input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>-->
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <!--<input type='hidden' name='referrer' value='distribution'/>-->
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Climate Change</th>
                            </tr>
                            <tr>
                                <td>
                                    <input id='historicalImport' type='radio' name='climateImportOption' value='historicalImport'>
                                    <label for='historicalImport'>Historical Weather</label>
                                </td>
                            </tr>
                            <tr>
                                <td><label for='startDate'>Start Date (YYYY-MM-DD):</label></td>
                                <td><input id='startDate' type='text' name='startDate' pattern='^\d{4}-\d{2}-\d{2}$' class="modalInput"></td>
                            </tr>
                            <tr>
                                <td><label for='endDate'>End Date (YYYY-MM-DD):</label></td>
                                <td><input id='endDate' type='text' name='endDate' pattern='^\d{4}-\d{2}-\d{2}$' class="modalInput"></td>
                            </tr>
                            <tr>
                                <td><label for='airport'>Airport Code:</label></td>
                                <td><input id='airport' type='text' name='airport' pattern='^[A-Z]{3}$' class="modalInput"></td>
                            </tr>
                            <tr>
                                <td>
                                    <input id='tmyImport' type='radio' name='climateImportOption' value='tmyImport'>
                                    <label for='tmyImport'>tmy Import</label>
                                </td>
                            </tr>
                            <tr>
                                <td><label for='zipCode'>Zip Code:</label></td>
                                <td><input id='zipCode' type="text" name="zipCode" pattern='^\d{5}$' class="modalInput"></td>
                            </tr>
                            <tr>
                                <td><button type="button" onclick="toggleElementDisplay('climateModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Apply</button></td>
                            </tr>
                        </tbody>
                    </table>
                </form>
            </div>
        </div>
        <div id='anonymizeModal' class='modal' style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm({formId:'anonymizeForm', pollUrl:'/checkAnonymize/{{thisOwner}}/{{thisModelName}}'}); return false;"
                action='/anonymize/{{thisOwner}}/{{thisFeederName}}' id="anonymizeForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <!--<input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>-->
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <!--<input type='hidden' name='referrer' value='distribution'/>-->
                    <table>
                        <tbody>
                            <tr><th>Anonymization</th></tr>
                            <tr><th class="modalTableHeader">Names and labels:</th></tr>
                            <tr>
                                <td>
                                    <select name='anonymizeNameOption'>
                                        <option value="noChange">No change</option>
                                        <option value="pseudonymize">Pseudonymize</option>
                                        <option value="randomize">Randomize</option>
                                    </select>
                                </td>
                            </tr>
                            <tr><th class="modalTableHeader">Locations:</th></tr>
                            <tr>
                                <td>
                                    <input type='radio' id='noChange' name='anonymizeLocationOption' value='noChange' checked>
                                    <label for='noChange'>No Change</label>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <input type='radio' id='translation' name='anonymizeLocationOption' value='translation'>
                                    <label for='translation'>Translate</label>
                                </td>
                            </tr>
                            <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='translateRight' class="modalInputLine"> [ft] to the right and</td></tr>
                            <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='translateUp' class="modalInputLine"> [ft] up with a</td></tr>
                            <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='rotate' class="modalInputLine"> [degree] rotation.</td></tr>
                            <tr>
                                <td>
                                    <input type='radio' id='randomize' name='anonymizeLocationOption' value='randomize'>
                                    <label for='randomize'>Random (Force Layout)</label>
                                </td>
                            </tr>
                            <tr><th class="modalTableHeader">Electrical properties:</th></tr>
                            <tr>
                                <td>
                                    <input type='checkbox' id='modifyLengthSize' name='modifyLengthSize' value='modifyLengthSize'>
                                    <label for='modifyLengthSize'>Modify conductor length and cable size</label>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <input type='checkbox' id='smoothLoadGen' name='smoothLoadGen' value='smoothLoadGen'>
                                    <label for='smoothLoadGen'>Smooth AMI Loadshapes</label>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <input type='checkbox' id='shuffleLoadGen' name='shuffleLoadGen' value='shuffleLoadGen'>
                                    <label for='shuffleLoadGen'>Shuffle loads and generators:</label>
                                    <input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='shufflePerc' class="modalInputLine"> [%]</label>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <input type='checkbox' id='addNoise' name='addNoise' value='addNoise'>
                                    <label for='addNoise'>Add noise:</label>
                                    <input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='noisePerc' class="modalInputLine"> [%]</label>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <button type="button" onclick="toggleElementDisplay('anonymizeModal')" class="modalButton">Cancel</button>
                                    <button type="submit" class="modalButton" style="float: right">Apply</button>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </form>
            </div>
        </div>
        <!-- Modals-->
        <div id="descriptionTables"></div>
        <div id="selectionTable"></div>
	</body>
</html>
<script id='componentsInsert'>const globalComponents = {% if components %}{{ components | safe }}{% else %}null{% endif %}; 
</script>
<script id='feederInsert'>const readFeeder = {% if thisFeederData %}{{ thisFeederData | safe }}{% else %}null{% endif %}; 
</script>
<script id='panZoomInsert'>
</script>
<script type='text/javascript'>
//"use strict";
let thisFeederName = "{% if thisFeederName %}{{ thisFeederName | safe }}{% else %}null{% endif %}";
const thisFeederNum = {% if thisFeederNum %}{{ thisFeederNum | safe }}{% else %}null{% endif %}; 
const thisModelName = "{% if thisModelName %}{{ thisModelName | safe }}{% else %}null{% endif %}"; 
const thisOwner = "{% if thisOwner %}{{ thisOwner | safe }}{% else %}null{% endif %}"; 
const publicFeeders = {% if publicFeeders %}{{ publicFeeders | safe }}{% else %}null{% endif %};
const userFeeders = {% if userFeeders %}{{ userFeeders | safe }}{% else %}null{% endif %}; 
const writeFeeder = deepCopy(readFeeder);
/* The globalTree can only be created after the entire file has been parsed */
let gTreeWrapper; 
let gViewport; 
let globalLonOffset = null;
let globalLatOffset = null;
// Globals to keep track of mouse coordinates
let downX, downY, upX, upY;
//let newNodeGenObj = {}; // What does this do?

//**************************************************
// Deprecated globals
//**************************************************

// Scale that all SVG objects are drawn at
let scaleLevel = 1.0; 

function saveSvg() {
	// Create an SVG that can be saved.
	alert('We are redirecting you to a static version of the SVG that you can save as a .svg file.')
	var svg = document.getElementById('svgContainer').outerHTML
	var win = window.open()
	win.document.write(svg)
}

function downloadTextFile() {
	// WARNING! Performance is very bad because the JSON is enormous! This can hang your browser!
	alert('We are opening a window with JSON in it that you can save as a .json file.')
	var modJson = JSON.stringify(writeFeeder);
	var win = window.open();
	win.document.write(modJson);
}

//TODO: keep the offset part but delete these functions
/**
 * Adds a circle to the svg.
 * @param {number} r - Has something to do with the scale factor of the svg. Everything seems to start with r=2
 * TODO: Switch the x and y arguments? This function (and addLine()) might be PART of the reason the graph gets flipped around vs. the 
 * graph in gridEdit.html. Or is gridEdit.html the one that is fipped??!!??
 */
//function addCircle(x,y,r,id,myClass) {
//	const svgOb = document.getElementsByClassName('svg-pan-zoom_viewport')[0];
//	const aCirc = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
//	aCirc.setAttribute('cx', x - globalLonOffset);
//	aCirc.setAttribute('cy', y - globalLatOffset);
//	aCirc.setAttribute('r', r);
//	aCirc.setAttribute('id', id);
//	aCirc.setAttribute('class', myClass);
//	aCirc.setAttribute('stroke-width', 0.5);
//	svgOb.appendChild(aCirc);
//}
//
///*
// * Note that longitude should refer to a x coordinate and latitude should refer to an y coordinate.
// * @param {number} x1 - The longitude of the "from" node of this line.
// * @param {number} y1 - The latitude of the "from" node of this line.
// * @param {number} x2 - The longitude of the "to" node of this line.
// * @param {number} y2 - The latitude of the "to" node of this line.
// */
//function addLine(x1, y1, x2, y2, id, myClass) {
//	const svgOb = document.getElementsByClassName('svg-pan-zoom_viewport')[0];
//	const aLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
//	aLine.setAttribute('x1', x1 - globalLonOffset);
//	aLine.setAttribute('y1', y1 - globalLatOffset);
//	aLine.setAttribute('x2', x2 - globalLonOffset);
//	aLine.setAttribute('y2', y2 - globalLatOffset);
//	aLine.setAttribute('id', id);
//	aLine.setAttribute('class', myClass);
//	let w;
//	if (myClass.indexOf('p2') !== -1) {
//		w = 2
//	} else if (myClass.indexOf('p3') !== -1) {
//		w = 3
//	} else if (myClass.indexOf('parentChild') !== -1) {
//		w = 0.5
//	} else {
//		w = 1
//	}
//	aLine.setAttribute('stroke-width', w);
//	svgOb.appendChild(aLine);
//}

/**
 * TODO: add unit tests
 */
function createViewport(treeWrapper, svgContainer) {
    const tree = treeWrapper.tree;
    const keys = Object.keys(tree);
    // Set the longitude and latitude to be within the bounds of the provided data
    const firstKey = keys.find(key => {
        return tree[key].longitude !== undefined && tree[key].latitude !== undefined;
    });
    let minLon = parseFloat(tree[firstKey].longitude);
    let maxLon = minLon;
    let minLat = parseFloat(tree[firstKey].latitude);
    let maxLat = minLat;
    /* Find the minimum and maximum longitudes and latitudes. That's not good enough. I need to find a RANGE of values
    for each and scale the viewport to the RANGE
    */
    keys.forEach(key => {
        let lon = tree[key].longitude;
        let lat = tree[key].latitude;
        if (lon !== undefined && lat !== undefined) {
            lon = parseFloat(lon);
            lat = parseFloat(lat);
            if (lon < minLon) {
                minLon = lon;
            }
            if (lon > maxLon) {
                maxLon = lon;
            }
            if (lat < minLat) {
                minLat = lat;
            }
            if (lat > maxLat) {
                maxLat = lat;
            }
        }
    });
    //const translatedMaxLon = maxLon - minLon;
    const translatedMaxLon = (maxLon - minLon);
    globalLonOffset = minLon;
    const translatedMaxLat = maxLat - minLat;
    globalLatOffset = minLat;
    // Create the viewport
    svgContainer.setAttribute('viewBox',`0 0 ${translatedMaxLon} ${translatedMaxLat}`);
	window.panZoom = svgPanZoom('#svgContainer', {
        /* These are equal to the default values */
		//zoomEnabled: true,
		//controlIconsEnabled: false,
        //center: true,
		//fit: true,
        //contain: true,
        dblClickZoomEnabled: false,
        zoomScaleSensitivity: 0.2,
        minZoom: 0.25,
		maxZoom: 100
    });
}

/**
 * TODO: add unit tests
 * Listener on the SVG object that handles user clicks.
 */
function svgClick(downEvent, upEvent) {
    if (downEvent.clientX !== upEvent.clientX || downEvent.clientY !== upEvent.clientY) {
		// Ignore drags, those should be handled by svg-panzoom.
        return;
    }
    const element = downEvent.target;
    if (downEvent.altKey && element.id !== "svgContainer" && !element.classList.contains("parentChild")) {
        //destroyTables(["descriptionTables", "selectionTable"]);
        destroyTables(["selectionTable"]);
        if (!element.classList.contains("selected")) {
            element.classList.add("selected");
        } else {
            element.classList.remove("selected");
            //Copied from rowPrototype.delete(). Refactor needed
            const table = document.getElementById(`table_${element.id}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
        }
        let ids = [];
        getSelected().forEach(e => { ids.push(e.id); });
        if (ids.length > 0) {
            const table = createSelectionTable(ids, gTreeWrapper);
            document.getElementById("selectionTable").appendChild(table);
        } 
        return;
    } 
    if (!downEvent.altKey) {
        getSelected().forEach(e => { e.classList.remove("selected"); });
        destroyTables(["descriptionTables", "selectionTable"]);
        if (element.id !== "svgContainer" && !element.classList.contains("parentChild")) {
            element.classList.add("selected");
            const table = createDescriptionTable(element.id, gTreeWrapper);
            document.getElementById("descriptionTables").appendChild(table);
        } 
    }
    return;
}

//function hotkeys() {
//	// Handle hotkey presses.
//	let x;
//	if (window.event) {
//		// IE8 and earlier
//		x = event.keyCode
//	} else if (event.which) {
//		// IE9/Firefox/Chrome/Opera/Safari
//		x = event.which
//	}
//	var keychar = String.fromCharCode(x);
//	if (event.target.type !== 'text') {
//		// Dispatch the key:
//		if (keychar == '-') {
//			window.panZoom.zoomOut()
//		} else if (keychar == '=') {
//			window.panZoom.zoomIn()
//		} else if (keychar =='m') {
//			moveNode()
//		}
//	}
//}


/**
 * TODO: add unit tests
 */
function destroyTables(ids) {
    ids.forEach(id => {
        const tableDiv = document.getElementById(id);
        Array.from(tableDiv.children).forEach(t => {
            tableDiv.removeChild(t);
        });
    });
}

function scaleTo(x) {
	// Scale the thickness of all lines and size of all circles. This helps user see details.
	scaleLevel = x
	if (!x) {
		return
	}
	const circles = document.getElementsByTagName('circle')
	const lines = document.getElementsByTagName('line')
	// Scale Circles
	for (let i = 0; i < circles.length; i++) {
		circles[i].setAttribute('r', 2*x)
		circles[i].setAttribute('stroke-width', 0.5*x)
	}
	// Scale Lines
	for (let i = 0; i < lines.length; i++) {
		if (lines[i].getAttribute('class').indexOf('p2') !== -1) {
			lines[i].setAttribute('stroke-width', 2*x)
		}
		else if (lines[i].getAttribute('class').indexOf('p3') !== -1) {
			lines[i].setAttribute('stroke-width', 3*x)
		}
		else if (lines[i].getAttribute('class').indexOf('parentChild') !== -1) {
			lines[i].setAttribute('stroke-width', 0.5*x)
		}
		else {
			lines[i].setAttribute('stroke-width', x)
		}
	}
}

function dropPill(thisButton, name) { // eslint-disable-line
	// This function is used to make the dropdown menus work.
	thisButton.style.color= 'black'
	thisButton.style.background= '#F8F8F8'
	thisButton.style.textAlign = 'left'
	thisButton.nextSibling.nextSibling.style.display = 'inline-block'
	thisButton.innerHTML = name + ' &#x25B4;'
	function clickCloseEvent() {
		thisButton.nextSibling.nextSibling.style.display = 'none'
		thisButton.innerHTML = name + ' &#x25BE;'
		this.removeEventListener('click', arguments.callee, true)
		thisButton.style.color= 'white'
		thisButton.style.background= 'transparent'
		if (window.event.toElement==thisButton) {event.stopPropagation()}
	}
	document.body.addEventListener('click', clickCloseEvent, true)
}

/*function clickCloseEvent(labelName, buttonName) { // eslint-disable-line
	// This event allows users to close the dropdown menus.
	var thisButton = document.getElementById(buttonName);
	//thisButton.nextSibling.nextSibling.style.display = 'none'
	thisButton.nextElementSibling.style.display = "none";
	thisButton.innerHTML = labelName + ' &#x25BE;';
	//this.removeEventListener('click', arguments.callee, true);
	//if (window.event.toElement==thisButton) {event.stopPropagation()}
}*/

function clickLatLon(event) {
	//Returns real Lat/Long of a click event, used in the moveBus function
	//const sizes = window.panZoom.getSizes();
    //const zoom = sizes.realZoom;
	const pan = window.panZoom.getPan();
    const zoom = panZoom.getSizes().realZoom;
	const svg = document.getElementById('svgContainer');
	let pt = svg.createSVGPoint();
	pt.x = event.clientX;
	pt.y = event.clientY;
	pt = pt.matrixTransform(svg.getScreenCTM().inverse());
	let x = pt.x;
	let y = pt.y;
	//x = (x - pan.x) / zoom;
	//y = (y - pan.y) / zoom;
	//return [x,y];
	// maybe this should be a class? We'll see...
	const coords = {
		x: (x - pan.x) / zoom,
		y: (y - pan.y) / zoom
	};
	return coords;
}

function clearGlobalSelectionArray() {
	//selection.forEach(element => {
	//	element.classList.remove("selected");
	//})
	//selection = [];
	Array.from(document.getElementsByClassName("selected")).forEach(element => element.classList.remove("selected"));
}

/**
 * TODO: add unit tests
 */
function getSelected() {
	return Array.from(document.getElementsByClassName("selected"));
}

//**************************************************
// Find modal interface
//**************************************************

/**
 * TODO: add unit tests
 */
function getSearchResults() {
    const tree = gTreeWrapper.tree;
    const keys = getMatchingKeys(this.value, tree);
    document.getElementById("searchCount").textContent = `hits: ${keys.length}`;
    const nextButton = document.getElementById("findNext");
    const previousButton = document.getElementById("findPrevious");
    tableDestroy();
    if (keys.length === 0 || this.value === "") {
        alert(`No results found for term: "${this.value}"`)
        const feedback = function() {
            alert("Please enter a new term to search for"); 
        }
        nextButton.onclick = feedback;
        previousButton.onclick = feedback;
        return;
    }
    const upperIndex = keys.length - 1;
    let idx = 0;
    tableCreate(tree[keys[idx]]);
    viewElement(keys[idx]);
    nextButton.onclick = function() {
        idx++;
        if (idx > upperIndex) {
            idx = 0;
        }
        tableCreate(tree[keys[idx]]);
        viewElement(keys[idx]);
    }
    previousButton.onclick = function() {
        idx--;
        if (idx < 0) {
            idx = upperIndex;
        }
        tableCreate(tree[keys[idx]]);
        viewElement(keys[idx]);
    }
}

/**
 * TODO: add unit tests
 */
function getMatchingKeys(term, tree) {
    const keys = [];
    for (let key in tree) {
        // Only add the key if it represents an object that was drawn
        if (((!isNullOrUndefined(tree[key].latitude) && !isNullOrUndefined(tree[key].longitude)) ||
         (!isNullOrUndefined(tree[key].to) && !isNullOrUndefined(tree[key].from)))) {
            for (let propertyKey in tree[key]) {
                let propertyVal = tree[key][propertyKey];
                if (typeof(propertyVal) !== "string") {
                    propertyVal += "";
                }
                if (propertyKey.toLowerCase().includes(term.toLowerCase())) {
                    keys.push(key);
                    break;
                } else if (propertyVal.toLowerCase().includes(term.toLowerCase())) {
                    keys.push(key);
                    break;
                }
            }
        }
    }
    return keys;
}

/** 
 * TODO: add unit tests
 * Clears the "selected" class from previous elements before making the viewed element "selected"
 */
function viewElement(key) {
    Array.from(document.getElementsByClassName("selected")).forEach(element => element.classList.remove("selected"));
    const element = document.getElementById(key);
	element.classList.add('selected');
    let x, y;
    if (!isNullOrUndefined(element.getAttribute("cx")) && !isNullOrUndefined(element.getAttribute("cy"))) {
        x = element.getAttribute("cx");
        y = element.getAttribute("cy");
    } else {
		x = (parseFloat(element.getAttribute('x1')) + parseFloat(element.getAttribute('x2'))) / 2;
		y = (parseFloat(element.getAttribute('y1')) + parseFloat(element.getAttribute('y2'))) / 2;
    }
    // I can't make this work 
    //panZoom.zoomAtPoint(2, {x: x, y: y});
    // Do this instead 
	panZoom.pan({x:0, y:0})
	var realZoom = window.panZoom.getSizes().realZoom
	var width = window.panZoom.getSizes().width / 2
	var height = window.panZoom.getSizes().height / 2
    panZoom.pan({x:width - (x * realZoom), y:height - (y * realZoom)})
    panZoom.zoom(15/scaleLevel);
}

/** 
 * TODO: remove this and everywhere that uses it
 */
function isNullOrUndefined(obj) {
    if (obj === undefined || obj === null) {
        return true;
    }
    return false;
}

//**************************************************
// jQuery handling for distNetViz.py
//**************************************************

/** 
 * TODO: add unit tests?
 * If this interface is being used as a file, we can't import jQuery with <script> so we can't use jQuery
 * styling. This function is only called when jQuery is available.
 */
 function applyJQueryStyles() {
    // Make stuff draggable
    $("#findModal .modalContent").draggable();
    $("#progressModal .modalContent").draggable();
    $("#loadModal .modalContent").draggable();
    $("#blankFeederModal .modalContent").draggable();
    $("#milsoftModal .modalContent").draggable();
    $("#gridlabdModal .modalContent").draggable();
    $("#cymeModal .modalContent").draggable();
    $("#scadaModal .modalContent").draggable();
    $("#amiModal .modalContent").draggable();
    $("#massAddModal .modalContent").draggable();
    $("#massEditModal .modalContent").draggable();
    $("#attachmentsModal .modalContent").draggable();
    //$("#descriptionTable").draggable();
    // Position the description table depending on whether or not it is draggable
    //document.getElementById("descriptionTable").removeAttribute("style");
    //document.getElementById("descriptionTable").style.left = "70vw";
}

/** 
 * Ajax requests depend on jQuery, so any function that uses $.ajax() cannot be used if this interface
 * is loaded as a file. This function is called when jQuery isn't available.
 */
function disableJQueryFunctionality() {
    //Hide stuff that doesn't work in distNetViz.py
    Array.from(document.querySelectorAll("[data-web]")).forEach(li => {
        li.remove();
    });
}

//**************************************************
// Header menu functions
//**************************************************

function attachHandlers() {
    //fillObjectMenu(globalComponents);
    addComponents();
    attachFeederList(document.getElementById("publicFeederList"), publicFeeders, "public");
    attachFeederList(document.getElementById("userFeederList"), userFeeders, thisOwner);
    addFileMenuHandlers();
    addEditMenuHandlers();
}

/** 
 * TODO: add unit-tests, delete this I think. Actually just modify it
 * Fill menu of "Add" button and add its handler functions.
 */
//function fillObjectMenu(globalComponents) {
function addComponents() {
	const ul = document.getElementById("componentList");
    const select = document.getElementById("componentSelect");
	for (let componentName in globalComponents) {
		const li = document.createElement("li");
		li.textContent = componentName;
		li.addEventListener("click", function() {
			addSvgObjects(addFeederObject(componentName, document.getElementsByClassName("selected")));
		});
		ul.appendChild(li);
        select.innerHTML += `<option value=${componentName}>${componentName}</option>`;
	}
}

/** 
 * TODO: add unit-tests
 * @param {Element} ul - An html element where the list will be attached
 * @param {Array} feeders - An array of objects, where each object has properties "model" and "name", or null. 
 * @param {string} owner - Either "public" or the owner of the current writeFeeder.
 */
function attachFeederList (ul, feeders, owner) {
    if (!feeders) return;
    for (let writeFeeder of feeders) {
        if (writeFeeder.name != thisFeederName) {
            const li = document.createElement("li");
            li.classList.add("feederItem");
            li.innerHTML = `<strong>${writeFeeder.name}</strong> from <br>"${writeFeeder.model}"`;
            li.addEventListener("click", function() {
                //overwriteFeeder(writeFeeder.name, writeFeeder.model, owner);
                loadFeeder(writeFeeder.name, writeFeeder.model, owner);
            });
            ul.append(li);
        }
    }
}

/**
 * TODO: add unit tests
 */
function addFileMenuHandlers() {
    const menu = document.getElementById("fileMenu");
    if (isNullOrUndefined(menu)) return;
    const items = Array.from(menu.children);
    if (items.length !== 8) {
        throw new Error("Please update this function to ensure the correct handlers are attached");
    }
    items[0].addEventListener("click", function() {
        saveFeeder(writeFeeder);
    });
    items[1].addEventListener("click", downloadTextFile);
    items[2].addEventListener("click", renameFeeder);
    items[3].addEventListener("click", function() { toggleElementDisplay("loadModal"); });
    items[4].addEventListener("click", function() { toggleElementDisplay("blankFeederModal"); });
    items[5].addEventListener("click", function() { toggleElementDisplay("milsoftModal"); });
    items[6].addEventListener("click", function() { toggleElementDisplay("gridlabdModal"); });
    items[7].addEventListener("click", function() { toggleElementDisplay("cymeModal"); });
}

/** 
 * TODO: add unit tests
 */
function addEditMenuHandlers() {
    const menu = document.getElementById("editMenu");
    const items = Array.from(menu.children);
    if (items.length != 9) {
        throw new Error("Please update this function to ensure the correct handlers are attached");
    }
    //items[0].addEventListener("click", zoomToFit);
    //items[1].addEventListener("click", zoomReset);
    items[0].addEventListener("click", staticLoadsToHouses);
    items[1].addEventListener("click", function() { toggleElementDisplay("scadaModal"); });
    items[2].addEventListener("click", function() { toggleElementDisplay("amiModal"); });
    items[3].addEventListener("click", function() { toggleElementDisplay("findModal"); });
    items[4].addEventListener("click", function() {
        updateAttachTargets("massAddTargetSelect", gTreeWrapper.tree);
        toggleElementDisplay("massAddModal");
    });
    items[5].addEventListener("click", function() {
        updateAttachTargets("massEditTargetSelect", gTreeWrapper.tree);
        toggleElementDisplay("massEditModal");
    });
    items[6].addEventListener("click", function() {
        loadAttachments(); 
        toggleElementDisplay("attachmentsModal");
    });
    items[7].addEventListener("click", function() { toggleElementDisplay("climateModal"); });
    items[8].addEventListener("click", function() { toggleElementDisplay("anonymizeModal"); });
}

/** 
 * TODO: add unit tests
 * If an element isn't displayed, set it's inline display value to the default browser value.
 * If the element is displayed, then hide it.
 */
function toggleElementDisplay(id) {
    const element = document.getElementById(id);
    if (element.style.display === "none") {
        element.removeAttribute("style");
    } else {
        element.style.display = "none";
        if (id === "findModal") {
            return;
        }
        // When we hide a modal, set any of the text fields to empty
        const queryString = `#${id} input[type=text]`;
        document.querySelectorAll(queryString).forEach(input => {
            input.value = "";
        });
    }
}

//**************************************************
// Edit menu interface
//**************************************************

/**
 * Set the viewport to its initial state and center it
 */
//function zoomReset() {
//    panZoom.fit();
//    panZoom.center();
//}

/**
 * Set the viewport value to its initial state.
 */
//function zoomToFit() {
//    panZoom.fit();
//}

function randomGaussian() {
  // Get a Gaussian from a uniform(0,1) via the Box-Muller transform.
  let rad;
  let x1;
  let x2;
  let c;
  do {
	x1 = 2 * Math.random() - 1
	x2 = 2 * Math.random() - 1
	rad = x1 * x1 + x2 * x2
  } while (rad >= 1 || rad == 0) {
    c = Math.sqrt(-2 * Math.log(rad) / rad);
  }
  return x1 * c
}

function randomInt(min,max) {
	return Math.floor(Math.random()*(max - min + 1) + min)
}

function randomInt(min,max) {
	return Math.floor(Math.random()*(max - min + 1) + min)
}

function randomChoice(inList) {
	return inList[Math.floor(Math.random() * inList.length)]
}


// TODO: for secondary system has 'load', replace it with triplex_meter and triplex_node
// TODO: rename this function?
function staticLoadsToHouses() {
    const tree = gTreeWrapper.tree;
    const names = gTreeWrapper.names;
	//if (!containsTriplexNodes(tree)) {
	if (!containsTriplexNodeOrLoad(tree)) {
        alert("There are no triplex nodes or triplex loads in this model.");
        return;
	} else {
        let modal = new ProgressModal("Please wait. Houses are being generated.", "", false);
        modal.show();
        // Replace 100 nodes at a time (maximum), to prevent the browser from hanging
        const keys = Object.keys(tree);
        let start = 0;
        let end = 100;
        const intervalId = setInterval(function() {
            //console.log("start: " + start);
            //console.log("end: " + end);
            replaceAllHouses(start, end, keys);
            if (end >= keys.length) {
                clearInterval(intervalId);
                modal.hide();
            } else {
                start = end + 1;
                end += 100;
            }
        }, 10);
    }

    /* Triplex loads should have a "parent" property. Triplex nodes should NOT have a "parent" property usually.
    Therefore, if the parent property DOES exist on either a node/load I should use it. However, it it DOESN'T exist,
    then I should carry on as normal too.
    */
    function containsTriplexNodeOrLoad(tree) {
        for (let key in tree) {
            if (tree[key].object === "triplex_node" || tree[key].object === "triplex_load") {
                return true;
            } 
        }   
        return false;
    }

	function replaceAllHouses(start, end, keys) {
        if (end >= keys.length) {
            end = keys.length - 1;
        }
        for (let i = start; i <= end; i++) {
            if (tree[keys[i]].object === "triplex_node" || tree[keys[i]].object === "triplex_load") {
                let parentKey = names[tree[keys[i]].parent];
                if (parentKey == null) {
                    //There is no parent. No big deal

                } else {
                    //There is a parent. Use the parent to place the new house

                }
            }
            /*
            TODO: delete this
            if (tree[keys[i]].hasOwnProperty('parent') && tree[keys[i]].object === "triplex_node") {
                // Get the key of the parent of this triplex node, which is a triplex meter (i.e. another node)
                let parentKey = names[tree[keys[i]].parent];
                // Delete the triplex_node itself
                deleteObject(keys[i]);
                // Create a new house object to replace the triplex node
                let houseObj = randomHouse();
                let lightsObj = randomLights();
                let heaterObj = randomWaterHeater();
                newChildAtLocation(houseObj.house, parentKey);
                newChildAtLocation(lightsObj.lights, houseObj.key);
                if (heaterObj != false) {
                    newChildAtLocation(heaterObj.heater, houseObj.key);
                }
            }
            */
        }
    }

	function randomHouse() {
		const newHouse = {}
		newHouse['object'] = 'house'
		newHouse['air_temperature'] = '70'
		newHouse['cooling_COP'] = randomInt(25, 40) / 10.0 + ''
		newHouse['cooling_setpoint'] = 'cooling' + randomInt(1, 8) + '*1'
		newHouse['cooling_system_type'] = randomChoice(['ELECTRIC', 'HEAT_PUMP', 'NONE'])
		// House sizing distribution from http://www.census.gov/housing/ahs/
		// between 1100 and 3000. Probably needs a normal distribution.
		let area = 1800 + 500 * randomGaussian()
		if (area < 500) {
			area = 500
		}
		area = area.toPrecision(2) * 1.0 + ''
		newHouse['floor_area'] = area
		newHouse['heating_COP'] = randomInt(20, 35) / 10.0 + ''
		newHouse['heating_setpoint'] = 'heating' + randomInt(1, 8) + '*1'
		newHouse['heating_system_type'] = randomChoice(['RESISTANCE', 'HEAT_PUMP', 'GAS'])
		newHouse['mass_temperature'] = '70'
		let skew = 1200 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHouse['schedule_skew'] = skew
		newHouse['thermal_integrity_level'] = randomChoice([1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6]) + ''
		const newKey = getNewTreeKey(gTreeWrapper.tree);
		newHouse['name'] = 'synhouse' + newKey
		return {
            house: newHouse,
            key: newKey
        }
	}

	function randomLights() {
		const newLights = {}
		newLights['object'] = 'ZIPload'
		newLights['power_fraction'] = '0.400000'
		newLights['current_fraction'] = '0.300000'
		newLights['impedance_pf'] = '1.000'
		newLights['current_pf'] = '1.000'
		newLights['power_pf'] = '1.000'
		newLights['impedance_fraction'] = '0.300000'
		newLights['heatgain_fraction'] = '0.9'
		let power = 1.2 + randomGaussian()
		if (power < 0) {
			power = -1 * power
		}
		power = power.toPrecision(3) * 1.0 + ''
		newLights['base_power'] = 'LIGHTS*' + 1.33
		let skew = 2000 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newLights['schedule_skew'] = skew
		const newKey = getNewTreeKey(gTreeWrapper.tree);
		newLights['name'] = 'synLights' + newKey
		return {
            lights: newLights,
            key: newKey
        }
	}

	function randomWaterHeater() {
		const newHeater = {}
		if (randomChoice([1, 2, 3]) == 3) {
			return false
		}
		// Static properties.
		newHeater['object'] = 'waterheater'
		newHeater['temperature'] = '135'
		newHeater['tank_volume'] = '50'
		newHeater['location'] = 'INSIDE'
		// Uniformly distributed properties.
		newHeater['heating_element_capacity'] = randomInt(37, 53) / 10.0 + ''
		newHeater['thermostat_deadband'] = randomInt(20, 60) / 10.0 + ''
		newHeater['demand'] = 'water' + randomInt(1, 20) + '*1'
		newHeater['tank_UA'] = randomInt(20, 40) / 10.0 + ''
		// Gaussian properties.
		let skew = 2000 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHeater['schedule_skew'] = skew
		newHeater['tank_setpoint'] = (randomGaussian() * 2 + 130).toPrecision(3) + ''
		// between 1100 and 3000. Probably needs a normal distribution.
		const newKey = getNewTreeKey(gTreeWrapper.tree);
		newHeater['name'] = 'synwaterheater' + newKey;
		return {
            heater: newHeater,
            key: newKey
        }
	}
}

/** 
 * TODO: add better validation for percent to ensure 1) it's a float and 2) it's in a valid range. Do this on the input if possible
 * General Function to Add Components 'inverter', 'triplex_meter', PERC
 * Did this function get chopped in half?
 */
function attachFeederList(ul, feeders, owner) {
    if (feeders === null || feeders === undefined) {
        return
    } 
    for (let writeFeeder of feeders) {
        if (writeFeeder.name !== thisFeederName) {
            const li = document.createElement("li");
            li.classList.add("feederItem");
            li.innerHTML = `<strong>${writeFeeder.name}</strong> from <br>"${writeFeeder.model}"`;
            li.addEventListener("click", function() {
                //overwriteFeeder(writeFeeder.name, writeFeeder.model, owner);
                loadFeeder(writeFeeder.name, writeFeeder.model, owner);
            });
            ul.append(li);
        }
    }
}

function massAdd() {
    let tree = gTreeWrapper.tree;
	const componentName = document.getElementById('componentSelect').value;
	const attachType = document.getElementById('massAddTargetSelect').value;
    const percent = document.getElementById('percent').value;
    if (isNaN(percent) || percent === "") {
        alert("Please enter a valid number for attachment probability");
        return
    }
	let objectsAdded = 0;
    let modal = new ProgressModal(`Please wait. We are adding ${componentName} objects to all ${attachType} objects.`, "", false);
    modal.show();
    // Add 100 nodes at a time (maximum), to prevent the browser from hanging
    const keys = Object.keys(tree);
    let start = 0;
    let end = 100;
    const intervalId = setInterval(function() {
        console.log("start: " + start);
        console.log("end: " + end);
        massAddComponent(start, end, keys);
        if (end >= keys.length) {
            clearInterval(intervalId);
            modal.hide();
            alert(`${objectsAdded} ${componentName} objects added to the feeder`);
        } else {
            start = end + 1;
            end += 100;
        }
    }, 100);

    function massAddComponent(start, end, keys) {
        if (end >= keys.length) {
            end = keys.length - 1;
        }
        for (let i = start; i <= end; i++) {
            if (tree[keys[i]].object === attachType) {
				if (Math.random() < percent) {
					const newComponent = deepCopy(globalComponents[componentName]);
					newChildAtLocation(newComponent, keys[i]);
					objectsAdded += 1
				}
            }
        }
    }
}

function updateAttachTargets(id, tree) {
	/* Clearing each list so we dont get duplicates in the list. This must be done because the attachTarget list must be 
    refreshed, since the user could have added a new object type to the data which they now want to attach to.
    */
    document.getElementById(id).innerHTML = "";
	let attachList = [];
	for (let key in tree) {
        /* Only list an object type as a valid attachTarget if 1) its object property matches a known component and 2)
        the object type already exists in the graph. "1" is to prevent things like weird configuration nodes from 
        being presented to the user, since the user could not attach anything to those weird objects. "2" is to ensure
        that the user must attach to things that already exist in a particular model.
        */
        if (globalComponents.hasOwnProperty(tree[key].object)) {
			if (!attachList.includes(tree[key].object)) {
                attachList.push(tree[key].object);
                document.getElementById(id).innerHTML += `<option value=${tree[key].object}>${tree[key].object}</option>`;
            }
        }
    }
}

function massEdit() {
    const tree = gTreeWrapper.tree;
    const objectType = document.getElementById("massEditTargetSelect").value;
    const keys = [];
    for (let key in tree){
		if (tree[key].object === objectType) {
            keys.push(key);
        }
    }
    let operation = document.querySelector("input[name=attributeOperation]:checked");
    if (isNullOrUndefined(operation)) {
        alert("Please select an operation with radio buttons on the 'Mass Edit' menu.");
        return;
    }
    operation = operation.value;
    if (operation === "addAttribute") {
        massEditAdd(keys);
        return;
    }
    const attributeKey = document.getElementById("massEditAttribute").value;
    for (let key of keys) {
        if (tree[key][attributeKey] === undefined) {
            alert(`Invalid operation. One or more of the objects you selected does not have the attribute you are trying to edit.
            Attribute "${attributeKey}" is missing from tree object with key "${key}".`);
            return;
        }
    }
    switch (operation) {
        case "addTo":
            const operand = parseFloat(document.getElementById("addToValue").value);
            if (isNaN(operand)) {
                alert("Invalid operation. Please enter a valid number if you choose 'Add to Value'.");
                return;
            } else {
                for (let key of keys) {
                    const value = parseFloat(tree[key][attributeKey]);
                    if (isNaN(value)) {
                        alert("Invalid operation. The attribute you are trying to add to is not a number.");
                        return;
                    }
                    tree[key][attributeKey] = (value + operand).toString();
                }
            }
            break;
        case "change":
            const newValue = document.getElementById("changeValue").value;
            for (let key of keys) {
                tree[key][attributeKey] = newValue;
            }
            break;
        case "delete":
            for (let key of keys) {
                delete tree[key][attributeKey];
            }
            break;
        case "multiplyBy":
            const multiplyOperand = parseFloat(document.getElementById("multiplyValue").value);
            const rawAddOperand = document.getElementById("andAddValue").value;
            let addOperand;
            if (rawAddOperand === "") {
                addOperand = 0;
            } else {
                addOperand = parseFloat(rawAddOperand);
            }
            if (isNaN(multiplyOperand) || isNaN(addOperand)) {
                alert("Invalid operation. Please enter valid numbers if you choose 'Multiply attribute by'.");
            }
            for (let key of keys) {
                const value = parseFloat(tree[key][attributeKey]);
                if (isNaN(value)) {
                    alert("Invalid operation. The attribute you are trying to multiply by is not a number.");
                    return;
                }
                tree[key][attributeKey] = ((value * multiplyOperand) + addOperand).toString();
            }
            break;
    }
    alert(`${keys.length} ${objectType} objects edited.`);
}

function massEditAdd(keys) {
    const tree = gTreeWrapper.tree;
    const newKey = document.getElementById("newAttributeKey").value;
    const newValue = document.getElementById("newAttributeValue").value;
    for (let key of keys) {
        tree[key][newKey] = newValue;
    }
    const objectType = document.getElementById("massEditTargetSelect").value;
    alert(`${keys.length} ${objectType} objects edited.`);
}

function loadAttachments() {
    const selectElement = document.getElementById("attachmentSelect");
    selectElement.innerHTML = "";
	for (let key in writeFeeder.attachments) {
        selectElement.innerHTML += `<option value=${key}>${key}</option>`;
    }
}

function editAttachment() {
	//document.body.style.cursor = 'wait'
	//setTimeout(function(){
		toggleElementDisplay('editAttachmentModal');
		let name =  document.getElementById('attachmentSelect').value; //get the select. attachmentsList = attachmentSelect
		document.getElementById('attachmentTd').innerHTML = name;  //get the td. attachmentSelect = attachmentTd
		document.getElementById('editAttachmentBox').innerHTML = writeFeeder.attachments[name];
		//document.body.style.cursor = 'auto'
	//}, 100);
}

function saveAttachment() {
	let name = document.getElementById('attachmentSelect').value;
	writeFeeder.attachments[name] = document.getElementById('editAttachmentBox').value;
}

//ADD PROMPT TO SAVE CHANGES BEFORE EXIT
{% if is_admin or not public %}
	window.onbeforeunload = function(e) {
		let confirmationMessage = 'It looks like you have been editing something. ';
		confirmationMessage += 'If you leave before saving, your changes will be lost.';
		//if (unsavedChanges) return confirmationMessage;
	};
{% endif %}

//**************************************************
// File menu interface
//**************************************************
{% if showFileMenu %}

/** 
 * Used to save the new changes or undo an operation by resaving the old changes.
 */ 
function saveFeeder(feeder) {
    const formData = new FormData();
    formData.set("feederObjectJson", JSON.stringify(feeder));
    const postRequest = $.ajax({
        type: "POST",
        url: `/saveFeeder/${thisOwner}/${thisModelName}/${thisFeederName}`,
        data: formData,
        processData: false,
        contentType: false,
    });
    let cancelled = false;
    let progressModal;
    if (feeder === readFeeder) {
        progressModal = new ProgressModal("Cancelling the previous operation...", "", false);
        postRequest.done(function() {
            progressModal.hide();
            alert("Success. Previous operation was canceled");
        });
    } else if (feeder === writeFeeder) {
        progressModal = new ProgressModal("Saving changes to your file...", "You have canceled the save.", true);
        progressModal.button.addEventListener("click", function() {
            cancelled = true;
            progressModal.header.textContent = progressModal.cancelMessage;
            progressModal.button.style.display = "none";
        });
        postRequest.done(function() {
            if (cancelled) {
                saveFeeder(readFeeder);
            } else {
                progressModal.hide();
                alert("Success. Your data was saved.");
            }
        });
    }
    progressModal.show();
}

async function loadFeeder(serverFeederName, serverModelName, owner) {
    let submitForm = false;
    await $.ajax({
        url: `/uniqObjName/Feeder/${thisOwner}/${serverFeederName}/${serverModelName}`
    }).done(function(data) {
        if (data.exists) {
            submitForm = true;
        } else {
            alert('This feeder no longer exists. Please refresh the page, or select another feeder.');
        }
    });
    if (submitForm === false) {
        return;
    }
    let formData = new FormData();
    formData.set("referrer", "distribution");
    const progressModal = new ProgressModal("Loading feeder from server...", "You have canceled loading the feeder.", true);
    let cancelled = false;
    progressModal.button.addEventListener("click", function() {
        cancelled = true;
        progressModal.header.textContent = progressModal.cancelMessage;
        progressModal.button.style.display = "none";
    });
    progressModal.show();
    $.ajax({
        type: "POST",
        url: `/loadFeeder/${serverFeederName}/${serverModelName}/${thisModelName}/${thisFeederNum}/${owner}/${thisOwner}`,
        data: formData,
        processData: false,
        contentType: false,
    }).done(function() {
        if (cancelled) {
            saveFeeder(readFeeder);
        } else {
            reloadWrapper();
        }
    });
}

/** 
 * TODO: add back ability to cancel these operations
 */
async function submitForm({formId, pollUrl, inputId}) {
    let submitForm = true;
    if (inputId !== undefined) {
        // inputId was defined, therefore we need to check the file name on the server before submitting the form
        submitForm = false;
        const fileName = document.getElementById(inputId).value;
        // Check if the file exists, using the user-provided fileName
        await $.ajax({
            url: `/uniqObjName/Feeder/${thisOwner}/${fileName}/${thisModelName}`
        }).done(function(data) {
            console.log(data);
            if (data.exists === true) {
                alert(`You already have a feeder named "${fileName}". Please choose a different name.`);
            } else {
                // The file does not exist. Submit the form.
                submitForm = true;
            }
        });
    }
    if (submitForm === false) {
        return;
    }
    const form = document.getElementById(formId);
    const formData = new FormData(form);
    const submitModal = new ProgressModal("Submitting your file...", "", false);
    submitModal.show();
    // Submit the form to the server with an ajax request
    const formRequest = $.ajax({
        type: "POST",
        url: form.action,
        data: formData,
        processData: false,
        contentType: false,
    });
    if (pollUrl === undefined) {
        // We don't want to poll the server. Just reload the page.
        formRequest.done(function() {
            reloadWrapper();
        });
    } else {
        formRequest.done(function(data) {
            let cancelled = false;
            const pollModal = new ProgressModal("Converting your file...", "You canceled the file conversion.", true);
            pollModal.button.addEventListener("click", function() {
                cancelled = true;
                pollModal.header.textContent = pollModal.cancelMessage;
                pollModal.button.style.display = "none";
            });
            pollModal.show();
            // Poll the server
            const intervalId = setInterval(function() {
                $.ajax({
                    //url: `/checkConversion/${thisModelName}/${thisOwner}`
                    url: pollUrl
                }).done(function(data) {
                    if (cancelled) {
                        clearInterval(intervalId);
                        pollModal.hide();
                        alert("You cancelled the operation");
                        saveFeeder(readFeeder);
                    }
                    if (data.exists === true) {
                        //processing is ongoing 
                    } else if (data.exists === false) {
                        // The pollModal isn't hidden before the alert happens. This has nothing to do with the reload wrapper.
                        clearInterval(intervalId);
                        pollModal.hide();
                        alert("Conversion complete");
                        reloadWrapper();
                    } else if (data === "milError") {
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('The .std and .seq files used are incorrectly formatted.');
                        //TODO: submit the readFeeder
                    } else if (data === "glmError") {
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('The .glm file used is incorrectly formatted.');
                        //TODO: submit the readFeeder
                    } else {
                        console.log(data);
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('There was a problem. Operation was cancelled');
                    }
                });
            }, 5000);
        });
    }
}

async function renameFeeder() {
	if (JSON.stringify(readFeeder) !== JSON.stringify(writeFeeder)){
		alert('You have unsaved changes. Please save the feeder before proceeding.')
	} else {
		let newName = prompt("Rename the feeder to", `${thisFeederName}`);
		while (! /^[\w\s]+$/.test(newName) || /^\s+$/.test(newName)) {
			newName = prompt("Only letters, digits and underscore are allowed.\nPlease enter a different name", `${thisFeederName}`);
		}
		if (newName){
            let submitRequest = false;
            await $.ajax({
                url: `/uniqObjName/Feeder/${thisOwner}/${newName}/${thisModelName}`
            }).done(function(data) {
                if (data.exists) {
                    alert(`You already have a feeder named "${newName}". Please choose a different name.`);
                } else {
                    submitRequest = true;
                }
            });
            if (submitRequest === false) {
                return;
            }
            $.ajax({
                url: `/renameFeeder/${thisOwner}/${thisModelName}/${thisFeederName}/${newName}/${thisFeederNum}`
            }).done(function() {
                thisFeederName = newName;
                alert("Feeder file was successfully renamed.");
            })
		}
	} 
}
{% endif %}

/** This is done for testing reasons.
 */
function reloadWrapper() {
    /* Force the client to always request new files from the server without using the browser cache. 
    */
    window.location.reload(true);
}

function ProgressModal(message, cancelMessage, showButton) {
    this.self = document.getElementById("progressModal");
    this.button = this.self.getElementsByTagName("button")[0];
    this.header = this.self.getElementsByTagName("h2")[0];
    this.message = message;
    this.cancelMessage = cancelMessage;
    this.showButton = showButton;
}

ProgressModal.prototype.show = function() {
    this.header.textContent = this.message;
    this.self.removeAttribute("style");
    if (this.showButton) {
        this.button.removeAttribute("style");
    } else {
        this.button.style.display = "none";
    }
}

ProgressModal.prototype.hide = function() {
    this.self.style.display = "none";
}

//**************************************************
// TreeWrapper interface
//**************************************************

const treeWrapperPrototype = {

    /* "Public" interface methods */

    /** 
     * Return a TreeWrapper that represents which tree objects need to be redrawn as a result of inserting 
     * this TreeObject.
     * 
     * If the TreeObject.key does not exist in this TreeWrapper, the new TreeObject.key and new TreeObject.data are added to the
     * TreeWrapper. If the TreeObject.key does exist in this TreeWrapper, the data at the existing key is overwritten.
     * This is a public interface method, which means it should be used in event handlers and other places to do stuff.
     * While this method will work for ANY TreeWrapper, it is intended to be used with the "gTreeWrapper" only.
     * The gTreeWrapper encapsulates all the data of the model, which is what we want to work with.
     * @param {TreeObject} treeObject - contains a key and some data that will be used to add or overwite
     * data inside of this TreeWrapper.
     * @return {TreeWrapper} tWrapper - contains all of the tree objects that need to be redrawn as a result of 
     * modifying the data.
     */
     insert(treeObject) {
        this.tree[treeObject.key] = treeObject.data;
        this.names[treeObject.data.name] = treeObject.key;
        const tWrapper = createTreeWrapper();
        tWrapper.add(treeObject.key, this);
        tWrapper.merge(this.getSubtreeToRedraw(treeObject.key));
        return tWrapper;
    },

    /** 
     * Delete the tree object with the passed key argument from this TreeWrapper.
     * @param {string} key - the key used to identify the tree object to delete.
     * @return {TreeWrapper} tWrapper - contains 1 tree object that was affected by the delete operation.
     */
    delete(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            console.log(`Unable to perform delete operation. This TreeWrapper does not contain a tree object with key: "${key}".`);
            return tWrapper;
        }
        const childKeys = Object.keys(this.getChildrenOf(key).tree);
        if (childKeys.length > 0) {
            throw new Error(`Cannot delete object with key "${key}" because it has existing children. Please delete the children first.`);
            //console.log(`Cannot delete tree object with key "${key}" from the tree because it has existing children`);
            return tWrapper;
        }
        const lineKeys = Object.keys(this.getConnectedLinesOf(key).tree);
        if (lineKeys.length > 0) {
            throw new Error(`Cannot delete object with key "${key}" because it has connected lines. Please delete the connected lines first.`);
            //console.log(`Cannot delete tree object with key "${key}" from the tree because it has connected lines`);
            return tWrapper;
        }
        tWrapper.add(key, this);
        delete this.names[this.tree[key].name];
        delete this.tree[key];
        return tWrapper;
    },

    /** 
     * Delete the tree object with the passed key argument from this TreeWrapper. Also recursively delete any connected
     * lines and children. 
     * @param {string} key - the key of the tree object which should be deleted, along with any associated tree objects.
     * @return {TreeWrapper} - contains all of the tree objects that need to be removed from the svg
     * as a result of the recursive delete operation.
     */
    recursiveDelete(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to perform a recursive delete operation. The tree object with key "${key}" does not exist
            //in this TreeWrapper`);
            return tWrapper;
        }
        tWrapper.add(key, this);
        tWrapper.merge(this.getSubtreeToDelete(key, []));
        for (let key in tWrapper.tree) {
            delete this.names[this.tree[key].name];
            delete this.tree[key];
        }
        return tWrapper;
    },

    /* "Private" helper methods */

    /** 
     * Add an object from the tWrapper argument into this TreeWrapper.
     * @param {string} key - the key of the object to search for in the tWrapper argument.
     * @param {TreeWrapper} tWrapper - the TreeWrapper from which we want to get data to insert into this TreeWrapper.
     */
    add(key, tWrapper) {
        if (!tWrapper.contains(key)) {
            console.log(`Unable to add the key to this TreeWrapper. The tree object with the key: "${key}" does
            not exist in the tWrapper argument.`)
            return;
        }
        this.tree[key] = tWrapper.tree[key];
        const name = this.tree[key].name;
        if (name == null) {
            return;
        }
        this.names[name] = key;
    },

    /** 
     * Return a TreeWrapper that contains direct children of the tree object with the passed key argument.
     * @param {string} parentKey - the key of the tree object that is presumably a parent to some other tree objects.
     * @return {TreeWrapper} childrenTreeWrapper - contains only children tree objects of the parentKey tree object.
     */
    getChildrenOf(parentKey) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(parentKey)) {
            //console.log(`Unable to get the children of the tree object with key: "${parentKey}". The key does not exist in this
            //TreeWrapper.`);
            return tWrapper;
        }
        if (!isParentChildNode(this.tree[parentKey]) && !isParentlessNode(this.tree[parentKey])) {
            return tWrapper;
        }
        let parentName = this.tree[parentKey].name;
        if (parentName == null) {
            /* Children reference their parent with the parent's name. If a node doesn't have a name, then it must not
            have children.
            */
            //console.log(`Unable to get the children of the tree object with key: "${parentKey}". The tree object
            //does not have a name.`);
            return tWrapper;
        } 
        // TODO: Build an object in TreeWrapper that allows instant lookup of children for any TreeWrapper.tree object
        Object.keys(this.tree).forEach(key => {
            parentName = this.tree[key].parent;
            if (parentName != null && parentName === this.tree[parentKey].name) {
                tWrapper.add(key, this);
            }
        });
        return tWrapper;
    },

    /** Return a TreeWrapper that contains lines connected to the tree object with the passed key argument.
     *
     * @param {string} nodeKey - the key of the tree object that presumably has lines connected to it.
     * @return {TreeWrapper} subWrapper - contains only line tree objects that connect to the nodeKey tree object.
     */
    getConnectedLinesOf(nodeKey) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(nodeKey)) {
            //console.log(`Unable to find lines that connect to this node with key: "${nodeKey}". The key does not exist in this
            //TreeWrapper.`);
            return tWrapper;
        } else if (!isParentChildNode(this.tree[nodeKey]) && !isParentlessNode(this.tree[nodeKey])) {
            // This tree object is not a node, therefore no lines can connect to it
            return tWrapper;
        }

        const linesTreeWrapper = createTreeWrapper();
        // TODO: Build an object in TreeWrapper that allows instant lookup of connected lines for any TreeWrapper.tree object
        Object.keys(this.tree).forEach(key => {
            if (this.tree[key].to === this.tree[nodeKey].name || this.tree[key].from === this.tree[nodeKey].name) {
                linesTreeWrapper.add(key, this);
            }
        });
        return linesTreeWrapper;
    },

    /** Merge the treeWrapper argument into this TreeWrapper.
     * 
     * If no keys argument is passed, the entire treeWrapper argument is merged into this TreeWrapper.
     * If a keys argument is passed, only those tree objects with matching keys inside of the treeWrapper argument are merged
     * into this TreeWrapper.
     * @param {TreeWrapper} treeWrapper - contains tree objects that will be merged into this TreeWrapper
     * @param {Array} keys - an optional argument that limits which tree objects are merged into this TreeWrapper
     */
    merge(treeWrapper, keys) {
        if (keys === undefined) {
            Object.keys(treeWrapper.tree).forEach(key => {
                this.add(key, treeWrapper);
            });
        } else if (Array.isArray(keys)) {
            keys.forEach(key => {
                this.add(key, treeWrapper);
            });
        } else {
            throw new Error("If the keys argument is passed, it must be an array");
        }
    },

    /** Return a TreeWrapper that contains all tree objects that will be deleted as a result of deleting the
     * tree object with the passed key argument.
     * 
     * @param {string} key - the key of the tree object for which to find its deletable subtree.
     * @param {Array} visited - contains keys of tree objects that have already been visited so the method dosen't
     * recurse infinitely in case of a cycle.
     * @return {TreeWrapper}
     */
    getSubtreeToDelete(key, visited) {
        if (!Array.isArray(visited)) {
            throw new Error("Visited argument must be an array");
        }
        visited.push(key);
        const tWrapper = createTreeWrapper();
        const children = this.getChildrenOf(key);
        tWrapper.merge(children);
        tWrapper.merge(this.getConnectedLinesOf(key));
        if (Object.keys(children.tree).length > 0) {
            for (let childKey in children.tree) {
                if (!visited.includes(childKey)) {
                    tWrapper.merge(this.getSubtreeToDelete(childKey, visited));
                }
            }
        }
        return tWrapper;
    },

    /**
     * Return a TreeWrapper that contains only the parent tree object of the child tree object.
     * 
     * @param {string} childKey - the key of the child tree object.
     * @return {TreeWrapper} subWrapper - contains only the parent tree object of the child tree object.
     */
    getParentOf(childKey) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(childKey)) {
            //console.log(`Unable to get the parent of the tree object with key: "${childKey}". The key does not exist in this
            //TreeWrapper.`);
            return tWrapper;
        }  
        const parentName = this.tree[childKey].parent;
        if (parentName == null) {
            // This tree object doesn't have a parent, which is fine.
            return tWrapper
        }
        const parentKey = this.names[parentName];
        if (parentKey == null) {
            /* If parentKey is undefind, then either 1) the child node has a parent that doesn't exist in this graph or 
            2) the names object of a TreeWrapper was built incorrectly */
            //console.log(`Unable to get the parent of the child tree object with key: "${childKey}". The parent does not 
            //exist in this TreeWrapper.`); //or the 'names' property is being built wrong.
            return tWrapper;
        }
        tWrapper.add(parentKey, this);
        return tWrapper;
    },

    /** Return a TreeWrapper that contains only tree objects that are on the other ends of lines that connect
     * to the tree object with the passed key argument.
     * 
     * @param {string} key - the tree object for which to search for its paired nodes. Nodes have a paired relationship
     * if they are connected by a line.
     * @return {TreeWrapper} - contains only tree objects that are paired nodes of the tree object for which
     * we searched.
     */
    getPairedNodesOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to get the paired nodes of the tree object with the key: "${key}". The key does not exist
            //in this TreeWrapper`);
            return tWrapper;
        }
        const linesTreeWrapper = this.getConnectedLinesOf(key);
        for (let lineKey in linesTreeWrapper.tree) {
            const fromKey = this.names[this.tree[lineKey].from];
            const toKey = this.names[this.tree[lineKey].to];
            if (key === fromKey) {
                // The 'from' node points to this tree object, so we want the other tree object
                tWrapper.add(toKey, this);
            } else if (key === toKey) {
                // The 'to' node points to this tree object, so we want the other tree object
                tWrapper.add(fromKey, this);
            } else {
                throw new Error(`There was a problem finding a "from" or "to" node for line with key: "${lineKey}"`);
            }
        }
        return tWrapper;
    },

    /** 
     * Return a TreeWrapper that contains nodes on either end of the line that is represented by the
     * tree object with the passed key argument.
     * @param {string} key - the key of the tree object that is a line. 
     * @return {TreeWrapper} subWrapper - contains only 2 tree objects that are on either end of the line,
     * or 0 tree objects if the tree object isn't a line!
     */
    getNodeEndsOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key) || !isLine(this.tree[key])) {
            //TODO add console message and maybe split these up
            return tWrapper;
        }
        const fromKey = this.names[this.tree[key].from];
        const toKey = this.names[this.tree[key].to];
        const subWrapper = createTreeWrapper();
        if (fromKey == null) {
            if (toKey == null) {
                console.log(`Tree object with key: "${key}" has nonexistent "from" and "to" nodes.`);
                return subWrapper;
            } else {
                console.log(`Tree object line with key: "${key}" has nonexistent "from" node.`);
                subWrapper.add(toKey, this);
                return subWrapper;
            }
        } else if (toKey == null) {
            console.log(`Tree object line with key: "${key}" has nonexistent "to" node.`);
            subWrapper.add(fromKey, this);
            return subWrapper;
        }
        subWrapper.add(fromKey, this);
        subWrapper.add(toKey, this);
        return subWrapper;
    },

    /**
     * 
     */
    getSubtreeToRedraw(key) {
        const tWrapper = createTreeWrapper();
        tWrapper.merge(this.getParentOf(key));
        tWrapper.merge(this.getChildrenOf(key));
        tWrapper.merge(this.getConnectedLinesOf(key));
        tWrapper.merge(this.getPairedNodesOf(key));
        tWrapper.merge(this.getNodeEndsOf(key));
        return tWrapper;
    },

    /** 
     * Return true if the tree of this TreeWrapper has the 'key' argument, otherwise return false;
     */
    contains(key) {
        if (this.tree[key] == null) {
            // Methods that use this method have more specific error messages that make this one redundant
            //console.log(`Unable to perform any operations with the 'key' argument.
            //No tree object with key: "${key}" exists in this TreeWrapper.`);
            return false;
        }
        const name = this.tree[key].name;
        if (name == null) {
            //console.log(`The tree object with the key: "${key}" does not have a 'name' property, therefore it isn't
            //contained in the 'names' property of this TreeWrapper.`);
        } else if (this.names[this.tree[key].name] == null) {
            console.log(`The 'names' property of this TreeWrapper is missing an entry for tree object with key: "${key}",
            name: "${this.tree[key].name}".`); 
        }
        return true;
    },

    ///** TODO: add unit tests
    // * 
    // */
    //getKeyWithName(name) {
    //    const key = this.names[name];
    //    if (key == null) {
    //        console.log(`The name "${name}" does not exist in this TreeWrapper.names`);
    //        return null;
    //    }
    //    return key;
    //},

    /** 
     * It would be nice if createTreeWrapper() could accept another treeWrapper. That way instead of rebuilding a new
     * names object for each treeWrapper I could (maybe) reuse the pre-existing names object in the TreeWrapper argument?
     * It's a micro-optimization I think.
     */
    buildNames() {
        const nameKeyMap = {};
        Object.keys(this.tree).forEach(key => {
            const name = this.tree[key].name;
            if (name != null) {
                keyIsStringAndValidNumber(key);
                nameKeyMap[name] = key;
            }
        });
        return nameKeyMap;
    }
};

/** 
 * Return an object that has an 'tree' object and a 'names' map.
 * 
 * The 'tree' object is a reference to the tree that exists in writeFeeder, which is the original source of all data.
 * The 'names' object maps the name of a tree object to the key of the tree object in the tree. This allows faster
 * retrieval of to/from/parent nodes when building the svg data. Without this map, we would have to parse the tree to find
 * every to/from/parent node. This would be slow.
 * @param {Object} tree - contains all of the objects that will be used to generate the svg.
 * @return {TreeWrapper} treeWrapper - a wrapper around the tree argument. This wrapper also has the name-key map to speed up 
 * to/from/parent node retrieval.
 */
function createTreeWrapper(tree = {}) {
    if (typeof(tree) !== "object" || Array.isArray(tree)) {
        throw new Error("tree argument must be a JavaScript object");
    }
    const treeWrapper = Object.create(treeWrapperPrototype);
    treeWrapper.tree = tree;
    treeWrapper.names = treeWrapper.buildNames();
    return treeWrapper;
}

//**************************************************
// TreeWrapper-to-SVG interface
//**************************************************

const deletableSvgDataPrototype = {

    /* Public interface methods */

    /**
     * Use the ids inside of the deletableSvgData instance to remove elements from the document viewport.
     */
    deleteFrom(viewport) {
        this.ids.forEach(id => {
            let e = document.getElementById(id);
            if (e != null) {
                viewport.removeChild(document.getElementById(id));
            }
            // could log a console message if it would be helpful
        });
    }
}

/** 
 * TODO: should take a treeWrapper, add unit tests
 * 
 * @param {Object} tree - A tree of all tree objects that 1) were already deleted from the tree and 2) should also
 * be deleted from the svg.
 * @return {Object} DeletableSvgData - Has a method for deleting from a viewport.
 */
function createDeletableSvgData(tree) {
    const obj = Object.create(deletableSvgDataPrototype);
    obj.ids = []
    Object.keys(tree).forEach(key => {
        if (isParentChildNode(tree[key])) {
            obj.ids.push(key);
            const parentChildLineId = `${tree[key].parent}_${tree[key].name}`
            obj.ids.push(parentChildLineId);
        } else {
            obj.ids.push(key);
        }
        /*
        else if (isParentlessNode(tree[key])) {
            obj.ids.push(key);
        } else if (isLine(tree[key])) {
            obj.ids.push(key)
        } else if (isConfigurationNode(tree[key])) {

        } else { 
            //console.log(`Failed to delete type: "${tree[key].object}", name: "${tree[key].name}", key: ${key}"`);
            //throw new Error(`tree key: ${key}, with data: ${tree[key]} is not a parent-child node, a parentless node, or a line.`); 
        }
        */
    });
    return obj;
}

/** 
 * TODO: add unit tests
 * 
 */
const addableSvgDataPrototype = {

    /* "Public" interface methods */

    /** 
     * TODO: add unit tests
     * Add the svgData to the viewport when the feeder is initially built. The lines must be drawn before
     * circles to be underneath the circles. 
     */
    addTo(viewport) {
        this.lines.forEach(line => {
            viewport.appendChild(line);
        });
        this.circles.forEach(circle => {
            viewport.appendChild(circle);
        });
    },

    /**
     *  TODO: add unit tests
     */
    redrawTo(viewport) {
        this.lines.forEach(line => {
            //viewport.removeChild(document.getElementById(line.id).parentNode.childNodes);
            document.getElementById(line.id).remove();
        });
        this.circles.forEach(circle => {
            //viewport.removeChild(document.getElementById(circle.id).parent);
            document.getElementById(circle.id).remove();
        });
        this.lines.forEach(line => {
            viewport.appendChild(line);
        });
        this.circles.forEach(circle => {
            viewport.appendChild(circle);
        });
        scaleTo(scaleLevel);
    },

    /* "Private" helper methods */

    /** 
     * TOOD: add unit tests
     */
    addLine(key) {
        const nodes = Object.values(this.treeWrapper.getNodeEndsOf(key).tree);
        if (nodes.length < 2) {
            console.log(`Could not find the nodes on either end of a line with key: "${key}". Line was not drawn`);
            /* TODO: Draw the line anyway with some kind of default values so the user can see there's a broken line?
            I could have a second viewport that is contained in a table with all the broken lines and circles! Neat!
            */
            return;
        }
        const tree = this.treeWrapper.tree;
        let line;
        if (tree[key].from === nodes[0].name) {
            line = createSvgLine(nodes[0], nodes[1], key, tree[key]);
        } else {
            line = createSvgLine(nodes[1], nodes[0], key, tree[key]);
        }
        this.lines.push(line);
    },

    /** 
     * TODO: add unit tests
     */
    addParentChildLine(key) {
        const parent = Object.values(this.treeWrapper.getParentOf(key).tree)[0];
        if (parent == null) {
            console.log(`Could not draw the parent-child line for child tree object with key: "${key}"`);
            return;
        }
        const parentChildLine = createSvgLine(parent, this.treeWrapper.tree[key]);
        this.lines.push(parentChildLine);
    },

    /**
     * TODO: add unit tests
     */
    addConfigurationNode(key) {
        const node = this.treeWrapper.tree[key];
        node.longitude = 0;
        node.latitude = 0;
        const circle = createSvgCircle(key, node);
        this.circles.push(circle);
    },

    /**
     * TODO: add unit tests
     */
    addParentChildNode(key, obj) {
        /* There are some weird config nodes that have "parent" but no "longitude" and "latitude" properties and the
        interface breaks if I don't do this.
        */
        if (obj.longitude == null || obj.latitude == null) {
            this.addConfigurationNode(key);
        } else {
            const circle = createSvgCircle(key, obj);
            this.circles.push(circle);
        }
        this.addParentChildLine(key);
    }
};

/** 
 * Return an AddableSvgData instance.
 * 
 * An AddableSvgData instance contains an array of circles and an array of lines that can be redrawn or added
 * to the svg. It also has methods for adding to the svg and redrawing to it.
 * 
 * @param {TreeWrapper} treeWrapper - contains all tree objects that should be added to the svg.
 * @return {AddableSvgData} - the svg data to add.
 */
function createAddableSvgData(treeWrapper) {
    if (Object.getPrototypeOf(treeWrapper) !== treeWrapperPrototype) {
        throw new Error("treeWrapper argument must be an instance of TreeWrapper");
    }
    const obj = Object.create(addableSvgDataPrototype);
    obj.treeWrapper = treeWrapper;
    obj.lines = [];
    obj.circles = [];
    const tree = treeWrapper.tree;
    Object.keys(tree).forEach(key => {
        if (isParentChildNode(tree[key])) {
            obj.addParentChildNode(key, tree[key]);
        } else if (isParentlessNode(tree[key])) {
            const circle = createSvgCircle(key, tree[key]);
            obj.circles.push(circle);
        } else if (isLine(tree[key])) {
            obj.addLine(key);
        } else if (isConfigurationNode(tree[key])) {
            obj.addConfigurationNode(key);
        } else { 
            console.log(`Failed to draw type: "${tree[key].object}", name: "${tree[key].name}", key: "${key}"`);
        }
    });
    return obj;
}

/* Utility methods */

function isParentlessNode(obj) {
    return obj.parent == null && obj.from == null && obj.to == null &&
    obj.latitude != null && obj.longitude != null;
}

function isParentChildNode(obj) {
    //return obj.parent != null && obj.latitude != null && obj.longitude != null;
    return obj.parent != null;
}

// add unit tests
function isLine(obj) {
    return obj.from != null && obj.to != null;
}

// add unit tests
function isConfigurationNode(obj) {
    //return obj.longitude == null && obj.latitude == null && obj.from == null && obj.to == null && obj.parent == null;
    return obj.longitude == null && obj.latitude == null && obj.from == null && obj.to == null;
}

/** 
 * TODO: add unit tests
 * @return {Object} SvgCircle - A fully configured svg circle.
 */
function createSvgCircle(key, {longitude, latitude, object}, {r = 2, strokeWidth = 0.5} = {}) {
    keyIsStringAndValidNumber(key);
    if (longitude == null || latitude == null || object == null) {
        //console.log(`For circle with tree key: "${key}", longitude was: "${longitude}",
        //latitude was: "${latitude}", object was: "${object}"`)
    }
	const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
	circle.setAttribute('id', key);
	circle.setAttribute('class', object);
	circle.setAttribute('r', r);
    circle.setAttribute('stroke-width', strokeWidth);
    // Set coordinates and consider if they need to be translated
    longitude = parseFloat(longitude);
    latitude = parseFloat(latitude);
    if (globalLonOffset !== null) {
        longitude -= globalLonOffset;
    }
    if (globalLatOffset !== null) {
        latitude -= globalLatOffset;
    }
    circle.setAttribute('cx', longitude);
    circle.setAttribute('cy', latitude);
    return circle;
}
/** 
 * TODO: add unit tests
 * @return {Object} SvgLine - A fully configured svg line.
 */
function createSvgLine(sourceNode, targetNode, key, thisObject) {
    const svgLine = document.createElementNS('http://www.w3.org/2000/svg', 'line'); 
    if (sourceNode.longitude == null || sourceNode.latitude == null || targetNode.longitude == null ||
    targetNode.latitude == null) {
        console.log(`For line with tree key: "${key}", sourceNode.name was: "${sourceNode.name}",
        sourceNode.longitude was: "${sourceNode.longitude}", sourceNode.latitude was: "${sourceNode.latitude}",
        targetNode.name was: "${targetNode.name}", targetNode.longitude was: "${targetNode.longitude}",
        targetNode.latitude was: "${targetNode.latitude}"`)
        //throw new Error(`For line with tree key: "${key}", sourceNode.longitude was: "${sourceNode.longitude}",
        //sourceNode.latitude was: "${sourceNode.latitude}", targetNode.longitude was: "${targetNode.longitude}",
        //targetNode.latitudw was: "${targetNode.latitude}"`)
    }
    // Set coordinates and consider if they need to be translated
    let sourceLon = parseFloat(sourceNode.longitude);
    let sourceLat = parseFloat(sourceNode.latitude);
    let targetLon = parseFloat(targetNode.longitude);
    let targetLat = parseFloat(targetNode.latitude); 
    if (globalLonOffset !== null) {
        sourceLon -= globalLonOffset;
        targetLon -= globalLonOffset;
    }
    if (globalLatOffset !== null) {
        sourceLat -= globalLatOffset;
        targetLat -= globalLatOffset;
    }
    svgLine.setAttribute("x1", sourceLon); 
    svgLine.setAttribute("x2", targetLon);
    svgLine.setAttribute("y1", sourceLat); 
    svgLine.setAttribute("y2", targetLat);
    if (key == null && thisObject == null) {
        // key and thisObject weren't included, so this line doesn't represent a real object in the tree, so it's a parent-child line.
        svgLine.setAttribute("id", `${sourceNode.name}_${targetNode.name}`);
        svgLine.setAttribute("class", "parentChild");
        svgLine.setAttribute("stroke-width", 0.25);
        return svgLine;
    } else if (key != null && thisObject != null) {
        keyIsStringAndValidNumber(key);
        svgLine.setAttribute("id", key);
        const phaseCount = countPhases(thisObject.phases).toString();
        const domClass = `${thisObject.object} p${phaseCount}`;
        svgLine.setAttribute("class", domClass);
        svgLine.setAttribute("stroke-width", phaseCount);
        return svgLine;
    }
    throw new Error("key and thisObject arguments must be passed together or not at all");
}

//**************************************************
// SVG interface
//**************************************************


/** What kind of event am I listening for? Just clicks? What about the drag box I thought about?
 * svg-pan-zoom handles drag events. So if the user held alt THEN dragged, then I could make a drag box.
 * 
 */
function svgContainerHandler(event) {
    //event.target.id
    //console.log(event.altKey);
}
//**************************************************
// TreeObject interface
//**************************************************

const treeObjectPrototype = {

    /* "Public" interface methods.*/

    /** 
     * TODO: add unit tests
     */
    //update(map) {
    //    this.data = deepCopy(map);
    //},

    /* "Private" helper methods */
};

/**
 * Return a key value which has not been used in tree.
 * @return {string} key
 */
function getNewTreeKey(tree) { 
	let nextKey = Object.keys(tree).length;
	while(tree.hasOwnProperty(nextKey.toString())) {
		nextKey += 1;
	}
	return nextKey.toString();
}

// Fix this function. Some lines have CLOSED instead of ABCN or something.
function countPhases(p) {
	// Return the number of phases a line has.
	//return p.length
	let total = 0
	if (p.search('A') > -1) {total++}
	if (p.search('B') > -1) {total++}
	if (p.search('C') > -1) {total++}
	return total;
}

/** 
 * Return a TreeObject.
 * 
 * A TreeObject (which is not to be confused with a more general "tree object") is either:
 * 1) a copy of a component that is in the process of being added to the tree, OR
 * 2) a copy of an existing object in the tree.
 * 
 * @param {(string|Object)} input - either a key OR a map of properties to create this TreeObject.
 * @param {TreeWrapper} tree - the treeWrapper from which to create this TreeObject.
 * return {TreeObject} - Either a new component that does not exist in the tree, or a copy of an existing tree object 
 * inside of the treeWrapper argument.
 */
function createTreeObject(input, treeWrapper) {
    if (Object.getPrototypeOf(treeWrapper) !== treeWrapperPrototype) {
        throw new Error("treeWrapper argument must be an instance of TreeWrapper");
    }
    //const treeObject = Object.create(treeObjectPrototype);
    const treeObject = {};
    if (typeof(input) === "string") {
        keyIsStringAndValidNumber(input);
        const obj = treeWrapper.tree[input];
        if (obj != null) {
            treeObject.key = input;
            treeObject.data = deepCopy(obj);
            return treeObject;
        }
        throw new Error(`The passed key argument: "${input}" to create the TreeObject does not exist in the treeWrapper.tree.`);
    } else if (typeof input === "object" && !Array.isArray(input)) {
        treeObject.key = getNewTreeKey(treeWrapper.tree);
        treeObject.data = deepCopy(input);
        //treeObject.update(input);
        return treeObject;
    } 
    throw new Error("Input argument must be a string or an object.");
}

/** 
 * Return an object that is a copy of the argument object.
 * JSON.stringify will not copy a property of an object with an undefined value.
 * @param {Object} oldObject - the object to copy.
 * @return {Object} - a copy of the object argument.
 */
function deepCopy(oldObject) {
    if (Object.getPrototypeOf(oldObject) !== Object.prototype) {
        throw new Error("This function cannot be used to copy objects created with a constructor function.");
    }
    const properties = Object.getOwnPropertyNames(oldObject);
    const keys = Object.keys(oldObject);
    for (let key of keys) {
        if (typeof(oldObject[key]) === "function") {
            throw new Error("This function cannot be used to copy objects with methods.");
        } else if (oldObject[key] === undefined) {
            throw new Error("JSON.stringify silently ignores properties with undefined values, so this function cannot handle undefined values.");
        }
    }
    return JSON.parse(JSON.stringify(oldObject));
}

/**  
 * TODO: add unit tests
 */
function keyIsStringAndValidNumber(key) {
    if (typeof(key) !== "string") {
        throw new Error("key argument must be a string.");
    }
    if (isNaN(parseFloat(key))) {
        throw new Error("key argument must be a string that can be parsed to a valid number");
    }
}

//**************************************************
// Table interface 
//**************************************************

/* These are names of properties in most objects in writeFeeder.tree that cannot be deleted from objects. 
They are a mix of properties that can be found in objects with a parent, objects without a parent,
and objects that represent lines. See my notes for reasoning behind designating these properties as non-deleteable.
This global array is a hard-coded data-dependency, but it's necessary at this point because the raw data does not define
whether or not a property is key to identifying an object in the svg graph. Maybe these hard-coded dependencies could be moved
so some other configuration file, like the components?
*/
const nonDeletableProperties = ["name", "object", "from", "to", "latitude", "longitude", "parent", "configuration"];
/* If these properties were to be modified for a given writeFeeder.tree object, it would require significantly modifying the 
other objects.  These properties ARE technically modifiable, but allowing the user to change them would require more work 
than I think is worth it. It is easier just to create a new node.
We can remove or add properteis to this array as the needs of the interface change.
*/
const nonModifiableProperties = ["name", "object", "from", "to", "parent"];

const titleProperties = ["object"];

/**
 * TODO: add unit tests
 * If an object has no name, just get the first property in the object.
 */
function createSelectionTable(ids, tWrapper) {
    const table = document.createElement("table");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody"); 

    const row = createRow({key: "Selected Elements"});
    Array.from(row.self.children).forEach(td => { td.classList.add("tableTitle") });
    row.self.children[1].setAttribute("colspan", "2");
    row.self.children[2].remove();

    tHead.append(row.self);
    table.append(tHead);
    table.append(tBody);
    table.classList.add("dataTable");
    ids.forEach(id => {
        let obj = tWrapper.tree[id];
        let name = obj.name != null ? obj.name : Object.keys(obj)[0];
        let button = document.createElement("button");
        button.textContent = "view";
        button.classList.add("modalButton");
        button.addEventListener("click", function() {
            let table = document.getElementById(`table_${id}`);
            if (table == null) {
                const table = createDescriptionTable(id, tWrapper);
                table.id = `table_${id}`;
                document.getElementById("descriptionTables").append(table);
            }           
        });
        let row = createRow({key: name, value: button, deletable: true}, id);
        tBody.append(row.self);
    });
    if (window.jQuery != null) {
        table.style.left = "50vw";
        $(table).draggable();
    }
    return table;
}

/**
 * TODO: add unit tests, don't allow longitude and latitude to be editted for lines!, turn all key inputs into plain text upon clicking save (would look nice)
 * The form element is only used to take advantage of the "required" form validation functionality that is native to the
 * browser.
 */
function createDescriptionTable(id, tWrapper) {
    const form = document.createElement("form");
    form.classList.add("formContainer");
    const table = document.createElement("table");
    table.classList.add("dataTable");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody");
    const buttonRow = document.createElement("tr");
    buttonRow.classList.add("buttonRow");
    const buttonCell = document.createElement("td");
    buttonCell.setAttribute("colspan", "3");
    form.append(table);
    table.append(tHead);
    table.append(tBody);
    tBody.append(buttonRow);
    buttonRow.append(buttonCell);
    const tObject = createTreeObject(id, tWrapper);
    if (!isLine(tObject.data)) {
        buttonCell.append(createButton({action: "move", tObject: tObject, tWrapper: tWrapper, tableBody: tBody}).self);
    } 
    buttonCell.append(createButton({action: "delete", tObject: tObject, tWrapper: tWrapper, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "add", tObject: tObject, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "save"}).self);
    form.addEventListener("submit", function(event) {
        event.preventDefault();
        const svg = createAddableSvgData(tWrapper.insert(tObject));
        svg.redrawTo(gViewport);
        alert("Object saved");
    });
    Object.keys(tObject.data).forEach(key => {
        let row;
        if (titleProperties.includes(key)) {
            row = createRow({key: key, map: tObject.data});
            Array.from(row.self.children).forEach(td => {
                td.classList.add("tableTitle");
            });
            tHead.append(row.self);
        } else {
            row = createRow({key: key, deletable: true, map: tObject.data});
            tBody.appendChild(row.self);
        }
    });
    if (window.jQuery != null) {
        //TODO: fix this
        //form.style.left = "50vw";
        //$(form).draggable();
        table.style.left = "50vw";
        $(table).draggable();
    }
    return form;
}

const buttonPrototype = {

    /* Private helper methods */

    /**
     * TODO: add unit tests
     * Add a click listener to the svgContainerWrapper which is the direct parent of the svgContainer. The
     * svgContainerWrapper will intercept a click before it reaches the svgContainer and invoke moveNode().
     */
    addMoveListener() {
        const element = document.getElementById("svgContainerWrapper");
        element.setAttribute("style", "cursor: crosshair");
        const that = this;
        element.addEventListener("click", moveNode, true);
        function moveNode(event) {
            event.stopPropagation();
            document.getElementById("svgContainerWrapper").removeEventListener("click", moveNode, true);
            const coords = clickLatLon(event);
            that.tObject.data.longitude = coords.x;
            that.tObject.data.latitude = coords.y;
            const subWrapper = that.tWrapper.insert(that.tObject);
            createAddableSvgData(subWrapper).redrawTo(gViewport);
            element.setAttribute("style", "cursor: default");
            // Update the table with the new coordinates
            Array.from(that.tableBody.getElementsByTagName("input")).forEach(input => {
                if (input.dataset.coordinate === "latitude") {
                    input.value = coords.y;
                } else if (input.dataset.coordinate === "longitude") {
                    input.value = coords.x;
                }
            });
        }
    },

    /**
     * Delete the TreeObject of this button from the TreeWrapper of this button
     */
    deleteObject() {
        let subWrapper;
        try {
            subWrapper = this.tWrapper.delete(this.tObject.key);
            createDeletableSvgData(subWrapper.tree).deleteFrom(gViewport);
        } catch (e) {
            if (confirm(e + " Alternatively, do you wish to delete this node and all of its immediately connected objects?")) {
                subWrapper = this.tWrapper.recursiveDelete(this.tObject.key);
                createDeletableSvgData(subWrapper.tree).deleteFrom(gViewport);
            }
        }
    },
}

/**
 * TODO: add unit tests
 */
function createButton({action, tableBody=null, tObject=null, tWrapper=null}) {
    validateButtonArguments(arguments[0]);
    const button = Object.create(buttonPrototype);
    button.self = document.createElement("button");
    button.self.textContent = action;
    button.self.classList.add("modalButton");
    button.tObject = tObject;
    button.tWrapper = tWrapper;
    button.tableBody = tableBody;
    button.self.type = "button";
    switch (action) {
        case "move":
            button.self.addEventListener("click", function() {
                button.addMoveListener();
            });
            break;
        case "delete":
            button.self.classList.add("deleteButton");
            button.self.addEventListener("click", function() {
                button.deleteObject();                
                document.getElementById("descriptionTables").removeChild(tableBody.parentElement.parentElement);
            });
            break;
        case "add":
            button.self.addEventListener("click", function() {
                const row = createRow({key: "", deletable: true, map: tObject.data});
                tableBody.append(row.self);
            });
            break;
        case "save":
            button.self.type = "submit";
            break;
        default:
            throw new Error("The action argument must be a string that matches an existing action for this button.");
    }
    return button;
}

/**
 * TODO: add unit tests
 */
function validateButtonArguments(args) {
    if (args.action === "move") {
        if (args.tObject == null || args.tWrapper == null || args.tableBody == null) {
            throw new Error(`A button with a "${args.action}" action must have non-null tObject, tWrapper, and tableBody arguments`);
        }
    } else if (args.action === "delete") {
        if (args.tObject == null || args.tWrapper == null || args.tableBody == null) {
            throw new Error(`A button with a "delete" action must have non-null tObject, tWrapper, and tableBody arguments`);
        }
    } else if (args.action === "add") {
        if (args.tObject == null || args.tableBody == null) {
            throw new Error(`A button with an "add" action must have non-null tObject and tableBody arguments`);
        }
    } else if (args.action !== "save") {
        throw new Error(`The action argument must match an existing action`);
    }
}

const rowPrototype = {

    /* Private helper methods */

    /**
     * Throw an error if arguments passed to createRow() were invalid.
     * @param {Object} args - an object containing the arguments that were passed to createRow()
     */
    validateArguments(args) {
        if (args.key != null && args.value != null && args.map != null) {
            throw new Error(`If there are key and map arguments, then the value of the row is determined by map[key] and passing a value
            argument is invalid`);
        } else if (args.map != null && args.map[args.key] === undefined && args.key !== "") {
            throw new Error("If a map argument is passed, the key argument should exist in that map.");
        } else if (args.key === "" && args.map == null) {
            throw new Error("If the key is an empty string, a map argument should be passed to the function");
        }
    },

    /**
     * Return false if the key already exists in the map or, otherwise return true.
     * @param {string} key - the incoming key that the user wants to write into the map belonging to this Row.
     * @return {boolean}
     */
    validateNewKey(key) {
        if (this.map[key] !== undefined || key === "") {
            return false;
        }
        return true;
    },

    /** 
     * Return false if the current key is an empty string, otherwise return true.
     * @return {boolean}
     */
    validateCurrentKey() {
        return this.key === "" ? false : true;
    },

    /**
     * Update a key in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new key that should be written to the map, if it is valid.
     */
    updateMapKey(input) {
        const newKey = input.value.trim();;
        if (this.validateNewKey(newKey)) {
            this.map[newKey] = this.map[this.key] != null ? this.map[this.key] : "";
            delete this.map[this.key];
            this.key = newKey;
        } else {
            alert(`Please enter a unique, valid key for this object.`);
            input.value = this.key;
        } 
    },
    /**
     * Return an HTMLTableCellElement.
     * @return {HTMLTableCellElement}
     */
    getKeyElement() {
        const td = document.createElement("td");
        if (this.key === "") {
            const input = document.createElement("input");
            input.classList.add("modalInput");
            td.appendChild(input);
            input.required = true;
            input.pattern = "[\\s]*[\\S]+.*";
            //if (input.validity.valueMissing) {
            //    input.setCustomValidity("Please fill out this field. Alternatively, delete this row.");
            //}
            const that = this;
            input.addEventListener("change", function() {
                that.updateMapKey(this);
            });
        } else {
            td.textContent = this.key;
        } 
        return td;
    },

    /** 
     * Return true if the value is valid for the Row (based on the key of that Row), otherwise return false.
     * @param {string} value - a value for a corresponding key that should be validated based on the key.
     * @return {boolean}
     */
    validateNewValue(value) {
        if (this.key === "longitude" || this.key === "latitude") {
            return !isNaN(parseFloat(value));
        }
        return true;
    },

    /** 
     * Update a value in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new value that should be written to the map, if the value is valid.
     */
    updateMapValue(input) {
        if (!this.validateCurrentKey()) {
            alert("Please enter a valid key for this row before entering a value.");
            input.value = "";
            return;
        }
        const newValue = input.value.trim();
        if (this.validateNewValue(newValue)) {
            this.map[this.key] = newValue;
        } else {
            alert(`The value "${newValue}" is invalid for for the key "${this.key}" in the table.`);
            input.value = this.map[this.key];
        }
    },
    /** 
     * Return an HTMLTableRowElement.
     * @param {Array} nonModifiableProperties - a hard-coded array of properties that the user shouldn't be able to modify.
     * @return {HTMLTableRowElement}
     */
    getValueElement(nonModifiableProperties) {
        const td = document.createElement("td");
        if (typeof(this.value) === "string") {
            td.textContent = this.value;
            return td;
        } else if (this.value instanceof HTMLElement) {
            td.append(this.value);
            return td;
        } else if (this.value == null) {
            if (this.map == null) {
                return td;
            } else {
                const value = this.key === "" ? "" : this.map[this.key];
                if (nonModifiableProperties.includes(this.key)) {
                    td.textContent = value;
                } else {
                    const input = document.createElement("input");
                    if (this.key === "longitude") {
                        input.dataset.coordinate = "longitude";
                    } else if (this.key === "latitude") {
                        input.dataset.coordinate = "latitude";
                    }
                    input.classList.add("modalInput");
                    td.appendChild(input);
                    const that = this;
                    input.addEventListener("change", function() {
                        that.updateMapValue(this);
                    });
                    input.value = value;
                }
                return td;
            }
        }
        throw new Error("Invalid value was provided for this row");
    },

    /** 
     * TODO: add unit tests
     * Return an HTMLTableRowElement.
     * @param {boolean} deletable - whether or not the returned <td> should have a delete button element child.
     * @param {Array} nonDeletableProperties - a hard-coded array of properties that the user should not be able
     * to delete from a TreeObject.
     * @return {HTMLTableRowElement}
     */
    getDeleteElement(deletable, nonDeletableProperties) {
        const td = document.createElement("td");
        if (deletable === true && !nonDeletableProperties.includes(this.key)) {
            const btn = document.createElement("button");
            btn.innerHTML = "&#9587;"
            btn.setAttribute("class", "modalButton deleteButton"); 
            td.appendChild(btn);
            const that = this;
            btn.addEventListener("click", function() {
                that.delete();
            });
        } 
        return td;
    },

    /**
     * TODO: update unit tests
     * Delete the row from the table. Delete the key from the map, if there was a map.
     * Remove "selected" from the classList of the element, if elementId is set.
     */
    delete() {
        if (this.map != null) {
            delete this.map[this.key];
        } 
        if (this.elementId != null) {
            document.getElementById(this.elementId).classList.remove("selected");
            const table = document.getElementById(`table_${this.elementId}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
            //const tables = Array.from(document.querySelectorAll("[data-tableid]"));
            //tables.forEach(t => {
            //    if (t.dataset.tableid === this.elementId) {
            //        document.getElementById("descriptionTables").removeChild(t);
            //    }
            //});
            if (getSelected().length === 0) {
                destroyTables(["selectionTable"]);
            }
        }
        this.self.parentElement.removeChild(this.self);
    },

    /**
     * TODO: add unit tests
     */
    updateInput() {
        //need a direct reference to the input of the row for convenience.
    }
}

/** 
 * Return a Row that can be appended to a table.
 * 
 * @param {string} key - the key of the row, which must be a property of the map argument if the map argument is not null.
 * @param {string|HTMLElement} - an optional value of the row.
 * @param {Object} map - an optional object that contains the data being manipulated by all of the rows. 
 * @param {boolean} deletable - whether or not the row should have a delete button.
 * @return {Row} - A wrapper object around the HTMLTableRowElement.
 */ 
function createRow({key, value=null, map=null, deletable=false}) {
    const obj = Object.create(rowPrototype);
    obj.validateArguments(arguments[0]);
    obj.key = key;
    obj.value = value;
    obj.map = map;
    obj.self = document.createElement("tr");
    obj.self.append(obj.getDeleteElement(deletable, nonDeletableProperties));
    obj.self.append(obj.getKeyElement());
    obj.self.append(obj.getValueElement(nonModifiableProperties));
    if (arguments[1] != null) {
        obj.elementId = arguments[1];
    }
    return obj;
}

//**************************************************
// Initialization
//**************************************************

function attachMouseListeners() {
    let downEvent;
    document.getElementById("svgContainer").addEventListener("mousedown", function(event) {
        downEvent = event;
    });
    document.getElementById("svgContainer").addEventListener("mouseup", function(upEvent) {
        svgClick(downEvent, upEvent);
    });
}


//setTimeout(main,100)
(() => {
    //buildFeeder();
    //const t0 = performance.now();

    gTreeWrapper = createTreeWrapper(writeFeeder.tree);
    //createViewport(writeFeeder.tree, document.getElementById("svgContainer"));
    createViewport(gTreeWrapper, document.getElementById("svgContainer"));
    gViewport = document.getElementsByClassName('svg-pan-zoom_viewport')[0];
    const svg = createAddableSvgData(gTreeWrapper);
    svg.addTo(gViewport);

    //document.getElementById("svgContainer").addEventListener("click", function(event) {
    //    svgClick(event);
    //});
    attachMouseListeners();

    attachHandlers();
    // Interface setup
    document.getElementById("searchInput").addEventListener("change", getSearchResults);
    // jQuery
    if (window.jQuery != null) {
        applyJQueryStyles();
    } else {
        disableJQueryFunctionality();
    }
    document.getElementById('loadingMessage').style.display = 'none'
    /* 
    const t1 = performance.now();
    const time = t1 - t0;
    console.log(`Tree rendering time was ${time} ms`);
    */
    
    /*
    setTimeout(function() {
        const deleteSvgData = createDeletableSvgData(gTreeWrapper.tree);
        deleteSvgData.deleteFrom(viewport);
    }, 2000);
    */
})();

//ADD PROMPT TO SAVE CHANGES BEFORE EXIT
{% if showFileMenu %}
	window.onbeforeunload = function(e) {
        if (JSON.stringify(readFeeder) !== JSON.stringify(writeFeeder)) {
            const confirmationMessage = `It looks like you have been editing something. 
            If you leave before saving, your changes will be lost.`;
            return confirmationMessage;
        }
	};
{% endif %}
</script>
<!--<script type='text/javascript' src='/static/distDataValidation.js'></script>-->
{% if spec %}{{ spec | safe }}{% endif %}