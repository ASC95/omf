<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<style >
            /* Define global css variables */
            :root {
                --header-height: 25px;
                --header-padding-top: 10px;
                --header-padding-bottom: 10px;
            }
			* { 
                font-family: Helvetica, Arial, Sans-Serif;
            }
			div.divButton {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				cursor: pointer;
				cursor: hand;
				position:fixed;
				width:30px;
				height:30px;
				text-align:center;
				font-size:30px;
				line-height:30px;
				color:white;
			}
			body {
                /*width: 100%;
                height: 100%;*/
                margin:0px;
            }
			a {
				text-decoration: none;
                color: mediumseagreen;
                /*color: black;*/
			}
            a:visited {
                color: seagreen;
            }

            /* SVG */

            #interfaceContainer {
                position: relative;
            }

            /* This is the element that acts as a hook for svg-pan-zoom.js to attach a viewport, which it creates itself */
			#svgContainer {
                /* width must be 100%, meaning 100% of the document */
				width: 100%; 
                /* height must be manually set to a hard value */
				height: calc(100vh - var(--header-height) - var(--header-padding-bottom) - var(--header-padding-top));
                /* overflow: hidden is set by svg-pan-zoom.js itself. No need to change that here. */
			}
			#saveButton {
				float:right;
			}

            div#loadingMessage {
                width: 100%;
                height: 100%;
				/*background-color: rgba(0,0,0,0.4); */
                background-color: white;
                position: fixed;
                top: 0px;
            }

			/* Load Spinner */

			.loader {
				margin: 60px auto;
				font-size: 10px;
				position: relative;
				text-indent: -9999em;
				border-top: 1.1em solid rgba(255, 255, 255, 0.2);
				border-right: 1.1em solid rgba(255, 255, 255, 0.2);
				border-bottom: 1.1em solid rgba(255, 255, 255, 0.2);
				border-left: 1.1em solid #ffffff;
				-webkit-transform: translateZ(0);
				-ms-transform: translateZ(0);
				transform: translateZ(0);
				-webkit-animation: load8 1.1s infinite linear;
				animation: load8 1.1s infinite linear;
			}
			.loader,
			.loader:after {
				border-radius: 50%;
				width: 10em;
				height: 10em;
			}
			@-webkit-keyframes load8 {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}
			@keyframes load8 {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}

            /**************************************************
            // Header and menu links
            **************************************************/

			#header {
				width:100%;
				height: var(--header-height);
				padding-top: var(--header-padding-top);
				padding-bottom: var(--header-padding-bottom);
				background:black;
                /*position: absolute;*/
				/*min-width:1000px;*/
			}
            #helpDiv a {
                color: white;
            }
			/*#menuLeft{ height:40px; float:left; font-size:medium; color:white; margin-left:5px;}*/
			#menuRight{ 
				/*height:40px;
				font-size:medium;
				color:white;*/
				float:right;
				display:flex;
				/*justify-content: space-between;
				width: 162px*/
			}
			/*#arrow { font-size:8pt; position:absolute; margin-top:2px; margin-left:4px; display:inline; }*/
            .headerDiv {
                margin-right: 15px;
                cursor: pointer;
            }
			ul.menu {
				position: absolute;
				top: 100%;
				left: 0;
				z-index: 1000;
				min-width: 100px;
				padding: 5px 0px 5px 0px;
				margin: 0px;
				list-style: none;
				display: none;
				text-align:left;
				background-color:#F8F8F8;
				padding:0;
				/*border: 1px solid #CCC;*/
				-webkit-border-radius: 5px;
				-moz-border-radius: 5px;
				border-radius: 5px 0px 5px 5px;
				-webkit-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				-moz-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				-webkit-background-clip: padding-box;
			}
			ul.menu.right { 
                right:0;
                left:auto;
                padding:5px 0px 5px 0px;
                overflow-y:auto;
                overflow-x:hidden;
                max-height:550px; 
                cursor: pointer;
            }
			ul.menu.left { right:auto; left:auto; padding:0 0 0 0; }
			ul.menu.center { right:auto; left:-45%; }
			ul.menu li { 
                padding: 4px; 
                }
			ul.menu li:hover { background:green; color:white; }
			ul.menu li:hover a { color:white; }
			ul.menu a { 
                display:block;
                color:black;
                /*padding:4px;*/
                }
			ul.menu a:hover {color:white;}
			ul.menu { display:block; color:black; padding:4px; }
			ul.menu ul.menu:hover, ul.menu:visited:hover { color:white; }
			div.buttonGroup { display:inline-block; position:relative; }
			button.pill {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				color:white;
				font-size:medium;
				width: auto;
				height:35px;
				margin: 0px;
				margin-top:-5px;
				padding:0.3em;
				border-radius: 5px 5px 0 0;
				background-color:#E0E0E0;
				display:inline-block;
				border:none;background:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;
				white-space: nowrap;
				display:inline-block;
                cursor: pointer;
			}
			button.pill:hover{background:transparent;}

            /**************************************************
            // Modal Dialogs
            **************************************************/

            #loadModalTable {
                width: 890px;
            }
            /*#milsoftInput {
                width: 100%;
            }*/
            #progressModalCancel {
                background-color: crimson;
            }
            #progressModal {
                z-index: 1;
            }
            #massAddModal .modalContent {
                width: 400px;
            }
            #climateModal label {
                white-space: nowrap;
            }
            #anonymizeModal {
                white-space: nowrap;
            }
			.modal {
                position: fixed;
                top: 0px;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
				background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
			}
	 		.modalContent {
                padding: 20px;
                border-radius: 10px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: space-evenly;
				background-color: #fefefe;
                /*height: 380px;*/
                overflow: hidden;
			}
            .modalInput {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
                width: 100%;
            }
            .modalInputLine {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
            }
            .modalButton {
                font-size: medium;
                background-color: seagreen;
                -webkit-border-radius: 5px;
                -moz-border-radius: 5px;
                border-radius: 5px;
                border: none;
                color: white;
                cursor: pointer;
                padding: 4px 6px 4px;
            }
            #cancelButton {
                background-color: crimson;
            }
            .modalContent td:nth-of-type(2) {
                text-align: right;
            }
            .modalTableHeader {
                text-align: left;
            }
            .modalTableRow {
                width: 50%;
            }
            .scrollableList {
                overflow: auto;
                height: 240px;
                list-style-type: none;
                margin: 0px 0px 0px 20px;
                padding: 0;
                cursor: pointer;
            }
            .feederItem {
                padding: 5px 5px 5px 5px;
                margin: 10px 0px 10px 0px;
            }
            .feederItem:hover {
                color: white;
                background-color: green;
            }
            /*
            input:valid {
                border: 1px solid white; 
            }
            */
            input:invalid {
                /*Aborder: 1px solid red;*/
            }            

            /* Tree tables */

            .buttonRow {
                /*text-align: center;*/
            }
            .buttonRow button {
                margin-right: 5px;
            }
            /*
            .treeTable {
                background-color: white; 
            }
            .treeTable tr {
            }
            .treeTable tr:last-child {
                border: 0px;
            }
            */
            thead td {
                
            }
            .tableInput {
                font-size: small;
                background-color: gainsboro;
                padding: 3px;
                border: 0px;
            }
            .deleteButton {
                background-color: #CC0000;
                /*padding: 1px 7px 1px 7px;*/
            }
            /* TODO: might need to delete this rule */
            .editButton {
                font-size: small;
                /*width: 100%;*/
            }

			/* dataTable */

            #descriptionTables {
                position: absolute;
                top: 0px;
                height:0px;
            }

            #selectionTable {
                position: absolute;
                top: 0px;
                height:0px;
            }

            .formContainer {
				/*position: fixed;*/
				/*top: 55px;*/
                height:0px;
				/*right: 5px;*/
            }

            /* Don't set overflow-y to hidden */
			.dataTable {
                position: fixed;
				top: 55px;
				border:1px solid black;
				border-collapse: collapse;
                display: inline-block;
                overflow-x: hidden;
				max-height: 90vh;
			}
            .dataTable tr {
                border-bottom: 1px solid black;
            }
            .dataTable tr:last-child {
                border: 0px;
            }
            /*.dataTable p {
                margin: 0px;
            }*/
            .tableTitle {
                background-color: black;
                color: white;
            }
			tbody {
				/*border: 1px solid black;*/
                border-collapse: collapse;
			}
			td {
				background:white;
				padding: 5px;
				border-collapse: collapse;
			}
			th {
				/*font-weight: normal;*/
				/*background:black;*/
				/*color:white;*/
				padding: 5px;
			}
			/*
            #editButtonRow button {
				font-size: small;
				color: white;
				background: seagreen;
				padding: 5px;
				border-radius: 5px;
				width: 100%;
			}
            */
            /*
			#editButtonRow button:hover {
				outline:0;
				outline: none; 
				background:mediumseagreen;
			}
            */
        </style>
        <link rel="stylesheet" href="/static/jquery-ui.min.css">
        <script type="text/javascript" src="/static/jquery.js"></script>
        <script type="text/javascript" src="/static/jquery-ui.min.js"></script>
		<script type='text/javascript' src='/static/svg-pan-zoom.js'></script>
		{% if jasmine %}{{ jasmine | safe }}{% endif %}
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Largest.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Norfork.js'></script> -->
	</head>
	<!--<body onkeypress='hotkeys()'>-->
    <body>
        <div id="interfaceContainer">
            <div id="loadingMessage">
                <p style="font-size:60pt; text-align:center; width:100%;">Feeder Loading...</p>
            </div>
            <div id="descriptionTables"></div>
            <div id="selectionTable"></div>
            <!-- Controls -->
            <div style='background:dimgrey; top:55px; left:5px' class='divButton' onclick='window.panZoom.zoomIn()' title='Zoom In'>+</div>
            <div style='background:dimgrey; top:95px; left:5px' class='divButton' onclick='window.panZoom.zoomOut()' title='Zoom Out'>-</div>
            <div style='background:dimgrey; top:135px; left:5px' class='divButton' onclick='window.panZoom.reset()' title='Reset Zoom'>R</div>
            <div style='background:dimgrey; top:175px; left:5px;' class='divButton' onclick='scaleTo(parseFloat(prompt("Scale line thickness by this multiple:", scaleLevel)))' title='Scale To'>S</div>
            <!-- <div style='background:navy; top:215px; left:5px' id='saveLink' class='divButton' onclick='saveSvg()' title='Save File' download>S</div> -->
            <!-- Menu Bar -->
            <div id='header'>
                <div id="menuRight">
                    <div id="helpDiv" class="headerDiv">
                        <div class="buttonGroup">
                            <button class='pill' type = 'submit'>
                                <a id='helpButton' href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit' target='_blank'>Help</a>
                            </button>
                        </div>
                    </div>
                    <div id="editDiv" class="headerDiv">
                        <div class="buttonGroup">
                            <button id="addOps" class='pill' onclick='dropPill(this, "Edit")'>Edit &#x25BE;</button>
                            <ul id="editMenu" class='menu right' style="display: none">
                                <!--<li>Zoom To Fit</li>-->
                                <!--<li>Zoom Reset</li>-->
                                <li>Static Loads to Houses</li>
                                <li data-web>Scada Loadshapes...</li>
                                <li data-web>Add AMI Profiles...</li>
                                <li>Find...</li>
                                <li>Mass Add...</li>
                                <li>Mass Edit...</li>
                                <li>Attachments...</li>
                                <li data-web>Climate...</li>
                                <li data-web>Anonymization...</li>
                            </ul>
                        </div>
                    </div>
                    <div id="addDiv" class="headerDiv">
                        <div class="buttonGroup">
                            <button id="addOps" class='pill' onclick='dropPill(this, "Add")'>Add &#x25BE;</button>
                            <ul id='componentList' class='menu right' style="display: none">
                        </div>
                    </div>
                    {% if showFileMenu %}
                    <div id="fileDiv" class="headerDiv">
                        <div class='buttonGroup'>
                            <button id="fileOps" class='pill' onclick='dropPill(this, "File")'>File &#x25BE;</button>
                            <ul id='fileMenu' class='menu right' style="display: none">
                                <li data-web>Save</li>
                                <li>View Raw Data</li>
                                <li data-web>Rename</li>
                                <li data-web>Load from Model...</li>
                                <li data-web>New Blank Feeder...</li>
                                <li data-web>Windmil Conversion...</li>
                                <li data-web>GridLAB-D Conversion...</li>
                                <li data-web>CYMDIST Conversion...</li>
                            </ul>
                        </div>
                    </div>
                    {% endif %}
                </div>
            </div>
            <!-- Svg container -->
            <div id="svgContainerWrapper" style="height: auto;">
                <svg id='svgContainer' xmlns='http://www.w3.org/2000/svg'>
                    <style type="text/css">
                        <![CDATA[
                        .house {fill:blue;}
                        .triplex_meter {fill:orange;}
                        .underground_line {stroke:gray;}
                        .transformer {stroke:orange;}
                        .regulator {stroke:red;}
                        line {stroke:black;}
                        line.parentChild {stroke:LightGrey;}
                        circle {stroke:white; fill:gray;}
                        line.selected, circle.selected {stroke:lime;}
                        ]]>
                    </style>
                </svg>
            </div>
            <!-- Modals -->
            <div id='findModal' class="modal" style="display: none">
                <div class='modalContent'>
                    <table>
                        <tr>
                            <td>Term</td>
                            <td><input id='searchInput' type='text' value="Enter a search term" class="modalInput"></td>
                            <td id="searchCount"></td>
                        </tr>
                        <tr>
                            <td><button id="findPrevious" class="modalButton">Previous</button></td>
                            <td><button id="findNext" class="modalButton">Next</button></td>
                            <td><button class="modalButton" onclick='toggleElementDisplay("findModal")'>Cancel</button></td>
                        </tr>
                    </table>
                </div>
            </div>
            <div id="progressModal" class="modal" style="display: none">
                <div class="modalContent">
                    <img src="/static/spinner.gif">
                    <h2>text...</h2>
                    <button class="modalButton" id="progressModalCancel">Cancel</button>
                </div>
            </div>
            <div id="loadModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table id="loadModalTable">
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Public Feeders</th>
                                <th class="modalTableHeader modalTableRow">My Feeders</th>
                            </tr>	
                            <tr>
                                <td class="modalTableRow"> 
                                    <ul id="publicFeederList" class="scrollableList"></ul>
                                </td>
                                <td class="modalTableRow"> 
                                    <ul id="userFeederList" class="scrollableList"></ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <button onclick="toggleElementDisplay('loadModal')" class="modalButton">Cancel</button>
                </div>
            </div>
            <div id="blankFeederModal" class="modal" style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'blankFeederForm'}); return false;"
                    action="/newBlankFeeder/{{thisOwner}}" id="blankFeederForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <input type='hidden' name='referrer' value='distribution'/>
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Blank Feeder</th>
                                </tr>
                                <tr>
                                    <td><label for="blankFeederInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="blankFeederInput" name='feederNameNew' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('blankFeederModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Create</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='milsoftModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'milsoftForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'milsoftInput'}); return false;"
                    action="/milsoftImport/{{thisOwner}}" id="milsoftForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Milsoft Conversion</th>
                                </tr>
                                <tr>
                                    <td><label for="milsoftInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="milsoftInput" name='feederNameM' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Data File (.std)</td>
                                    <td><input type='file' required id="stdFile" name='stdFile' accept='.std' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td>Equipment File (.seq)</td>
                                    <td><input type='file' required id="seqFile" name='seqFile' accept='.seq' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('milsoftModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table> 
                    </form>
                </div>
            </div>
            <div id='gridlabdModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'gridlabdForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'gridlabdInput'}); return false;"
                    action="/gridlabdImport/{{thisOwner}}" id="gridlabdForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">GridLab-D Conversion</th>
                                </tr>
                                <tr>
                                    <td><label for="gridlabdInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="gridlabdInput" name='feederNameG' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Data File (.glm)</td>
                                    <td><input type='file' required id="csvFile" name='glmFile' accept='.glm' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('gridlabdModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='cymeModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'cymeForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'cymeInput'}); return false;"
                    action="/cymeImport/{{thisOwner}}" id="cymeForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Cyme Conversion</th>
                                </tr>
                                <tr>
                                    <td><label for="cymeInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="cymeInput" name='feederNameC' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Network File (.mdb)</td>
                                    <td><input type='file' required id="mdbNetFile" name='mdbNetFile' accept='.mdb' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('cymeModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id="scadaModal" class="modal" style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'scadaForm', pollUrl:'/checkScadaLoadshape/{{thisModelName}}'}); return false;"
                    action="/scadaLoadshape/{{thisOwner}}/{{thisFeederName}}" id="scadaForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Scada Loadshapes</th>
                                    <th style='float:right;'>
                                        <a href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit#scada-loadshapes' target='_blank'>Format Help</a>
                                    </th>
                                </tr>
                                <tr>
                                    <td>File containing Scada load data (.csv)</td>
                                    <td><input type='file' required id="scadaFile" name='scadaFile' accept='.csv' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td colspan='100%'>Note: Model "Simulation Start Date" should lie within the Scada load's dates.</td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('scadaModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='amiModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'amiForm', pollUrl:'/checkLoadModelingAmi/{{thisModelName}}'}); return false;"
                    action="/loadModelingAmi/{{thisOwner}}/{{thisFeederName}}" id="amiForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">AMI Profiles</th>
                                    <th style='float:right;'>
                                        <a href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit' target='_blank'>Format Help</a>
                                    </th>
                                </tr>
                                <tr>
                                    <td>File containing AMI load data (.csv)</td>
                                    <td><input type='file' required id="amiFile" name='amiFile' accept='.csv' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td colspan='100%'>Note: Model "Simulation Start Date" should lie within the AMI profiles's dates.</td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('amiModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='massAddModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="massAdd(); toggleElementDisplay('massAddModal'); return false;">
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Mass Add</th>
                                </tr>
                                <tr>
                                    <td>Add component:</td>
                                    <td><select id='componentSelect'></select></td>
                                </tr>
                                <tr>
                                    <td>To each:</td>
                                    <td><select id='massAddTargetSelect'></select></td>
                                </tr>
                                <tr>
                                    <td>With probability for each attachment (float between 0.0 and 1.0):</td>
                                    <td><input type='text' pattern="^(1.0)|(0?(\.\d+))$" required id='percent' value='1.0' class="modalInput"/></td>

                                </tr>
                                <tr>
                                    <td><button onclick="toggleElementDisplay('massAddModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Apply</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='massEditModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader">Mass Edit</th>
                            </tr>
                            <tr>
                                <td>For each object of type</td>
                                <td><select id='massEditTargetSelect'></select></td>
                                <td>with attribute</td>
                                <td><input type='text' id='massEditAttribute' class="modalInput"></td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="addTo">Add value to attribute</td>
                                <td><input type='text' id='addToValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="delete">Delete Attribute</td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="change">Change attribute to</td>
                                <td><input type='text' id='changeValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            </tr>
                            <tr>		
                                <td><input type="radio" name="attributeOperation" value="multiplyBy">Multiply attribute by</td>
                                <td><input type='text' id='multiplyValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                                <td style="text-align: center" >and add</td>
                                <td><input type='text' id='andAddValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td>Or</td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="addAttribute"> Add new attribute</td>
                                <td><input type='text' id='newAttributeKey' class="modalInput"></td>
                                <td style="text-align: center">with value</td>
                                <td><input type='text' id='newAttributeValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td colspan="2">
                                    <button onclick="toggleElementDisplay('massEditModal')" class="modalButton" style="float: right">Cancel</button>
                                </td>
                                <td>
                                    <button onclick="massEdit(); toggleElementDisplay('massEditModal');" class="modalButton" style="float: left">Apply</button>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id='attachmentsModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <table>
                        <tbody>
                            <tr>
                                <td><select id='attachmentSelect'></select></td>
                            </tr>
                            <tr>
                                <td><button onclick="toggleElementDisplay('attachmentsModal')" class="modalButton">Cancel</button></td>
                                <td><button onclick="toggleElementDisplay('attachmentsModal'); editAttachment()" class="modalButton">Select</button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id='editAttachmentModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <table>
                        <tbody>
                            <tr>
                                <td id='attachmentTd'></td>
                            </tr>
                            <tr>
                                <td>
                                    <textarea rows='25' cols='80' id='editAttachmentBox'></textarea>
                                </td>
                            </tr>
                            <tr>
                                <td><button onclick="toggleElementDisplay('editAttachmentModal')" class="modalButton">Cancel</button></td>
                                <td><button onclick="saveAttachment(); toggleElementDisplay('editAttachmentModal');" class="modalButton">Save</button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id='climateModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'climateForm', pollUrl:'/checkClimateChange/{{thisOwner}}/{{thisModelName}}'}); return false;"
                    action="/climateChange/{{thisOwner}}/{{thisFeederName}}" id="climateForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <!--<input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>-->
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Climate Change</th>
                                </tr>
                                <tr>
                                    <td>
                                        <input id='historicalImport' type='radio' name='climateImportOption' value='historicalImport'>
                                        <label for='historicalImport'>Historical Weather</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td><label for='startDate'>Start Date (YYYY-MM-DD):</label></td>
                                    <td><input id='startDate' type='text' name='startDate' pattern='^\d{4}-\d{2}-\d{2}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td><label for='endDate'>End Date (YYYY-MM-DD):</label></td>
                                    <td><input id='endDate' type='text' name='endDate' pattern='^\d{4}-\d{2}-\d{2}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td><label for='airport'>Airport Code:</label></td>
                                    <td><input id='airport' type='text' name='airport' pattern='^[A-Z]{3}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td>
                                        <input id='tmyImport' type='radio' name='climateImportOption' value='tmyImport'>
                                        <label for='tmyImport'>tmy Import</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td><label for='zipCode'>Zip Code:</label></td>
                                    <td><input id='zipCode' type="text" name="zipCode" pattern='^\d{5}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('climateModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Apply</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='anonymizeModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'anonymizeForm', pollUrl:'/checkAnonymize/{{thisOwner}}/{{thisModelName}}'}); return false;"
                    action='/anonymize/{{thisOwner}}/{{thisFeederName}}' id="anonymizeForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <!--<input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>-->
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr><th>Anonymization</th></tr>
                                <tr><th class="modalTableHeader">Names and labels:</th></tr>
                                <tr>
                                    <td>
                                        <select name='anonymizeNameOption'>
                                            <option value="noChange">No change</option>
                                            <option value="pseudonymize">Pseudonymize</option>
                                            <option value="randomize">Randomize</option>
                                        </select>
                                    </td>
                                </tr>
                                <tr><th class="modalTableHeader">Locations:</th></tr>
                                <tr>
                                    <td>
                                        <input type='radio' id='noChange' name='anonymizeLocationOption' value='noChange' checked>
                                        <label for='noChange'>No Change</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='radio' id='translation' name='anonymizeLocationOption' value='translation'>
                                        <label for='translation'>Translate</label>
                                    </td>
                                </tr>
                                <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='translateRight' class="modalInputLine"> [ft] to the right and</td></tr>
                                <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='translateUp' class="modalInputLine"> [ft] up with a</td></tr>
                                <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='rotate' class="modalInputLine"> [degree] rotation.</td></tr>
                                <tr>
                                    <td>
                                        <input type='radio' id='randomize' name='anonymizeLocationOption' value='randomize'>
                                        <label for='randomize'>Random (Force Layout)</label>
                                    </td>
                                </tr>
                                <tr><th class="modalTableHeader">Electrical properties:</th></tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='modifyLengthSize' name='modifyLengthSize' value='modifyLengthSize'>
                                        <label for='modifyLengthSize'>Modify conductor length and cable size</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='smoothLoadGen' name='smoothLoadGen' value='smoothLoadGen'>
                                        <label for='smoothLoadGen'>Smooth AMI Loadshapes</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='shuffleLoadGen' name='shuffleLoadGen' value='shuffleLoadGen'>
                                        <label for='shuffleLoadGen'>Shuffle loads and generators:</label>
                                        <input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='shufflePerc' class="modalInputLine"> [%]</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='addNoise' name='addNoise' value='addNoise'>
                                        <label for='addNoise'>Add noise:</label>
                                        <input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='noisePerc' class="modalInputLine"> [%]</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <button type="button" onclick="toggleElementDisplay('anonymizeModal')" class="modalButton">Cancel</button>
                                        <button type="submit" class="modalButton" style="float: right">Apply</button>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <!-- Modals-->
        </div>
	</body>
</html>
<script id='componentsInsert'>const gComponents = {% if components %}{{ components | safe }}{% else %}null{% endif %}; 
</script>
<script id='feederInsert'>const readFeeder = {% if thisFeederData %}{{ thisFeederData | safe }}{% else %}null{% endif %}; 
</script>
<script id='panZoomInsert'>
</script>
<script type='text/javascript'>
//"use strict";
let thisFeederName = "{% if thisFeederName %}{{ thisFeederName | safe }}{% else %}null{% endif %}";
const thisFeederNum = {% if thisFeederNum %}{{ thisFeederNum | safe }}{% else %}null{% endif %}; 
const thisModelName = "{% if thisModelName %}{{ thisModelName | safe }}{% else %}null{% endif %}"; 
const thisOwner = "{% if thisOwner %}{{ thisOwner | safe }}{% else %}null{% endif %}"; 
const publicFeeders = {% if publicFeeders %}{{ publicFeeders | safe }}{% else %}null{% endif %};
const userFeeders = {% if userFeeders %}{{ userFeeders | safe }}{% else %}null{% endif %}; 
const writeFeeder = deepCopy(readFeeder);
// The global TreeWrapper can only be created after the entire file has been parsed.
let gSelection;
//let gTreeWrapper; 
let gTree;
let gViewport; 
let gOffsetX; 
let gOffsetY;
let gDownX;
let gDownY;
// Scale that all SVG objects are drawn at
let scaleLevel = 1.0; 

//**************************************************
// Selection Interface
//**************************************************

/**
 * TODO: add unit tests
 */
const selectionPrototype = {

    /* Public methods */

    includes(element) {
        return this.selectedElements.includes(element)
    },
    remove(element) {
        //const idx = this.selectedElements.findIndex(e => e === element);
        const elements = this.selectedElements.filter(e => e.id === element.id);
        if (elements.length === 0) {
            throw new Error("Remove operation failed. The element argument does not exist in this selection.");
        }
        elements.forEach(e => {
            e.classList.remove("selected");
            this.selectedElements.splice(this.selectedElements.indexOf(e), 1);
        });
    },
    add(element) {
        if (this.selectedElements.includes(element)) {
            throw new Error("Add operation failed. The element argument already exists in this selection.");
        } else if (element.classList.contains("selected")) {
            throw new Error("Add operation failed. The element argument already has the 'selected' class.");
        }
        element.classList.add("selected");
        this.selectedElements.push(element);
    },
    empty() {
        this.selectedElements.forEach(e => {
            e.classList.remove("selected");
        });
        this.selectedElements = [];
    },
    getKeys() {
        return this.selectedElements.map(element => {
            return element.id;
        });
    }
    /*
    getWrapper() {
        const tWrapper = createTreeWrapper();
        this.selectedElements.forEach(e => {
            tWrapper.add(e.id, gTreeWrapper);            
        });
        return tWrapper;
    },
    */
}

/**
 * DELETE THIS, but first incorporate it into isValidForAdd()
 * TODO: add unit tests, get rid of TreeObject.update(), get rid of this entirely
 * Return true if the TreeObject argument was successfully updated based on the selected HTMLElements, otherwise return false.
 */
 function updateTreeObject(tObject, tWrapper) {
    const keys = Object.keys(tWrapper.tree);
    const type = getType(tObject.data);
    switch (type) {
        case "line":
            if (keys.length === 2 && 
                keys.every(key => {
                    let objectType = getType(tWrapper.tree[key]);
                    // Can only add a line between childNodes and/or independentNodes
                    return objectType === "childNode" || objectType === "independentNode"
                })
            ) {
                tObject.update({to: tWrapper.tree[keys[0]], from: tWrapper.tree[keys[1]]});
                return true
            }
            break;
        case "configurationNode":
            break;
        case "childNode":
            if (keys.length === 1) {
                const objectType = getType(tWrapper.tree[keys[0]]);
                if (objectType === "childNode" || objectType === "independentNode") {
                    // Can only add a childNode to another childNode or an independentNode
                    tObject.update({parent: tWrapper.tree[keys[0]]});
                    return true
                }
            } 
            break;
        case "independentNode":
            break;
    }
    return false;
}

function createSelection() {
    const obj = Object.create(selectionPrototype);
    obj.selectedElements = [];
    return obj;
}

//let removeSelected;
//let addSelected;
//let emptySelected;
//let getSelectedElements;
//let getSelectedWrapper;
//let validateSelectedForAdd;
//let validateSelectedForMove;
/**
 * TODO: add unit tests, maybe delete this because node selection for lines happens afterwards now. Maybe I can add components
 * both ways, in which case this would still be needed?
 */
{
    //let gSelectedElements = [];
    //removeSelected = function(element) {
    //    if (element.classList.contains("selected")) {
    //        element.classList.remove("selected");
    //        const idx = gSelectedElements.findIndex(e => { return e === element; });
    //        if (idx < 0) {
    //            throw new Error("The previously selected element was not found in the selection array and couldn't be removed");
    //        } 
    //        gSelectedElements.splice(idx, 1);
    //    }
    //};
    //addSelected = function(element) {
    //    if (!element.classList.contains("selected")) {
    //        element.classList.add("selected");
    //        gSelectedElements.push(element);
    //    }
    //};
    //emptySelected = function() {
    //    Array.from(document.getElementsByClassName("selected")).forEach(e => {
    //        e.classList.remove("selected");
    //    });
    //    gSelectedElements = [];
    //};
    /**
     * Return true if the selected elements are valid for adding an object with the given type, otherwise return false.
     * 
     * @param {string} type - the type of the object used to modify or be modified by the selection. 
     * @return {boolean}
     */
    validateSelectedForAdd = function(type) {

    };

    /**
     * TODO: add unit tests
     * Return true if the selected elements can be moved, otherwise return false.
     * @return {boolean}
     */
    //validateSelectedForMove = function() {
    //    if (gSelectedElements.length === 0) {
    //        alert("Please select at least one circle to move.");
    //        return false
    //    } 
    //    const lines = gSelectedElements.filter(e => getType(e) === "line");        
    //    if (lines.length !== 0) {
    //        const names = gSelectedElements.map(e => e.name);
    //        alert("Lines cannot be moved. Please unselect the following lines: " + names);
    //        return false
    //    }
    //    return true
    //}
    /**
     * Return an array of HTMLElements that have the "selected" class.
     */
    //getSelectedElements = function() {
    //    return gSelectedElements;
    //};

    /**
     * Return a TreeWrapper that contains tree objects that correspond to HTMLElements with the "selected" class.
     */
    //getSelectedWrapper = function() {
    //    const tWrapper = createTreeWrapper();
    //    gSelectedElements.forEach(e => {
    //        tWrapper.add(e.id, gTreeWrapper);            
    //    });
    //    return tWrapper;
    //};
}

function saveSvg() {
	// Create an SVG that can be saved.
	alert('We are redirecting you to a static version of the SVG that you can save as a .svg file.')
	var svg = document.getElementById('svgContainer').outerHTML
	var win = window.open()
	win.document.write(svg)
}

function downloadTextFile() {
	// WARNING! Performance is very bad because the JSON is enormous! This can hang your browser!
	alert('We are opening a window with JSON in it that you can save as a .json file.')
	var modJson = JSON.stringify(writeFeeder);
	var win = window.open();
	win.document.write(modJson);
}

/**
 * TODO: add unit tests
 */
function createViewport(tree, svgContainer) {
    //const tree = tree.tree;
    const keys = Object.keys(tree);
    // Set the longitude and latitude to be within the bounds of the provided data
    const firstKey = keys.find(key => {
        return tree[key].longitude !== undefined && tree[key].latitude !== undefined;
    });
    let minLon = parseFloat(tree[firstKey].longitude);
    let maxLon = minLon;
    let minLat = parseFloat(tree[firstKey].latitude);
    let maxLat = minLat;
    /* Find the minimum and maximum longitudes and latitudes. That's not good enough. I need to find a RANGE of values
    for each and scale the viewport to the RANGE
    */
    keys.forEach(key => {
        let lon = tree[key].longitude;
        let lat = tree[key].latitude;
        if (lon !== undefined && lat !== undefined) {
            lon = parseFloat(lon);
            lat = parseFloat(lat);
            if (lon < minLon) {
                minLon = lon;
            }
            if (lon > maxLon) {
                maxLon = lon;
            }
            if (lat < minLat) {
                minLat = lat;
            }
            if (lat > maxLat) {
                maxLat = lat;
            }
        }
    });
    const translatedMaxLon = (maxLon - minLon);
    gOffsetX = minLon;
    const translatedMaxLat = maxLat - minLat;
    gOffsetY = minLat;
    // Create the viewport
    svgContainer.setAttribute('viewBox',`0 0 ${translatedMaxLon} ${translatedMaxLat}`);
	window.panZoom = svgPanZoom('#svgContainer', {
        /* Override the default values set by 'optionsDefaults' in svg-pan-zoom.js */
        dblClickZoomEnabled: false,
        zoomScaleSensitivity: 0.2,
        minZoom: 0.25,
		maxZoom: 100
    });
}

//**************************************************
// Click event functions
//**************************************************

/**
 * TODO: add unit tests, this should only handle selection objects. creating tables is a special listener attached to svgContainer,
 * not svgContainerWrapper
 * Listener on the SVG object that handles user clicks.
 */
function handleSelection(event) {
    if (gDownX !== event.clientX || gDownY !== event.clientY) {
		// Ignore drags, those should be handled by svg-panzoom.
        return
    }
    const element = event.target;
    if (event.altKey && element.id !== "svgContainer" && !element.classList.contains("parentChild")) {
        if (gSelection.includes(element)) {
            gSelection.remove(element);
            //Copied from rowPrototype.delete(). Refactor needed
            const table = document.getElementById(`descriptionTable_${element.id}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
        } else {
            gSelection.add(element);
        }
        //destroyTables(["descriptionTables", "selectionTable"]);
        destroyTables(["selectionTable"]);
        //let ids = Object.keys(gSelection.getWrapper().tree);
        let ids = gSelection.getKeys();
        if (ids.length > 0) {
            //const table = createSelectionTable(ids, gTreeWrapper);
            const table = createSelectionTable(ids, gTree);
            document.getElementById("selectionTable").appendChild(table);
        } 
    } else if (!event.altKey) {
        gSelection.empty();
        destroyTables(["descriptionTables", "selectionTable"]);
        //destroyTables(["selectionTable"]);
        if (element.id !== "svgContainer" && !element.classList.contains("parentChild")) {
            gSelection.add(element);
            const table = createDescriptionTable(element.id, gTreeWrapper);
            table.id = `descriptionTable_${element.id}`;
            document.getElementById("descriptionTables").appendChild(table);
        } 
    }
}

//function hotkeys() {
//	// Handle hotkey presses.
//	let x;
//	if (window.event) {
//		// IE8 and earlier
//		x = event.keyCode
//	} else if (event.which) {
//		// IE9/Firefox/Chrome/Opera/Safari
//		x = event.which
//	}
//	var keychar = String.fromCharCode(x);
//	if (event.target.type !== 'text') {
//		// Dispatch the key:
//		if (keychar == '-') {
//			window.panZoom.zoomOut()
//		} else if (keychar == '=') {
//			window.panZoom.zoomIn()
//		} else if (keychar =='m') {
//            attachMoveSelectionListener();
//		}
//	}
//}

function scaleTo(x) {
	// Scale the thickness of all lines and size of all circles. This helps user see details.
	scaleLevel = x
	if (!x) {
		return
	}
	const circles = document.getElementsByTagName('circle')
	const lines = document.getElementsByTagName('line')
	// Scale Circles
	for (let i = 0; i < circles.length; i++) {
		circles[i].setAttribute('r', 2*x)
		circles[i].setAttribute('stroke-width', 0.5*x)
	}
	// Scale Lines
	for (let i = 0; i < lines.length; i++) {
		if (lines[i].getAttribute('class').indexOf('p2') !== -1) {
			lines[i].setAttribute('stroke-width', 2*x)
		}
		else if (lines[i].getAttribute('class').indexOf('p3') !== -1) {
			lines[i].setAttribute('stroke-width', 3*x)
		}
		else if (lines[i].getAttribute('class').indexOf('parentChild') !== -1) {
			lines[i].setAttribute('stroke-width', 0.5*x)
		}
		else {
			lines[i].setAttribute('stroke-width', x)
		}
	}
}

function dropPill(thisButton, name) { // eslint-disable-line
	// This function is used to make the dropdown menus work.
	thisButton.style.color= 'black'
	thisButton.style.background= '#F8F8F8'
	thisButton.style.textAlign = 'left'
	thisButton.nextSibling.nextSibling.style.display = 'inline-block'
	thisButton.innerHTML = name + ' &#x25B4;'
	function clickCloseEvent() {
		thisButton.nextSibling.nextSibling.style.display = 'none'
		thisButton.innerHTML = name + ' &#x25BE;'
		this.removeEventListener('click', arguments.callee, true)
		thisButton.style.color= 'white'
		thisButton.style.background= 'transparent'
		if (window.event.toElement==thisButton) {event.stopPropagation()}
	}
    //document.body.addEventListener('click', clickCloseEvent, true)
    document.getElementById("interfaceContainer").addEventListener('click', clickCloseEvent, true)
}

/*function clickCloseEvent(labelName, buttonName) { // eslint-disable-line
	// This event allows users to close the dropdown menus.
	var thisButton = document.getElementById(buttonName);
	//thisButton.nextSibling.nextSibling.style.display = 'none'
	thisButton.nextElementSibling.style.display = "none";
	thisButton.innerHTML = labelName + ' &#x25BE;';
	//this.removeEventListener('click', arguments.callee, true);
	//if (window.event.toElement==thisButton) {event.stopPropagation()}
}*/

function clickLatLon(event) {
	//Returns real Lat/Long of a click event, used in the moveBus function
	//const sizes = window.panZoom.getSizes();
    //const zoom = sizes.realZoom;
	const pan = window.panZoom.getPan();
    const zoom = panZoom.getSizes().realZoom;
	const svg = document.getElementById('svgContainer');
	let pt = svg.createSVGPoint();
	pt.x = event.clientX;
	pt.y = event.clientY;
	pt = pt.matrixTransform(svg.getScreenCTM().inverse());
	let x = pt.x;
	let y = pt.y;
	//x = (x - pan.x) / zoom;
	//y = (y - pan.y) / zoom;
	//return [x,y];
	const coords = {
		x: (x - pan.x) / zoom,
		y: (y - pan.y) / zoom
	};
	return coords;
}

//**************************************************
// Find modal interface
//**************************************************

/**
 * TODO: add unit tests
 */
function getSearchResults() {
    const tree = gTreeWrapper.tree;
    const keys = getMatchingKeys(this.value, tree);
    document.getElementById("searchCount").textContent = `hits: ${keys.length}`;
    const nextButton = document.getElementById("findNext");
    const previousButton = document.getElementById("findPrevious");
    destroyTables(["descriptionTables"]);
    if (keys.length === 0 || this.value === "") {
        alert(`No results found for term: "${this.value}"`)
        const feedback = function() {
            alert("Please enter a new term to search for"); 
        }
        nextButton.onclick = feedback;
        previousButton.onclick = feedback;
        return;
    }
    const upperIndex = keys.length - 1;
    let idx = 0;
    document.getElementById("descriptionTables").appendChild(createDescriptionTable(tree[keys[idx]], gTreeWrapper));
    viewElement(keys[idx]);
    nextButton.onclick = function() {
        idx++;
        if (idx > upperIndex) {
            idx = 0;
        }
        destroyTables(["descriptionTables"]);
        document.getElementById("descriptionTables").appendChild(createDescriptionTable(tree[keys[idx]], gTreeWrapper));
        viewElement(keys[idx]);
    }
    previousButton.onclick = function() {
        idx--;
        if (idx < 0) {
            idx = upperIndex;
        }
        destroyTables(["descriptionTables"]);
        document.getElementById("descriptionTables").appendChild(createDescriptionTable(tree[keys[idx]], gTreeWrapper));
        viewElement(keys[idx]);
    }
}

/**
 * TODO: add unit tests
 */
function getMatchingKeys(term, tree) {
    const keys = [];
    for (let key in tree) {
        // Only add the key if it represents an object that was drawn
        if ((tree[key].latitude != null && tree[key].longitude != null) ||
        (tree[key].to != null && tree[key].from != null)) {
            for (let propertyKey in tree[key]) {
                let propertyVal = tree[key][propertyKey];
                if (typeof(propertyVal) !== "string") {
                    propertyVal += "";
                }
                if (propertyKey.toLowerCase().includes(term.toLowerCase())) {
                    keys.push(key);
                    break;
                } else if (propertyVal.toLowerCase().includes(term.toLowerCase())) {
                    keys.push(key);
                    break;
                }
            }
        }
    }
    return keys;
}

/** 
 * TODO: add unit tests
 */
function viewElement(key) {
    //emptySelected();
    gSelection.empty();
    const element = document.getElementById(key);
    //addSelected(element);
    gSelection.add(element);
   let x, y;
    if (element.getAttribute("cx") != null && element.getAttribute("cy") != null) {
        x = element.getAttribute("cx");
        y = element.getAttribute("cy");
    } else {
		x = (parseFloat(element.getAttribute('x1')) + parseFloat(element.getAttribute('x2'))) / 2;
		y = (parseFloat(element.getAttribute('y1')) + parseFloat(element.getAttribute('y2'))) / 2;
    }
    // I can't make this work 
    //panZoom.zoomAtPoint(2, {x: x, y: y});
    // Do this instead 
	panZoom.pan({x:0, y:0})
	var realZoom = window.panZoom.getSizes().realZoom
	var width = window.panZoom.getSizes().width / 2
	var height = window.panZoom.getSizes().height / 2
    panZoom.pan({x:width - (x * realZoom), y:height - (y * realZoom)})
    panZoom.zoom(15/scaleLevel);
}

//**************************************************
// jQuery handling for distNetViz.py
//**************************************************

/** 
 * TODO: add unit tests?
 * If this interface is being used as a file, we can't import jQuery with <script> so we can't use jQuery
 * styling. This function is only called when jQuery is available.
 */
 function applyJQueryStyles() {
    // Make stuff draggable
    $("#findModal .modalContent").draggable();
    $("#progressModal .modalContent").draggable();
    $("#loadModal .modalContent").draggable();
    $("#blankFeederModal .modalContent").draggable();
    $("#milsoftModal .modalContent").draggable();
    $("#gridlabdModal .modalContent").draggable();
    $("#cymeModal .modalContent").draggable();
    $("#scadaModal .modalContent").draggable();
    $("#amiModal .modalContent").draggable();
    $("#massAddModal .modalContent").draggable();
    $("#massEditModal .modalContent").draggable();
    $("#attachmentsModal .modalContent").draggable();
    // Position the description table depending on whether or not it is draggable
    //document.getElementById("descriptionTable").removeAttribute("style");
    //document.getElementById("descriptionTable").style.left = "70vw";
}

/** 
 * Ajax requests depend on jQuery, so any function that uses $.ajax() cannot be used if this interface
 * is loaded as a file. This function is called when jQuery isn't available.
 */
function disableJQueryFunctionality() {
    //Hide stuff that doesn't work in distNetViz.py
    Array.from(document.querySelectorAll("[data-web]")).forEach(li => {
        li.remove();
    });
}

//**************************************************
// Header menu functions
//**************************************************

function attachHandlers() {
    attachAddComponentListeners();
    attachFeederList(document.getElementById("publicFeederList"), publicFeeders, "public");
    attachFeederList(document.getElementById("userFeederList"), userFeeders, thisOwner);
    addFileMenuHandlers();
    addEditMenuHandlers();
}

/** 
 * TODO: add unit-tests, add a click listener instead of doing it backwards!
 * Fill menu of "Add" button and add its handler functions.
 */
function attachAddComponentListeners() {
	const ul = document.getElementById("componentList");
    const select = document.getElementById("componentSelect");
	for (const name in gComponents) {
		const li = document.createElement("li");
		li.textContent = name;
        const tObject = createTreeObject(gComponents[name], gTreeWrapper);
		li.addEventListener("click", function() {
            const tWrapper = gSelection.getWrapper();
            if (tWrapper.isValidForAdd(tObject.data)) {

            } else if (keys.length === 0) {

            }

            const keys = Object.keys(tWrapper.tree);
            if (keys.length === 0) {
                //add the proper event listener
            } else if (tWrapper.isValidForAdd(getType(tObject.data))) {

            } else {

            }
            /*
            */


            /* If the selection is valid for an add, then use the selection. If not, (look at notecards)*/

            if (gSelection.isValidForAdd(tObject.data)) {

            }

            //if (updateTreeObject(tObject, tWrapper)) {
            //    const svg = createAddableSvgData(gTreeWrapper.insert(tObject));
            //    svg.drawTo(gViewport);
            //} else {
            //    alert(getSelectionErrorMessage(getType(tObject.data)));
            //}
		});
		ul.appendChild(li);
        select.innerHTML += `<option value=${name}>${name}</option>`;
	}
}

/**
 * TODO: add unit tests
 */
function getSelectionErrorMessage(type) {
    let msg;
    switch (type) {
        case "line":
            msg = "Please select exactly 2 circles to insert this object. These circles must not be configuration objects. "; 
            break;
        case "childNode":
            msg = "Please select exactly 1 circle to act as the parent of this object. This circle must not be a configuration object. ";
            break;
        case "configurationNode":
            msg = "Please?";
            break;
        case "independentNode":
            msg = "what?";
            break;
    }
    msg += "Select an object by holding the 'alt' key and left clicking the object. After selecting the correct objects, " +
    "open the 'add' menu again and click on the object you want to add."
    return msg;
}

/** 
 * TODO: add unit-tests
 * @param {Element} ul - An html element where the list will be attached
 * @param {Array} feeders - An array of objects, where each object has properties "model" and "name", or null. 
 * @param {string} owner - Either "public" or the owner of the current writeFeeder.
 */
function attachFeederList (ul, feeders, owner) {
    if (!feeders) return;
    for (let writeFeeder of feeders) {
        if (writeFeeder.name != thisFeederName) {
            const li = document.createElement("li");
            li.classList.add("feederItem");
            li.innerHTML = `<strong>${writeFeeder.name}</strong> from <br>"${writeFeeder.model}"`;
            li.addEventListener("click", function() {
                //overwriteFeeder(writeFeeder.name, writeFeeder.model, owner);
                loadFeeder(writeFeeder.name, writeFeeder.model, owner);
            });
            ul.append(li);
        }
    }
}

/**
 * TODO: add unit tests
 */
function addFileMenuHandlers() {
    const menu = document.getElementById("fileMenu");
    if (menu == null) {
        return;
    }
    const items = Array.from(menu.children);
    if (items.length !== 8) {
        throw new Error("Please update this function to ensure the correct handlers are attached");
    }
    items[0].addEventListener("click", function() {
        saveFeeder(writeFeeder);
    });
    items[1].addEventListener("click", downloadTextFile);
    items[2].addEventListener("click", renameFeeder);
    items[3].addEventListener("click", function() { toggleElementDisplay("loadModal"); });
    items[4].addEventListener("click", function() { toggleElementDisplay("blankFeederModal"); });
    items[5].addEventListener("click", function() { toggleElementDisplay("milsoftModal"); });
    items[6].addEventListener("click", function() { toggleElementDisplay("gridlabdModal"); });
    items[7].addEventListener("click", function() { toggleElementDisplay("cymeModal"); });
}

/** 
 * TODO: add unit tests
 */
function addEditMenuHandlers() {
    const menu = document.getElementById("editMenu");
    const items = Array.from(menu.children);
    if (items.length != 9) {
        throw new Error("Please update this function to ensure the correct handlers are attached");
    }
    //items[0].addEventListener("click", zoomToFit);
    //items[1].addEventListener("click", zoomReset);
    items[0].addEventListener("click", staticLoadsToHouses);
    items[1].addEventListener("click", function() { toggleElementDisplay("scadaModal"); });
    items[2].addEventListener("click", function() { toggleElementDisplay("amiModal"); });
    items[3].addEventListener("click", function() { toggleElementDisplay("findModal"); });
    items[4].addEventListener("click", function() {
        updateAttachTargets("massAddTargetSelect", gTreeWrapper.tree);
        toggleElementDisplay("massAddModal");
    });
    items[5].addEventListener("click", function() {
        updateAttachTargets("massEditTargetSelect", gTreeWrapper.tree);
        toggleElementDisplay("massEditModal");
    });
    items[6].addEventListener("click", function() {
        loadAttachments(); 
        toggleElementDisplay("attachmentsModal");
    });
    items[7].addEventListener("click", function() { toggleElementDisplay("climateModal"); });
    items[8].addEventListener("click", function() { toggleElementDisplay("anonymizeModal"); });
}

/** 
 * TODO: add unit tests
 * If an element isn't displayed, set it's inline display value to the default browser value.
 * If the element is displayed, then hide it.
 */
function toggleElementDisplay(id) {
    const element = document.getElementById(id);
    if (element.style.display === "none") {
        element.removeAttribute("style");
    } else {
        element.style.display = "none";
        if (id === "findModal") {
            return;
        }
        // When we hide a modal, set any of the text fields to empty
        const queryString = `#${id} input[type=text]`;
        document.querySelectorAll(queryString).forEach(input => {
            input.value = "";
        });
    }
}

//**************************************************
// Edit menu interface
//**************************************************

/**
 * Set the viewport to its initial state and center it
 */
//function zoomReset() {
//    panZoom.fit();
//    panZoom.center();
//}

/**
 * Set the viewport value to its initial state.
 */
//function zoomToFit() {
//    panZoom.fit();
//}

function randomGaussian() {
  // Get a Gaussian from a uniform(0,1) via the Box-Muller transform.
  let rad;
  let x1;
  let x2;
  let c;
  do {
	x1 = 2 * Math.random() - 1
	x2 = 2 * Math.random() - 1
	rad = x1 * x1 + x2 * x2
  } while (rad >= 1 || rad == 0) {
    c = Math.sqrt(-2 * Math.log(rad) / rad);
  }
  return x1 * c
}

function randomInt(min,max) {
	return Math.floor(Math.random()*(max - min + 1) + min)
}

function randomChoice(inList) {
	return inList[Math.floor(Math.random() * inList.length)]
}


// TODO: for secondary system has 'load', replace it with triplex_meter and triplex_node
// TODO: rename this function?
function staticLoadsToHouses() {
    const tree = gTreeWrapper.tree;
    const names = gTreeWrapper.names;
	//if (!containsTriplexNodes(tree)) {
	if (!containsTriplexNodeOrLoad(tree)) {
        alert("There are no triplex nodes or triplex loads in this model.");
        return;
	} else {
        let modal = new ProgressModal("Please wait. Houses are being generated.", "", false);
        modal.show();
        // Replace 100 nodes at a time (maximum), to prevent the browser from hanging
        const keys = Object.keys(tree);
        let start = 0;
        let end = 100;
        const intervalId = setInterval(function() {
            //console.log("start: " + start);
            //console.log("end: " + end);
            replaceAllHouses(start, end, keys);
            if (end >= keys.length) {
                clearInterval(intervalId);
                modal.hide();
            } else {
                start = end + 1;
                end += 100;
            }
        }, 10);
    }

    /* Triplex loads should have a "parent" property. Triplex nodes should NOT have a "parent" property usually.
    Therefore, if the parent property DOES exist on either a node/load I should use it. However, it it DOESN'T exist,
    then I should carry on as normal too.
    */
    function containsTriplexNodeOrLoad(tree) {
        for (let key in tree) {
            if (tree[key].object === "triplex_node" || tree[key].object === "triplex_load") {
                return true;
            } 
        }   
        return false;
    }

	function replaceAllHouses(start, end, keys) {
        if (end >= keys.length) {
            end = keys.length - 1;
        }
        for (let i = start; i <= end; i++) {
            if (tree[keys[i]].object === "triplex_node" || tree[keys[i]].object === "triplex_load") {
                let parentKey = names[tree[keys[i]].parent];
                if (parentKey == null) {
                    //There is no parent. No big deal

                } else {
                    //There is a parent. Use the parent to place the new house

                }
            }
            /*
            TODO: delete this
            if (tree[keys[i]].hasOwnProperty('parent') && tree[keys[i]].object === "triplex_node") {
                // Get the key of the parent of this triplex node, which is a triplex meter (i.e. another node)
                let parentKey = names[tree[keys[i]].parent];
                // Delete the triplex_node itself
                deleteObject(keys[i]);
                // Create a new house object to replace the triplex node
                let houseObj = randomHouse();
                let lightsObj = randomLights();
                let heaterObj = randomWaterHeater();
                newChildAtLocation(houseObj.house, parentKey);
                newChildAtLocation(lightsObj.lights, houseObj.key);
                if (heaterObj != false) {
                    newChildAtLocation(heaterObj.heater, houseObj.key);
                }
            }
            */
        }
    }

	function randomHouse() {
		const newHouse = {}
		newHouse['object'] = 'house'
		newHouse['air_temperature'] = '70'
		newHouse['cooling_COP'] = randomInt(25, 40) / 10.0 + ''
		newHouse['cooling_setpoint'] = 'cooling' + randomInt(1, 8) + '*1'
		newHouse['cooling_system_type'] = randomChoice(['ELECTRIC', 'HEAT_PUMP', 'NONE'])
		// House sizing distribution from http://www.census.gov/housing/ahs/
		// between 1100 and 3000. Probably needs a normal distribution.
		let area = 1800 + 500 * randomGaussian()
		if (area < 500) {
			area = 500
		}
		area = area.toPrecision(2) * 1.0 + ''
		newHouse['floor_area'] = area
		newHouse['heating_COP'] = randomInt(20, 35) / 10.0 + ''
		newHouse['heating_setpoint'] = 'heating' + randomInt(1, 8) + '*1'
		newHouse['heating_system_type'] = randomChoice(['RESISTANCE', 'HEAT_PUMP', 'GAS'])
		newHouse['mass_temperature'] = '70'
		let skew = 1200 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHouse['schedule_skew'] = skew
		newHouse['thermal_integrity_level'] = randomChoice([1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6]) + ''
		const newKey = getNewTreeKey(gTreeWrapper.tree);
		newHouse['name'] = 'synhouse' + newKey
		return {
            house: newHouse,
            key: newKey
        }
	}

	function randomLights() {
		const newLights = {}
		newLights['object'] = 'ZIPload'
		newLights['power_fraction'] = '0.400000'
		newLights['current_fraction'] = '0.300000'
		newLights['impedance_pf'] = '1.000'
		newLights['current_pf'] = '1.000'
		newLights['power_pf'] = '1.000'
		newLights['impedance_fraction'] = '0.300000'
		newLights['heatgain_fraction'] = '0.9'
		let power = 1.2 + randomGaussian()
		if (power < 0) {
			power = -1 * power
		}
		power = power.toPrecision(3) * 1.0 + ''
		newLights['base_power'] = 'LIGHTS*' + 1.33
		let skew = 2000 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newLights['schedule_skew'] = skew
		const newKey = getNewTreeKey(gTreeWrapper.tree);
		newLights['name'] = 'synLights' + newKey
		return {
            lights: newLights,
            key: newKey
        }
	}

	function randomWaterHeater() {
		const newHeater = {}
		if (randomChoice([1, 2, 3]) == 3) {
			return false
		}
		// Static properties.
		newHeater['object'] = 'waterheater'
		newHeater['temperature'] = '135'
		newHeater['tank_volume'] = '50'
		newHeater['location'] = 'INSIDE'
		// Uniformly distributed properties.
		newHeater['heating_element_capacity'] = randomInt(37, 53) / 10.0 + ''
		newHeater['thermostat_deadband'] = randomInt(20, 60) / 10.0 + ''
		newHeater['demand'] = 'water' + randomInt(1, 20) + '*1'
		newHeater['tank_UA'] = randomInt(20, 40) / 10.0 + ''
		// Gaussian properties.
		let skew = 2000 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHeater['schedule_skew'] = skew
		newHeater['tank_setpoint'] = (randomGaussian() * 2 + 130).toPrecision(3) + ''
		// between 1100 and 3000. Probably needs a normal distribution.
		const newKey = getNewTreeKey(gTreeWrapper.tree);
		newHeater['name'] = 'synwaterheater' + newKey;
		return {
            heater: newHeater,
            key: newKey
        }
	}
}

/** 
 * TODO: add better validation for percent to ensure 1) it's a float and 2) it's in a valid range. Do this on the input if possible
 * General Function to Add Components 'inverter', 'triplex_meter', PERC
 * Did this function get chopped in half?
 */
function attachFeederList(ul, feeders, owner) {
    if (feeders === null || feeders === undefined) {
        return
    } 
    for (let writeFeeder of feeders) {
        if (writeFeeder.name !== thisFeederName) {
            const li = document.createElement("li");
            li.classList.add("feederItem");
            li.innerHTML = `<strong>${writeFeeder.name}</strong> from <br>"${writeFeeder.model}"`;
            li.addEventListener("click", function() {
                //overwriteFeeder(writeFeeder.name, writeFeeder.model, owner);
                loadFeeder(writeFeeder.name, writeFeeder.model, owner);
            });
            ul.append(li);
        }
    }
}

function massAdd() {
    let tree = gTreeWrapper.tree;
	const componentName = document.getElementById('componentSelect').value;
	const attachType = document.getElementById('massAddTargetSelect').value;
    const percent = document.getElementById('percent').value;
    if (isNaN(percent) || percent === "") {
        alert("Please enter a valid number for attachment probability");
        return
    }
	let objectsAdded = 0;
    let modal = new ProgressModal(`Please wait. We are adding ${componentName} objects to all ${attachType} objects.`, "", false);
    modal.show();
    // Add 100 nodes at a time (maximum), to prevent the browser from hanging
    const keys = Object.keys(tree);
    let start = 0;
    let end = 100;
    const intervalId = setInterval(function() {
        console.log("start: " + start);
        console.log("end: " + end);
        massAddComponent(start, end, keys);
        if (end >= keys.length) {
            clearInterval(intervalId);
            modal.hide();
            alert(`${objectsAdded} ${componentName} objects added to the feeder`);
        } else {
            start = end + 1;
            end += 100;
        }
    }, 100);

    function massAddComponent(start, end, keys) {
        if (end >= keys.length) {
            end = keys.length - 1;
        }
        for (let i = start; i <= end; i++) {
            if (tree[keys[i]].object === attachType) {
				if (Math.random() < percent) {
					const newComponent = deepCopy(gComponents[componentName]);
					newChildAtLocation(newComponent, keys[i]);
					objectsAdded += 1
				}
            }
        }
    }
}

function updateAttachTargets(id, tree) {
	/* Clearing each list so we dont get duplicates in the list. This must be done because the attachTarget list must be 
    refreshed, since the user could have added a new object type to the data which they now want to attach to.
    */
    document.getElementById(id).innerHTML = "";
	let attachList = [];
	for (let key in tree) {
        /* Only list an object type as a valid attachTarget if 1) its object property matches a known component and 2)
        the object type already exists in the graph. "1" is to prevent things like weird configuration nodes from 
        being presented to the user, since the user could not attach anything to those weird objects. "2" is to ensure
        that the user must attach to things that already exist in a particular model.
        */
        if (gComponents.hasOwnProperty(tree[key].object)) {
			if (!attachList.includes(tree[key].object)) {
                attachList.push(tree[key].object);
                document.getElementById(id).innerHTML += `<option value=${tree[key].object}>${tree[key].object}</option>`;
            }
        }
    }
}

function massEdit() {
    const tree = gTreeWrapper.tree;
    const objectType = document.getElementById("massEditTargetSelect").value;
    const keys = [];
    for (let key in tree){
		if (tree[key].object === objectType) {
            keys.push(key);
        }
    }
    let operation = document.querySelector("input[name=attributeOperation]:checked");
    if (operation == null) {
        alert("Please select an operation with radio buttons on the 'Mass Edit' menu.");
        return;
    }
    operation = operation.value;
    if (operation === "addAttribute") {
        massEditAdd(keys);
        return;
    }
    const attributeKey = document.getElementById("massEditAttribute").value;
    for (let key of keys) {
        if (tree[key][attributeKey] === undefined) {
            alert(`Invalid operation. One or more of the objects you selected does not have the attribute you are trying to edit.
            Attribute "${attributeKey}" is missing from tree object with key "${key}".`);
            return;
        }
    }
    switch (operation) {
        case "addTo":
            const operand = parseFloat(document.getElementById("addToValue").value);
            if (isNaN(operand)) {
                alert("Invalid operation. Please enter a valid number if you choose 'Add to Value'.");
                return;
            } else {
                for (let key of keys) {
                    const value = parseFloat(tree[key][attributeKey]);
                    if (isNaN(value)) {
                        alert("Invalid operation. The attribute you are trying to add to is not a number.");
                        return;
                    }
                    tree[key][attributeKey] = (value + operand).toString();
                }
            }
            break;
        case "change":
            const newValue = document.getElementById("changeValue").value;
            for (let key of keys) {
                tree[key][attributeKey] = newValue;
            }
            break;
        case "delete":
            for (let key of keys) {
                delete tree[key][attributeKey];
            }
            break;
        case "multiplyBy":
            const multiplyOperand = parseFloat(document.getElementById("multiplyValue").value);
            const rawAddOperand = document.getElementById("andAddValue").value;
            let addOperand;
            if (rawAddOperand === "") {
                addOperand = 0;
            } else {
                addOperand = parseFloat(rawAddOperand);
            }
            if (isNaN(multiplyOperand) || isNaN(addOperand)) {
                alert("Invalid operation. Please enter valid numbers if you choose 'Multiply attribute by'.");
            }
            for (let key of keys) {
                const value = parseFloat(tree[key][attributeKey]);
                if (isNaN(value)) {
                    alert("Invalid operation. The attribute you are trying to multiply by is not a number.");
                    return;
                }
                tree[key][attributeKey] = ((value * multiplyOperand) + addOperand).toString();
            }
            break;
    }
    alert(`${keys.length} ${objectType} objects edited.`);
}

function massEditAdd(keys) {
    const tree = gTreeWrapper.tree;
    const newKey = document.getElementById("newAttributeKey").value;
    const newValue = document.getElementById("newAttributeValue").value;
    for (let key of keys) {
        tree[key][newKey] = newValue;
    }
    const objectType = document.getElementById("massEditTargetSelect").value;
    alert(`${keys.length} ${objectType} objects edited.`);
}

function loadAttachments() {
    const selectElement = document.getElementById("attachmentSelect");
    selectElement.innerHTML = "";
	for (let key in writeFeeder.attachments) {
        selectElement.innerHTML += `<option value=${key}>${key}</option>`;
    }
}

function editAttachment() {
	//document.body.style.cursor = 'wait'
	//setTimeout(function(){
		toggleElementDisplay('editAttachmentModal');
		let name =  document.getElementById('attachmentSelect').value; //get the select. attachmentsList = attachmentSelect
		document.getElementById('attachmentTd').innerHTML = name;  //get the td. attachmentSelect = attachmentTd
		document.getElementById('editAttachmentBox').innerHTML = writeFeeder.attachments[name];
		//document.body.style.cursor = 'auto'
	//}, 100);
}

function saveAttachment() {
	let name = document.getElementById('attachmentSelect').value;
	writeFeeder.attachments[name] = document.getElementById('editAttachmentBox').value;
}

//ADD PROMPT TO SAVE CHANGES BEFORE EXIT
/*
{% if is_admin or not public %}
	window.onbeforeunload = function(e) {
		let confirmationMessage = 'It looks like you have been editing something. ';
		confirmationMessage += 'If you leave before saving, your changes will be lost.';
		//if (unsavedChanges) return confirmationMessage;
	};
{% endif %}
*/

//**************************************************
// File menu interface
//**************************************************
{% if showFileMenu %}

/** 
 * Used to save the new changes or undo an operation by resaving the old changes.
 */ 
function saveFeeder(feeder) {
    const formData = new FormData();
    formData.set("feederObjectJson", JSON.stringify(feeder));
    const postRequest = $.ajax({
        type: "POST",
        url: `/saveFeeder/${thisOwner}/${thisModelName}/${thisFeederName}`,
        data: formData,
        processData: false,
        contentType: false,
    });
    let cancelled = false;
    let progressModal;
    if (feeder === readFeeder) {
        progressModal = new ProgressModal("Cancelling the previous operation...", "", false);
        postRequest.done(function() {
            progressModal.hide();
            alert("Success. Previous operation was canceled");
        });
    } else if (feeder === writeFeeder) {
        progressModal = new ProgressModal("Saving changes to your file...", "You have canceled the save.", true);
        progressModal.button.addEventListener("click", function() {
            cancelled = true;
            progressModal.header.textContent = progressModal.cancelMessage;
            progressModal.button.style.display = "none";
        });
        postRequest.done(function() {
            if (cancelled) {
                saveFeeder(readFeeder);
            } else {
                progressModal.hide();
                alert("Success. Your data was saved.");
            }
        });
    }
    progressModal.show();
}

async function loadFeeder(serverFeederName, serverModelName, owner) {
    let submitForm = false;
    await $.ajax({
        url: `/uniqObjName/Feeder/${thisOwner}/${serverFeederName}/${serverModelName}`
    }).done(function(data) {
        if (data.exists) {
            submitForm = true;
        } else {
            alert('This feeder no longer exists. Please refresh the page, or select another feeder.');
        }
    });
    if (submitForm === false) {
        return;
    }
    let formData = new FormData();
    formData.set("referrer", "distribution");
    const progressModal = new ProgressModal("Loading feeder from server...", "You have canceled loading the feeder.", true);
    let cancelled = false;
    progressModal.button.addEventListener("click", function() {
        cancelled = true;
        progressModal.header.textContent = progressModal.cancelMessage;
        progressModal.button.style.display = "none";
    });
    progressModal.show();
    $.ajax({
        type: "POST",
        url: `/loadFeeder/${serverFeederName}/${serverModelName}/${thisModelName}/${thisFeederNum}/${owner}/${thisOwner}`,
        data: formData,
        processData: false,
        contentType: false,
    }).done(function() {
        if (cancelled) {
            saveFeeder(readFeeder);
        } else {
            reloadWrapper();
        }
    });
}

/** 
 * TODO: add back ability to cancel these operations
 */
async function submitForm({formId, pollUrl, inputId}) {
    let submitForm = true;
    if (inputId !== undefined) {
        // inputId was defined, therefore we need to check the file name on the server before submitting the form
        submitForm = false;
        const fileName = document.getElementById(inputId).value;
        // Check if the file exists, using the user-provided fileName
        await $.ajax({
            url: `/uniqObjName/Feeder/${thisOwner}/${fileName}/${thisModelName}`
        }).done(function(data) {
            console.log(data);
            if (data.exists === true) {
                alert(`You already have a feeder named "${fileName}". Please choose a different name.`);
            } else {
                // The file does not exist. Submit the form.
                submitForm = true;
            }
        });
    }
    if (submitForm === false) {
        return;
    }
    const form = document.getElementById(formId);
    const formData = new FormData(form);
    const submitModal = new ProgressModal("Submitting your file...", "", false);
    submitModal.show();
    // Submit the form to the server with an ajax request
    const formRequest = $.ajax({
        type: "POST",
        url: form.action,
        data: formData,
        processData: false,
        contentType: false,
    });
    if (pollUrl === undefined) {
        // We don't want to poll the server. Just reload the page.
        formRequest.done(function() {
            reloadWrapper();
        });
    } else {
        formRequest.done(function(data) {
            let cancelled = false;
            const pollModal = new ProgressModal("Converting your file...", "You canceled the file conversion.", true);
            pollModal.button.addEventListener("click", function() {
                cancelled = true;
                pollModal.header.textContent = pollModal.cancelMessage;
                pollModal.button.style.display = "none";
            });
            pollModal.show();
            // Poll the server
            const intervalId = setInterval(function() {
                $.ajax({
                    //url: `/checkConversion/${thisModelName}/${thisOwner}`
                    url: pollUrl
                }).done(function(data) {
                    if (cancelled) {
                        clearInterval(intervalId);
                        pollModal.hide();
                        alert("You cancelled the operation");
                        saveFeeder(readFeeder);
                    }
                    if (data.exists === true) {
                        //processing is ongoing 
                    } else if (data.exists === false) {
                        // The pollModal isn't hidden before the alert happens. This has nothing to do with the reload wrapper.
                        clearInterval(intervalId);
                        pollModal.hide();
                        alert("Conversion complete");
                        reloadWrapper();
                    } else if (data === "milError") {
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('The .std and .seq files used are incorrectly formatted.');
                        //TODO: submit the readFeeder
                    } else if (data === "glmError") {
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('The .glm file used is incorrectly formatted.');
                        //TODO: submit the readFeeder
                    } else {
                        console.log(data);
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('There was a problem. Operation was cancelled');
                    }
                });
            }, 5000);
        });
    }
}

async function renameFeeder() {
	if (JSON.stringify(readFeeder) !== JSON.stringify(writeFeeder)){
		alert('You have unsaved changes. Please save the feeder before proceeding.')
	} else {
		let newName = prompt("Rename the feeder to", `${thisFeederName}`);
		while (! /^[\w\s]+$/.test(newName) || /^\s+$/.test(newName)) {
			newName = prompt("Only letters, digits and underscore are allowed.\nPlease enter a different name", `${thisFeederName}`);
		}
		if (newName){
            let submitRequest = false;
            await $.ajax({
                url: `/uniqObjName/Feeder/${thisOwner}/${newName}/${thisModelName}`
            }).done(function(data) {
                if (data.exists) {
                    alert(`You already have a feeder named "${newName}". Please choose a different name.`);
                } else {
                    submitRequest = true;
                }
            });
            if (submitRequest === false) {
                return;
            }
            $.ajax({
                url: `/renameFeeder/${thisOwner}/${thisModelName}/${thisFeederName}/${newName}/${thisFeederNum}`
            }).done(function() {
                thisFeederName = newName;
                alert("Feeder file was successfully renamed.");
            })
		}
	} 
}
{% endif %}

/** This is done for testing reasons.
 */
function reloadWrapper() {
    /* Force the client to always request new files from the server without using the browser cache. 
    */
    window.location.reload(true);
}

function ProgressModal(message, cancelMessage, showButton) {
    this.self = document.getElementById("progressModal");
    this.button = this.self.getElementsByTagName("button")[0];
    this.header = this.self.getElementsByTagName("h2")[0];
    this.message = message;
    this.cancelMessage = cancelMessage;
    this.showButton = showButton;
}

ProgressModal.prototype.show = function() {
    this.header.textContent = this.message;
    this.self.removeAttribute("style");
    if (this.showButton) {
        this.button.removeAttribute("style");
    } else {
        this.button.style.display = "none";
    }
}

ProgressModal.prototype.hide = function() {
    this.self.style.display = "none";
}
//**************************************************
// TreeMap interface
//**************************************************

const treeMapPrototype = {

    /* Public methods */

    /**
     * TODO: add unit tests
     */
    getKey(name) {
        const key = this.names[name];
        if (key === undefined) {
            throw new Exception(`Did not find the name "${name}" in this.names.`);
        }
        return key 
    },

    /**
     * TODO: add unit tests
     */
    getChildKeys(key) {
        return this.children[key];
    },

    /**
     * TODO: add unit tests
     */
    getLineKeys(key) {
        return this.lines[key];
    },

    /**
     * TODO: add unit tests
     */ 
    add(key) {
        this.mapName(key);
        this.mapChild(key);
        this.mapLine(key);
    },

    remove(key) {

    },

    /* Private methods. */

    mapChild(key) {
        const parentName = this.tree[key].parent;
        if (parentName === undefined) {
            return;
        }
        let parentKey;
        try {
            parentKey = this.getKey(parentName);
        } catch (e) {
            console.error(`The child object named "${this.tree[key].name}" has a non-existant parent object named "${parentName}". The parent-child line was not drawn.`);
            return;
        }
        if (this.children[parentKey] == null) {
            this.children[parentKey] = [key];
        } else if (!this.children[parentKey].includes(key)) {
            this.children[parentKey].push(key);
        } 
    },

    mapName(key) {
        const name = this.tree[key].name;
        if (name != null) {
            const stringName = String(name).toLowerCase();
            if (stringName === "null" || stringName === "undefined") {
                return;
            } 
            this.names[name] = key;
        } 
    },

    mapLine(key) {
        const sourceName = this.tree[key].to;
        const targetName = this.tree[key].from;
        if (sourceName === undefined && targetName === undefined) {
            return;
        }
        if (sourceName !== undefined && targetName !== undefined) {
            let sourceKey, targetKey;
            try {
                sourceKey = this.getKey(sourceName);
                targetKey = this.getKey(targetName);
            } catch(e) {
                console.error(`The line object named "${this.tree[key].name}" has non-existant 'to' and/or 'from' nodes. Line was not drawn.`);
            }
            if (this.lines[sourceKey] == null) {
                this.lines[sourceKey] = [key];
            } else if (!this.lines[sourceKey].includes(key)) {
                this.lines[sourceKey].push(key);
            }
            if (this.lines[targetKey] == null) {
                this.lines[targetKey] = [key];
            } else if (!this.lines[targetKey].includes(key)) {
                this.lines[targetKey].push(key);
            }
            return;
        }
        console.error(`The line object named "${this.tree[key].name}" is missing a 'to' or 'from' property. Line was not drawn.`);
    }
};

/**
 * good
 */
function createTreeMap(tree) {
    const map = Object.create(treeMapPrototype);
    map.tree = tree;
    map.names = {};
    map.children = {};
    map.lines = {};
    const keys = Object.keys(tree);
    keys.forEach(key => {
        map.mapName(key);
    });
    keys.forEach(key => {
        map.mapChild(key);
        map.mapLine(key);
    });
    return map;
}

//**************************************************
// Tree interface
//**************************************************
/**
 * How to write a console.error message:
 * 1) State what failed (console.error trace does this already)
 * 2) State why there was a failure in a USER FRIENDLY way
 * 3) State action taken (or NOT taken), if any.
 */

const treePrototype = {

    /* Public methods 
    TODO: delete unused methods
    */

    /**
     * TODO: add unit tests
     */
    getObject(key) {
        const obj = this.tree[key];
        if (obj == null) {
            console.error(`The object with the key "${key}" does not exist in the Tree.`);
        } else {
            return this.tree[key];
        }
    },

    /**
     * TODO: add unit tests
     */
    getParentKey(nodeKey) {
        return this.treeMap.getKey(this.tree[nodeKey].parent);
    },

    /**
     * TODO: add unit tests
     */
    getParent(nodeKey) {
        return this.getObject(this.getParentKey(nodeKey));
    },

    /**
     * TODO: add unit tests
     */
    getToNodeKey(lineKey) {
        return this.treeMap.getKey(this.tree[lineKey].to);
    },

    /**
     * TODO: add unit tests
     */
    getToNode(lineKey) {
        return this.getObject(this.getToNodeKey(lineKey));
    },

    /**
     * TODO: add unit tests
     */
    getFromNodeKey(lineKey) {
        return this.treeMap.getKey(this.tree[lineKey].from);
    },

    /**
     * TODO: add unit test
     */
    getFromNode(lineKey) {
        return this.getObject(this.getFromNodeKey(lineKey));
    },

    /**
     * TODO: add unit tests
     */
    getPairedNodeKeys(nodeKey) {
        const pairedNodes = [];
        const lineKeys = this.treeMap.getLineKeys(key);
        lineKeys.forEach(key => {
            if (this.getToNodeKey(key) === nodeKey) {
                pairedNodes.push(this.getFromNodeKey(key));
            } else {
                pairedNodes.push(this.getToNodeKey(key));
            }
        });
        return pairedNodes;
    },

    /**
     * TODO: do some sort of pre-scan to find an empty square in the graph to insert the configuration objects.
     * Parse this TreeWrapper.tree and insert longitude and latitude properties if a non-line type object does not contain them.
     * @param {number} initX - the longitude of the top left corner of the square.
     * @param {number} initY - the latitude of the top left corner of the square.
     * @param {number} spacing - how far apart the nodes should be spaced from one another
     */
     insertCoordinates(initX, initY, spacing) {
        let keys = Object.keys(this.tree);
        let gen = getCoordinates(initX, initY, spacing);
        keys.forEach(key => {
            let obj = this.tree[key];
            if (getType(obj) !== "line" && (obj.longitude == null || obj.latitude == null)) {
                let coords = gen.next().value;
                obj.longitude = coords.longitude;
                obj.latitude = coords.latitude;
            }
        });
    },

    /**
     * TODO: add unit tests
     */
    insert(treeObject) {
        this.tree[treeObject.key] = treeObject.data;
        this.treeMap.add(treeObject.key);
        if (treeObject.data.name == null) {
            console.log(`You inserted an object with key "${treeObject.key}". However, this object does not a "name" property.`);
        }
    },

    /** 
     * TODO: add unit tests
     * Delete the tree object with the passed key argument from this Tree.
     * @param {string} key - the key used to identify the tree object to delete.
     */
    delete(key) {
        /* See if this object has any children or connected lines. If it has children, throw an error. If it has connected lines, throw an error. If it doesn't have either, delete it from names. Next, check if IT is a child and delete it from its parent's children array. Next, check if IT is a line and delete it from its node(s) arrays(s). */
        const parentKey = this.getParentKey(key);
        if (parentKey != null) {
            const children = this.treeMap.getChildKeys(parentKey);
            const idx = children.indexOf(key)
            if (idx >= 0) {
                children.splice(idx, 1);
            } else {
                throw new Error(`Child node with key "${key}" was not mapped as a child of parent with key "${parentKey}".`)
            }
        }
        const 

        //const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            console.log(`Unable to perform delete operation. This TreeWrapper does not contain a tree object with key: "${key}".`);
            return tWrapper;
        }
        const childKeys = Object.keys(this.getChildrenOf(key).tree);
        if (childKeys.length > 0) {
            throw new Error(`Cannot delete object with key "${key}" because it has existing children. Please delete the children first.`);
            return tWrapper;
        }
        const lineKeys = Object.keys(this.getConnectedLinesOf(key).tree);
        if (lineKeys.length > 0) {
            throw new Error(`Cannot delete object with key "${key}" because it has connected lines. Please delete the connected lines first.`);
            return tWrapper;
        }
        tWrapper.add(key, this);
        delete this.names[this.tree[key].name];
        delete this.tree[key];
        return tWrapper;
    },

    /** 
     * Delete the tree object with the passed key argument from this TreeWrapper. Also recursively delete any connected
     * lines and children. 
     * @param {string} key - the key of the tree object which should be deleted, along with any associated tree objects.
     * @return {TreeWrapper} - contains all of the tree objects that need to be removed from the svg
     * as a result of the recursive delete operation.
     */
    recursiveDelete(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to perform a recursive delete operation. The tree object with key "${key}" does not exist
            //in this TreeWrapper`);
            return tWrapper;
        }
        tWrapper.add(key, this);
        tWrapper.merge(this.getSubtreeToDelete(key, []));
        for (let key in tWrapper.tree) {
            delete this.names[this.tree[key].name];
            delete this.tree[key];
        }
        return tWrapper;
    },

    /* Private methods */

};

function createTree(tree) {
    Object.keys(tree).forEach(key => {
        if (!isNumberString(key)) {
            throw new Error(`The key "${key}" in the 'tree' argument cannot be parsed to a valid number.`);
        }
    });
    const treeWrapper = Object.create(treePrototype);
    treeWrapper.tree = tree;
    treeWrapper.treeMap = createTreeMap(tree);
    return treeWrapper;
}

/**
 * TODO: this should go at the top of the file
 */
//**************************************************
// TreeWrapper interface
//**************************************************

const treeWrapperPrototype = {

    /* Public TreeWrapper methods */

    /** 
     * Return a TreeWrapper that represents which tree objects need to be redrawn as a result of inserting 
     * this TreeObject.
     * 
     * If the TreeObject.key does not exist in this TreeWrapper, the new TreeObject.key and new TreeObject.data are added to the
     * TreeWrapper. If the TreeObject.key does exist in this TreeWrapper, the data at the existing key is overwritten. This is a
     * public method, which means it should be used in event handlers and other places to do stuff. While this method will work
     * for ANY TreeWrapper, it is intended to be used with the "gTreeWrapper" only. The gTreeWrapper encapsulates all the data of
     * the model, which is what we want to work with.
     * @param {TreeObject} treeObject - contains a key and some data that will be used to add or overwite
     * data inside of this TreeWrapper.
     * @return {TreeWrapper} - contains all of the tree objects that need to be redrawn as a result of modifying the data.
     */
     insert(treeObject) {
        this.tree[treeObject.key] = treeObject.data;
        const name = treeObject.data.name;
        if (name != null) {
            this.names[name] = treeObject.key;
        } else {
            //console.log(`Inserted TreeObject with key "${treeObject.key}" did not have a "name" property.`);
        }
        /*
        const s = new Set();
        s.add(treeObject.key);
        this.getSubtreeToRedraw(treeObject.key).forEach(key => {
            s.add(key);
        });
        return new Tree(this.tree, s);

        const t = new Tree(this.tree, this.getSubtreeToRedraw(tObject.key));
        */
        /*
        const tWrapper = createTreeWrapper();
        tWrapper.add(treeObject.key, this);
        tWrapper.merge(this.getSubtreeToRedraw(treeObject.key));
        return tWrapper;
        */
    },

    /** 
     * Delete the tree object with the passed key argument from this TreeWrapper.
     * @param {string} key - the key used to identify the tree object to delete.
     * @return {TreeWrapper} tWrapper - contains 1 tree object that was affected by the delete operation.
     */
    delete(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            console.log(`Unable to perform delete operation. This TreeWrapper does not contain a tree object with key: "${key}".`);
            return tWrapper;
        }
        const childKeys = Object.keys(this.getChildrenOf(key).tree);
        if (childKeys.length > 0) {
            throw new Error(`Cannot delete object with key "${key}" because it has existing children. Please delete the children first.`);
            return tWrapper;
        }
        const lineKeys = Object.keys(this.getConnectedLinesOf(key).tree);
        if (lineKeys.length > 0) {
            throw new Error(`Cannot delete object with key "${key}" because it has connected lines. Please delete the connected lines first.`);
            return tWrapper;
        }
        tWrapper.add(key, this);
        delete this.names[this.tree[key].name];
        delete this.tree[key];
        return tWrapper;
    },

    /** 
     * Delete the tree object with the passed key argument from this TreeWrapper. Also recursively delete any connected
     * lines and children. 
     * @param {string} key - the key of the tree object which should be deleted, along with any associated tree objects.
     * @return {TreeWrapper} - contains all of the tree objects that need to be removed from the svg
     * as a result of the recursive delete operation.
     */
    recursiveDelete(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to perform a recursive delete operation. The tree object with key "${key}" does not exist
            //in this TreeWrapper`);
            return tWrapper;
        }
        tWrapper.add(key, this);
        tWrapper.merge(this.getSubtreeToDelete(key, []));
        for (let key in tWrapper.tree) {
            delete this.names[this.tree[key].name];
            delete this.tree[key];
        }
        return tWrapper;
    },

    /**
     * Translate the 'longitude' and 'latitude' properties of all nodes in this TreeWrapper according
     * to the arguments.
     * 
     * These x, y coordinate arguments are relative to the viewport, which means they have a minimum
     * value of 0 and that the gOffsetX and gOffsetY must be added to them before they are real 
     * coordinates to be stored in the tree.
     * @param {number} x - an x coordinate relative to the viewport, usually created with a click on the screen.
     * @param {number} y - a y coordinate relative to the viewport, usually created with a click on the screen.
     * @param {number} offsetX - corresponds to gOffsetX, which is how much the gTreeWrapper is translated on 
     * the x-axis to fit in the created viewport.
     * @param {number} offsetY - corresponds to gOffsetY, which is how much the gTreeWrapper is translated on 
     * the y-axis to fit in the created viewport.
     */
    move({x, y}, {offsetX, offsetY}) {
        const allKeys = Object.keys(this.tree);
        const nodeKeys = [];
        let avgLon = 0;
        let avgLat = 0;
        for (let i = 0; i < allKeys.length; i++) {
            if (getType(this.tree[allKeys[i]]) === "line") {
                continue
            }
            nodeKeys.push(allKeys[i]);
            avgLon += parseFloat(this.tree[allKeys[i]].longitude);
            avgLat += parseFloat(this.tree[allKeys[i]].latitude);
        }
        if (nodeKeys.length === 0) {
            return
        }
        avgLon /= nodeKeys.length;
        avgLat /= nodeKeys.length;
        nodeKeys.forEach(key => {
            this.tree[key].longitude = parseFloat(this.tree[key].longitude) + offsetX + x - avgLon; 
            this.tree[key].latitude = parseFloat(this.tree[key].latitude) + offsetY + y - avgLat;
        });
    },

    /**
     * Return true if this TreeWrapper can be moved, otherwise return false;
     * @return {boolean}
     */
    isValidForMove() {
        const objects = Object.values(this.tree);
        if (objects.length === 0) {
            return false
        }
        const names = this.getNamesOfTypes("line");
        if (names.length !== 0) {
            alert(`Lines cannot be moved. Please unselect the following lines: "` + names + `"`);
            return false
        }
        return true
    },

    /**
     * Return true if this TreeWrapper contains objects that can be added-to by the 'obj' argument, otherwise return false.
     * @param {Object} obj - the object to add to the data, using every object in this TreeWrapper.
     * @return {boolean}
     */
    isValidForAdd(obj) {
        const objects = Object.values(this.tree);
        if (objects.length === 0) {
            return false
        }
        const type = getType(obj);
        const names = this.getNamesOfTypes("line", "configurationNode");
        switch (type) {
            case "independentNode":
            case "configurationNode":
                alert(`This component cannot be added to another object. Please unselect all objects before adding this component again.`);
                return false;
            case "childNode":
                if (names.length > 0 && obj.object !== "recorder") {
                    alert(`This component cannot be added as a child of a line or a configuration node. Please unselect the following objects: "` + names + `" before adding this component again.`);
                    return false;
                }
                return true;
            case "line":
                if (objects.length < 2) {
                    alert("Please select at least 2 circles to add this line.");
                    return false;
                }
                if (names.length > 0) {
                    alert(`A line cannot be added to another line or a configuration node. Please unselect the following objects: "` + names + `" before adding this line again.`)
                    return false;
                }
                return true;
        }
    },

    /**
     * TODO: add unit tests 
     * @param {Array} types - the types of objects we want to select from this TreeWrapper.
     * @return {string} - the names of objects with the specified types.
     */
    getNamesOfTypes(...types) {
        return Object.values(this.tree).filter(obj => {
            const type = getType(obj);
            return types.includes(type);
            //return type === "line" || type === "configurationNode"
        }).map(obj => obj.name !== undefined ? obj.name : Object.values(obj)[0]).join(", ");
    },

    /* Private TreeWrapper methods */

    /** 
     * Add an object from the tWrapper argument into this TreeWrapper.
     * @param {string} key - the key of the object to search for in the tWrapper argument.
     * @param {TreeWrapper} tWrapper - the TreeWrapper from which we want to get data to insert into this TreeWrapper.
     */
    add(key, tWrapper) {
        if (!tWrapper.contains(key)) {
            // TODO: I've seen a case where this gets triggerred because somehow the viewport is added to the TreeWrapper
            console.log(`Unable to add the desired tree object to this TreeWrapper. The tree object with the key: "${key}" does
            not exist in the source tWrapper argument.`)
            return;
        }
        this.tree[key] = tWrapper.tree[key];
        const name = this.tree[key].name;
        if (name == null) {
            return;
        }
        this.names[name] = key;
    },

    /** 
     * Return a TreeWrapper that contains direct children of the tree object with the passed key argument.
     * @param {string} key - the key of the tree object that is presumably a parent to some other tree objects.
     * @return {TreeWrapper} childrenTreeWrapper - contains only children tree objects of the key tree object.
     */
    getChildrenOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to get the children of the tree object with key: "${key}". The key does not exist in this
            //TreeWrapper.`);
            return tWrapper;
        }
        const type = getType(this.tree[key]);
        if (type === "childNode" || type === "independentNode") {
            const thisName = this.tree[key].name;
            if (thisName == null) {
                /* Children reference their parent with the parent's name. If a node doesn't have a name, then it must not
                have children. */
                //console.log(`Unable to get the children of the tree object with key: "${key}". The tree object
                //does not have a name.`);
                return tWrapper;
            } 
            // TODO: Build an object in TreeWrapper that allows instant lookup of children for any TreeWrapper.tree object
            Object.keys(this.tree).forEach(key => {
                if (this.tree[key].parent === thisName) {
                    tWrapper.add(key, this);
                }
            });
        }
        return tWrapper;
    },

    /** 
     * Return a TreeWrapper that contains lines connected to the tree object with the passed key argument.
     * @param {string} key - the key of the tree object that presumably has lines connected to it.
     * @return {TreeWrapper} - contains only line tree objects that connect to the desired tree object.
     */
    getConnectedLinesOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to find lines that connect to this node with key: "${key}". The key does not exist in this
            //TreeWrapper.`);
            return tWrapper;
        } 
        const type = getType(this.tree[key]);
        if (type === "childNode" || type === "independentNode") {
            const thisName = this.tree[key].name;
            if (thisName == null) {
                /* Lines reference their connected nodes with the node's name. If a node doesn't have a name, then it must not
                have lines. */
                //console.log(`Unable to get the lines of the tree object with key: "${key}". The tree object
                //does not have a name.`);
                return tWrapper;
            } 
            // TODO: Build an object in TreeWrapper that allows instant lookup of connected lines for any TreeWrapper.tree object
            Object.keys(this.tree).forEach(key => {
                if (this.tree[key].to === thisName || this.tree[key].from === thisName) {
                    tWrapper.add(key, this);
                }
            });
        }
        return tWrapper;
    },

    /** 
     * Merge the treeWrapper argument into this TreeWrapper.
     * 
     * If no keys argument is passed, the entire treeWrapper argument is merged into this TreeWrapper.
     * If a keys argument is passed, only those tree objects with matching keys inside of the treeWrapper argument are merged
     * into this TreeWrapper.
     * @param {TreeWrapper} treeWrapper - contains tree objects that will be merged into this TreeWrapper
     * @param {Array} keys - an optional argument that limits which tree objects are merged into this TreeWrapper
     */
    merge(treeWrapper, keys) {
        if (keys === undefined) {
            Object.keys(treeWrapper.tree).forEach(key => {
                this.add(key, treeWrapper);
            });
        } else if (Array.isArray(keys)) {
            keys.forEach(key => {
                this.add(key, treeWrapper);
            });
        } else {
            throw new Error("If the keys argument is passed, it must be an array");
        }
    },

    /** 
     * Return a TreeWrapper that contains all tree objects that will be deleted as a result of deleting the
     * tree object with the passed key argument.
     * 
     * @param {string} key - the key of the tree object for which to find its deletable subtree.
     * @param {Array} visited - contains keys of tree objects that have already been visited so the method dosen't
     * recurse infinitely in case of a cycle.
     * @return {TreeWrapper}
     */
    getSubtreeToDelete(key, visited) {
        if (!Array.isArray(visited)) {
            throw new Error("Visited argument must be an array");
        }
        visited.push(key);
        const tWrapper = createTreeWrapper();
        const children = this.getChildrenOf(key);
        tWrapper.merge(children);
        tWrapper.merge(this.getConnectedLinesOf(key));
        if (Object.keys(children.tree).length > 0) {
            for (let childKey in children.tree) {
                if (!visited.includes(childKey)) {
                    tWrapper.merge(this.getSubtreeToDelete(childKey, visited));
                }
            }
        }
        return tWrapper;
    },

    /**
     * Return a TreeWrapper that contains only the parent tree object of the child tree object.
     * 
     * @param {string} childKey - the key of the child tree object.
     * @return {TreeWrapper} subWrapper - contains only the parent tree object of the child tree object.
     */
    getParentOf(childKey) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(childKey)) {
            //console.log(`Unable to get the parent of the tree object with key: "${childKey}". The key does not exist in this
            //TreeWrapper.`);
            return tWrapper;
        }  
        const parentName = this.tree[childKey].parent;
        if (parentName == null) {
            // This tree object doesn't have a parent, which is fine.
            return tWrapper
        }
        const parentKey = this.names[parentName];
        if (parentKey == null) {
            /* If parentKey is undefind, then either 1) the child node has a parent that doesn't exist in this graph or 
            2) the names object of a TreeWrapper was built incorrectly */
            //console.log(`Unable to get the parent of the child tree object with key: "${childKey}". The parent does not 
            //exist in this TreeWrapper.`); //or the 'names' property is being built wrong.
            return tWrapper;
        }
        tWrapper.add(parentKey, this);
        return tWrapper;
    },

    /** 
     * Return a TreeWrapper that contains only tree objects that are on the other ends of lines that connect
     * to the tree object with the passed key argument.
     * 
     * @param {string} key - the tree object for which to search for its paired nodes. Nodes have a paired relationship
     * if they are connected by a line.
     * @return {TreeWrapper} - contains only tree objects that are paired nodes of the tree object for which
     * we searched.
     */
    getPairedNodesOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to get the paired nodes of the tree object with the key: "${key}". The key does not exist
            //in this TreeWrapper`);
            return tWrapper;
        }
        const type = getType(this.tree[key]);
        if (type === "childNode" || type == "independentNode") {
            const linesTreeWrapper = this.getConnectedLinesOf(key);
            for (let lineKey in linesTreeWrapper.tree) {
                const fromKey = this.names[this.tree[lineKey].from];
                const toKey = this.names[this.tree[lineKey].to];
                if (key === fromKey) {
                    // The 'from' node points to this tree object, so we want the other tree object
                    tWrapper.add(toKey, this);
                } else if (key === toKey) {
                    // The 'to' node points to this tree object, so we want the other tree object
                    tWrapper.add(fromKey, this);
                } else {
                    throw new Error(`There was a problem finding a "from" or "to" node for line with key: "${lineKey}"`);
                }
            }
        }
        return tWrapper;
    },

    /** 
     * Return a TreeWrapper that contains nodes on either end of the line that is represented by the
     * tree object with the passed key argument.
     * @param {string} key - the key of the tree object that is a line. 
     * @return {TreeWrapper} subWrapper - contains only 2 tree objects that are on either end of the line,
     * or 0 tree objects if the tree object isn't a line!
     */
    getNodeEndsOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to get the node ends of the tree object with the key: "${key}". The key does not exist
            //in this TreeWrapper`);
            return tWrapper;
        } 
        if (getType(this.tree[key]) === "line") {
            const fromKey = this.names[this.tree[key].from];
            const toKey = this.names[this.tree[key].to];
            if (fromKey == null) {
                if (toKey == null) {
                    console.log(`Tree object with key: "${key}" has nonexistent "from" and "to" nodes.`);
                    return tWrapper;
                } else {
                    console.log(`Tree object line with key: "${key}" has nonexistent "from" node.`);
                    //tWrapper.add(toKey, this);
                    return tWrapper;
                }
            } else if (toKey == null) {
                console.log(`Tree object line with key: "${key}" has nonexistent "to" node.`);
                //tWrapper.add(fromKey, this);
                return tWrapper;
            } else {
                tWrapper.add(fromKey, this);
                tWrapper.add(toKey, this);
            }
        }
        return tWrapper;
    },

    /**
     * Return a treeWrapper that contains tree objects that will be affected by drawing the tree object with the key argument.
     * @param {string} key
     * @return {TreeWrapper}
     */
    getSubtreeToRedraw(key) {
        const tWrapper = createTreeWrapper();
        tWrapper.merge(this.getParentOf(key));
        tWrapper.merge(this.getChildrenOf(key));
        tWrapper.merge(this.getConnectedLinesOf(key));
        tWrapper.merge(this.getPairedNodesOf(key));
        tWrapper.merge(this.getNodeEndsOf(key));
        return tWrapper;
    },

    /** 
     * Return true if the tree of this TreeWrapper contains the 'key' argument as a property, otherwise return false;
     * @param {string} key - the key to search for in the TreeWrapper.tree
     * @return {boolean}
     */
    contains(key) {
        if (this.tree[key] == null) {
            // Methods that use this method have more specific error messages that make this one redundant
            //console.log(`Unable to perform any operations with the 'key' argument.
            //No tree object with key: "${key}" exists in this TreeWrapper.`);
            return false;
        }
        //const name = this.tree[key].name;
        //if (name == null) {
        //    //console.log(`The tree object with the key: "${key}" does not have a 'name' property, therefore it isn't
        //    //contained in the 'names' property of this TreeWrapper.`);
        //} else if (this.names[this.tree[key].name] == null) {
        //    console.log(`The 'names' property of this TreeWrapper is missing an entry for tree object with key: "${key}",
        //    name: "${this.tree[key].name}".`); 
        //}
        return true;
    },

    /**
     * Return an object that maps the name of every tree object to its key, if a tree object has a name.
     * 
     * This must run before I can build any other property. O(2n) is much better than O(n^2).
     * @return {Object}
     */
    mapNames() {
        const map = {};
        const keys = Object.keys(this.tree);
        for (let i = 0; i < keys.length; i++) {
            let name = this.tree[keys[i]].name;
            if (name == null) continue;
            let stringName = String(name).toLowerCase();
            if (stringName === "null" || stringName === "undefined") continue;
            map[name] = keys[i];
        }
        return map;
    },

    /**
     * Return an object that maps the key of every tree object to either 1) an array of child keys or 2) null
     * if there are no children.
     * @return {Object} 
     */
    buildChildren3() {
        const children = {};
        const keys = Object.keys(this.tree);
        for (let i = 0; i < keys.length; i++) {
            //if (children[keys[i]] === undefined) {
            //    children[keys[i]] = null;
            //} 
            //let parentName = this.tree[keys[i]].parent;
            //if (parentName === undefined) {
            //    continue;
            //}
            //let parentKey;
            //try {
            //    parentKey = this.getKeyFromName(parentName);
            //} catch (e) {
            //    console.error(`The child object named "${this.tree[keys[i]].name}" has a non-existant parent object with the name "${parentName}".`);
            //    continue;
            //}
            //if (children[parentKey] == null) {
            //    children[parentKey] = [keys[i]];
            //} else {
            //    children[parentKey].push(keys[i]);
            //}
        }
        return children;
    },

    /**
     * If the parentName is null, that name will never be found in TreeWrapper.names, so an error will be thrown always.
     */
    mapChild(key) {
        //call contains
        let parentName = this.tree[key].parent;
        if (parentName === undefined) {
            return;
        }
        let parentKey;
        try {
            parentKey = this.getKeyFromName(parentName);
        } catch (e) {
            console.error(`The child object named "${this.tree[key].name}" has a non-existant parent object with the name "${parentName}".`);
            return;
        }
        if (this.children[parentKey] == null) {
            this.children[parentKey] = [key];
        } else if (!this.children[parentKey].includes(key)) {
            this.children[parentKey].push(key);
        }
    },

    /**
     * 
     */
    registerLine(key) {
        let sourceName = this.tree[key].from;
        let targetName = this.tree[key].to;
        //if ()
    },

    /**
     * Return the key of the object with a 'name' property value that matches the 'name' argument. If there is no such object,
     * throw an error.
     * @param {string} name - the name to search for.
     * @return {string}
     */
    getKeyFromName(name) {
        const key = this.names[name];
        if (key === undefined) {
            throw new Error(`The name "${name}" does not exist in this TreeWrapper.names.`);
        }
        return key
    },

    buildChildrenAndLines() {
        const keys = Object.keys(this.tree);
        for (let i = 0; i < keys.length; i++) {
            mapChild(keys[i]);
            buildLines(keys[i]);
        }
    }
};

/** 
 * Return an object that has an 'tree' object and a 'names' map.
 * 
 * The 'tree' object is a reference to the tree that exists in writeFeeder, which is the original source of all data.
 * The 'names' object maps the name of a tree object to the key of the tree object in the tree. This allows faster
 * retrieval of to/from/parent nodes when building the svg data. Without this map, we would have to parse the tree to find
 * every to/from/parent node. This would be slow.
 * @param {Object} tree - contains all of the objects that will be used to generate the svg.
 * @return {TreeWrapper} treeWrapper - a wrapper around the tree argument. This wrapper also has the name-key map to speed up 
 * to/from/parent node retrieval.
 */
function createTreeWrapper(tree = {}) {
    Object.keys(tree).forEach(key => {
        if (!isNumberString(key)) {
            throw new Error(`The key "${key}" in the 'tree' argument cannot be parsed to a valid number.`);
        }
    });
    const tWrapper = Object.create(treeWrapperPrototype);
    tWrapper.tree = tree;
    tWrapper.children = {};
    tWrapper.lines = {};
    tWrapper.names = tWrapper.mapNames();
    //tWrapper.buildChildrenAndLines();
    return tWrapper;
}

//**************************************************
// TreeWrapper-to-SVG interface
//**************************************************

const deletableSvgDataPrototype = {

    /* Public interface methods */

    /**
     * Use the ids inside of the deletableSvgData instance to remove elements from the document viewport.
     */
    deleteFrom(viewport) {
        this.ids.forEach(id => {
            let e = document.getElementById(id);
            if (e != null) {
                viewport.removeChild(document.getElementById(id));
            }
            // could log a console message if it would be helpful
        });
    }
}

/** 
 * TODO: should take a treeWrapper, add unit tests
 * 
 * @param {Object} tree - A tree of all tree objects that 1) were already deleted from the tree and 2) should also
 * be deleted from the svg.
 * @return {Object} DeletableSvgData - Has a method for deleting from a viewport.
 */
function createDeletableSvgData(tree) {
    const obj = Object.create(deletableSvgDataPrototype);
    obj.ids = []
    Object.keys(tree).forEach(key => {
        if (getType(tree[key]) === "childNode") {
            obj.ids.push(key);
            const parentChildLineId = `${tree[key].parent}_${tree[key].name}`
            obj.ids.push(parentChildLineId);
        } else {
            obj.ids.push(key);
        }
        //console.log(`Failed to delete type: "${tree[key].object}", name: "${tree[key].name}", key: ${key}"`);
        //throw new Error(`tree key: ${key}, with data: ${tree[key]} is not a parent-child node, a parentless node, or a line.`); 
    });
    return obj;
}

const addableSvgDataPrototype = {

    /* "Public" interface methods */

    /**
     * Deletes lines and circles from the viewport if they exist, then draws all lines and circles on the viewport.
     * 
     * I know why elements lose their selected status. I'm removing old circles and adding completely new ones each time!
     * The old circles/lines have coordinates that are no good. Would it be smart to modify them instead of always replacing them?
     * @param {HTMLElement} viewport - a viewport created by svg-pan-zoom.
     */
    drawTo(viewport) {
        this.lines.forEach(line => {
            this.drawObject(line, viewport);
        });
        this.circles.forEach(circle => {
            this.drawObject(circle, viewport);
        });
        scaleTo(scaleLevel);
    },

    /* "Private" helper methods */

    /**
     * TODO: add unit tests
     */
    drawObject(obj, viewport) {
        let e = document.getElementById(obj.id);
        if (e != null) {
            if (e.classList.contains("selected")) {
                gSelection.remove(e);
                gSelection.add(obj);
            }
            e.parentNode.removeChild(e);
        } 
        viewport.appendChild(obj);
    },

    /** 
     * TOOD: add unit tests
     */
    addLine(key) {
        const nodes = Object.values(this.treeWrapper.getNodeEndsOf(key).tree);
        if (nodes.length < 2) {
            console.log(`Could not find both of the nodes on either end of a line with key: "${key}". Line was not drawn`);
            /* TODO: Draw the line anyway with some kind of default values so the user can see there's a broken line?
            I could have a second viewport that is contained in a table with all the broken lines and circles! Neat!
            */
            return;
        }
        const tree = this.treeWrapper.tree;
        let line;
        if (tree[key].from === nodes[0].name) {
            line = createSvgLine(nodes[0], nodes[1], key, tree[key]);
        } else {
            line = createSvgLine(nodes[1], nodes[0], key, tree[key]);
        }
        this.lines.push(line);
    },

    /** 
     * TODO: add unit tests
     */
    addParentChildLine(key) {
        const parent = Object.values(this.treeWrapper.getParentOf(key).tree)[0];
        if (parent == null) {
            //console.log(`Could not draw the parent-child line for child tree object with key: "${key}"`);
            return;
        }
        const parentChildLine = createSvgLine(parent, this.treeWrapper.tree[key]);
        this.lines.push(parentChildLine);
    },
};

/** 
 * Return an AddableSvgData instance.
 * 
 * An AddableSvgData instance contains an array of circles and an array of lines that can be draw to the svg.
 * @param {TreeWrapper} treeWrapper - contains all tree objects that should be drawn to to the svg.
 * @return {AddableSvgData} - the svg data to add.
 */
function createAddableSvgData(treeWrapper) {
    if (Object.getPrototypeOf(treeWrapper) !== treeWrapperPrototype) {
        throw new Error("treeWrapper argument must be an instance of TreeWrapper");
    }
    const obj = Object.create(addableSvgDataPrototype);
    obj.treeWrapper = treeWrapper;
    obj.lines = [];
    obj.circles = [];
    const tree = treeWrapper.tree;
    Object.keys(tree).forEach(key => {
        let type = getType(tree[key]);
        switch (type) {
            case "line":
                obj.addLine(key);
                break;
            case "childNode":
                obj.circles.push(createSvgCircle(key, tree[key]));
                obj.addParentChildLine(key);
                break;
            case "configurationNode":
                obj.circles.push(createSvgCircle(key, tree[key]));
                break;
            case "independentNode":
                obj.circles.push(createSvgCircle(key, tree[key]));
                break;
            default:
                console.log(`Failed to draw object type: "${tree[key].object}", name: "${tree[key].name}", key: "${key}"`);
        }
    });
    return obj
}

//**************************************************
// Utility methods
//**************************************************

/**
 * There are 4 types of objects: lines, child nodes, independent nodes, and configuration nodes.
 * The line between a parent and child doesn't exist in the data itself, it's merely shown in the svg
 * to demonstrate the relationship between two nodes.
 */

/* Public utility methods */

/**
 * Return true if the string is a valid number, otherwise return false. Thanks stackoverflow.
 * @param {string}
 * @return {boolean}
 */
function isNumberString(str) {
    if (typeof str !== "string" || /\s/.test(str)) {
        //console.error(`Expected "${str}" to be a string without whitespace, but it was not.`);
        return false;
    } 
    if (isNaN(str) || isNaN(parseFloat(str))) {
        //console.error(`Expected "${str}" to be a string that could be parsed to a number, but it was not.`);
        return false;
    }
    return true;
}

/**
 * Return the type of the object with regard to this interface.
 * 
 * This function is important because the order in which an object is checked matters. For example, an object
 * could be both a 'line' type and a 'configurationNode' type, but the 'line' type should take precedence over the 
 * 'configurationNode' type, so 'line' should be returned.
 * @param {Object} obj
 * @return {string}
 */
function getType(obj) {
    if (isLine(obj)) {
        return "line";
    } else if (isChildNode(obj)) {
        return "childNode";
    } else if (isConfigurationNode(obj)) {
        return "configurationNode";
    }
    return "independentNode"
}

/** 
 * Return an object that is a copy of the argument object.
 * JSON.stringify will not copy a property of an object with an undefined value.
 * @param {Object} oldObject - the object to copy.
 * @return {Object} - a copy of the object argument.
 */
 function deepCopy(oldObject) {
    if (Object.getPrototypeOf(oldObject) !== Object.prototype) {
        throw new Error("This function cannot be used to copy objects created with a constructor function.");
    }
    const properties = Object.getOwnPropertyNames(oldObject);
    const keys = Object.keys(oldObject);
    for (let key of keys) {
        if (typeof(oldObject[key]) === "function") {
            throw new Error("This function cannot be used to copy objects with methods.");
        } else if (oldObject[key] === undefined) {
            throw new Error("JSON.stringify silently ignores properties with undefined values, so this function cannot handle undefined values.");
        }
    }
    return JSON.parse(JSON.stringify(oldObject));
}

/**
 * 
 * This seems unncessary, but what if a user opens up their .omd file in a text program and messes up a key somewhere?
 */
function formatKey(key) {
    if (!isFinite(key)) {

    }

    if (isNaN(parseFloat(key))) {
        throw new Error("key argument must be a string that can be parsed to a valid number");
    } 
}

function formatNumericString(string) {

}

/**  
 * TODO: add unit tests
 */
function keyIsStringAndValidNumber(key) {
    if (typeof(key) !== "string") {
        throw new Error("key argument must be a string.");
    }
    if (isNaN(parseFloat(key))) {
        throw new Error("key argument must be a string that can be parsed to a valid number");
    }
}

function formatKey(key) {
    if (isNaN(parseFloat(key))) {
        throw new Error(`The key ${key} is not a valid number.`);
    }
    if (typeof(key) !== "string") {
        
    }
}

/* Private utility methods */

/**
 * Return true if the object has a 'parent' property, otherwise return false.
 * @param {Object} obj
 * @return {boolean}
 */
function isChildNode(obj) {
    return obj.parent !== undefined;
}

/**
 * Return true if the object has 'from' and 'to' properties, otherwise return false.
 * @param {Object} obj
 * @return {boolean}
 */
function isLine(obj) {
    return obj.from !== undefined && obj.to !== undefined;
}

/**
 * Return true if the object is a configuration node.
 * @param {Object} obj
 * @return {boolean}
 */
function isConfigurationNode(obj) {
    if (obj.object == null || configurationTypes.includes(obj.object)) {
        return true;
    }
    return false;
}

/**
 * TODO: add unit tests
 * Return a generator that will provide the longitude and latitude for an object.
 * 
 * @param {number} initX - the longitude of the top left corner of the square.
 * @param {number} initY - the latitude of the top left corner of the square.
 * @param {number} spacing - how far apart to space a node from adjacent nodes in the square.
 * @return {Generator}
 */
function * getCoordinates(initX, initY, spacing) {
    yield {
        longitude: initX,
        latitude: initY
    }
    let x = 0;
    let y = 0;
    let dimension = 1;
    while (true) {
        if (x <= dimension) {
            yield {
                longitude: initX + (x++ * spacing),
                latitude: initY + (dimension * spacing)
            }
        } else {
            yield {
                longitude: initX + (dimension * spacing),
                latitude: initY + (y++ * spacing)
            }
        }
        if (y === dimension) {
            dimension++;
            x = 0;
            y = 0;
        }
    }
}

//**************************************************
// (new) SVG interface
//**************************************************

const svgCirclePrototype = {
    /**
     * TODO: update unit tests
     */
    getNewInstance() {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this.update(circle);
        return circle; 
    },
    /**
     * TODO: update unit tests
     */
    update(circle) {
        circle.setAttribute('id', this.id);
        circle.setAttribute('class', this.class);
        circle.setAttribute('r', this.r);
        circle.setAttribute('stroke-width', this["stroke-width"]);
        circle.setAttribute('cx', this.cx);
        circle.setAttribute('cy', this.cy);
    }
};

/**
 * TODO: update unit tests
 */
function createSvgCircle2(key, {longitude, latitude, object}, {r = 2, strokeWidth = 0.5} = {}) {
    let error = "";
    if (!isNumberString(key)) {
        error += `The 'key' argument, "${key}", must be formatted as a string that can be parsed to a valid number. `
    } 
    if (typeof longitude !== "number" && !isNumberString(longitude)) {
        error += `The 'longitude' argument, "${longitude}", must be formatted as either 1) a string that can be parsed to a valid number or 2) a number. `
    }
    if (typeof latitude !== "number" && !isNumberString(latitude)) {
        error += `The 'latitude' argument, "${latitude}", must be formatted as either 1) a string that can be parsed to a valid number or 2) a number. `
    }
    if (error !== "") {
        error = `The circle with key "${key}" was not drawn. ` + error;
        console.error(error);
        return;
    }
    const circle = Object.create(svgCirclePrototype);
    circle.id = key;
    circle.class = object;
    circle.r = r;
    circle["stroke-width"] = strokeWidth;
    circle.cx = longitude - gOffsetX;
    circle.cy = latitude - gOffsetY;
    return circle;
}

const svgLinePrototype = {
    getNewInstance() {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        this.update(line);
        return line; 
    },
    update(line) {
        line.setAttribute('id', this.id);
        line.setAttribute('class', this.class);
        line.setAttribute('stroke-width', this["stroke-width"]);
        line.setAttribute('x1', this.x1);
        line.setAttribute('x2', this.x2);
        line.setAttribute('y1', this.y1);
        line.setAttribute('y2', this.y2);
    }
};

/**
 * TODO: add unit tests, add error handling
 */
function createSvgLine2(source, target, key=null, lineObject=null) {
    const line = Object.create(svgLinePrototype);
    line.x1 = source.longitude - gOffsetX;
    line.x2 = target.longitude - gOffsetX;
    line.y1 = source.latitude - gOffsetY;
    line.y2 = target.latitude - gOffsetY;
    if (key == null && lineObject == null) {
        // key and lineObject weren't included, so this line doesn't represent a real object in the tree, so it's a parent-child line.
        line.id = `${source.name}_${target.name}`;
        line.class = "parentChild";
        line["stroke-width"] = .025;
        return line;
    } else if (key != null && lineObject != null) {
        line.id = key;
        const phaseCount = countPhases(lineObject.phases).toString();
        line.class =  `${lineObject.object} p${phaseCount}`;
        line["stroke-width"] = phaseCount;
        return line;
    }
}

const svgDataPrototype = {

    /* Public methods */

    /**
     * TODO: add unit test
     */
    drawTo(viewport) {
        this.lines.forEach(line => {
            this.draw(line, viewport);
        });
        this.circles.forEach(circle => {
            this.draw(circle, viewport);
        });
        scaleTo(scaleLevel);
    },

    /**
     * TODO: add unit tests
     */
    deleteFrom(viewport) {
        this.keys.forEach(key => {
            const e = document.getElementById(key);
            if (e != null) {
                viewport.removeChild(e);
            }
        });
        /*
        this.lines.forEach(line => {
            const e = document.getElementById(line.id);
            if (e != null) {
                viewport.removeChild(e);
            }
        });
        this.circles.forEach(circle => {
            const e = document.getElementById(circle.id);
            if (e != null) {
                viewport.removeChild(e);
            }
        });
        */
    },

    /* Private methods */

    /**
     * No need to update selection. If the element was selected, it still will be. If it is new, then it couldn't have been selected.
     */
    draw(obj, viewport) {
        const e = document.getElementById(obj.id);
        if (e != null) {
            obj.update(e);
        } else {
            viewport.appendChild(obj.getNewInstance());
        }
    },
}

/**
 * TODO: add unit tests. See if all this works, then add in the subtree redraw etc.
 */
function createSvgData(tree, keys=null) {
    const svgData = Object.create(svgDataPrototype);
    svgData.lines = [];
    svgData.circles = [];
    if (keys == null) {
        keys = Object.keys(tree.tree);
    }
    svgData.keys = keys;
    //svgData.tree = tree;
    keys.forEach(key => {
        let type = getType(tree.getObject(key));
        switch (type) {
            case "line":
                svgData.lines.push(createSvgLine2(tree.getFromNode(key), tree.getToNode(key), key, tree.getObject(key)));
                break;
            case "childNode":
                svgData.circles.push(createSvgCircle2(key, tree.getObject(key)));
                svgData.lines.push(createSvgLine2(tree.getObject(key), tree.getParent(key)));
                break;
            case "configurationNode":
                svgData.circles.push(createSvgCircle2(key, tree.getObject(key)));
                break;
            case "independentNode":
                svgData.circles.push(createSvgCircle2(key, tree.getObject(key)));
                break;
            default:
                console.log(`Failed to draw object type: "${tree.getObject(key).object}", name: "${tree.getObject(key).name}", key: "${key}".`);
        }
    });
    return svgData;
}

/** 
 * TODO: add unit tests
 * @return {Object} SvgCircle - A fully configured svg circle.
 */
 
function createSvgCircle(key, {longitude, latitude, object}, {r = 2, strokeWidth = 0.5} = {}) {
    keyIsStringAndValidNumber(key);
    if (longitude == null || latitude == null || object == null) {
        //console.log(`For circle with tree key: "${key}", longitude was: "${longitude}",
        //latitude was: "${latitude}", object was: "${object}"`)
    }
	const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
	circle.setAttribute('id', key);
	circle.setAttribute('class', object);
	circle.setAttribute('r', r);
    circle.setAttribute('stroke-width', strokeWidth);
    // Set coordinates and consider if they need to be translated
    longitude = parseFloat(longitude) - gOffsetX;
    latitude = parseFloat(latitude) - gOffsetY;
    circle.setAttribute('cx', longitude);
    circle.setAttribute('cy', latitude);
    return circle;
}


/** 
 * TODO: add unit tests
 * @return {Object} SvgLine - A fully configured svg line.
 */
 
function createSvgLine(sourceNode, targetNode, key, thisObject) {
    const svgLine = document.createElementNS('http://www.w3.org/2000/svg', 'line'); 
    if (sourceNode.longitude == null || sourceNode.latitude == null || targetNode.longitude == null ||
    targetNode.latitude == null) {
        console.log(`For line with tree key: "${key}", sourceNode.name was: "${sourceNode.name}",
        sourceNode.longitude was: "${sourceNode.longitude}", sourceNode.latitude was: "${sourceNode.latitude}",
        targetNode.name was: "${targetNode.name}", targetNode.longitude was: "${targetNode.longitude}",
        targetNode.latitude was: "${targetNode.latitude}"`)
        //throw new Error(`For line with tree key: "${key}", sourceNode.longitude was: "${sourceNode.longitude}",
        //sourceNode.latitude was: "${sourceNode.latitude}", targetNode.longitude was: "${targetNode.longitude}",
        //targetNode.latitudw was: "${targetNode.latitude}"`)
    }
    // Set coordinates and consider if they need to be translated
    let sourceLon = parseFloat(sourceNode.longitude) - gOffsetX;
    let sourceLat = parseFloat(sourceNode.latitude) - gOffsetY;
    let targetLon = parseFloat(targetNode.longitude) - gOffsetX;
    let targetLat = parseFloat(targetNode.latitude) - gOffsetY; 
    svgLine.setAttribute("x1", sourceLon); 
    svgLine.setAttribute("x2", targetLon);
    svgLine.setAttribute("y1", sourceLat); 
    svgLine.setAttribute("y2", targetLat);
    if (key == null && thisObject == null) {
        // key and thisObject weren't included, so this line doesn't represent a real object in the tree, so it's a parent-child line.
        svgLine.setAttribute("id", `${sourceNode.name}_${targetNode.name}`);
        svgLine.setAttribute("class", "parentChild");
        svgLine.setAttribute("stroke-width", 0.25);
        return svgLine;
    } else if (key != null && thisObject != null) {
        keyIsStringAndValidNumber(key);
        svgLine.setAttribute("id", key);
        const phaseCount = countPhases(thisObject.phases).toString();
        const domClass = `${thisObject.object} p${phaseCount}`;
        svgLine.setAttribute("class", domClass);
        svgLine.setAttribute("stroke-width", phaseCount);
        return svgLine;
    }
    throw new Error("key and thisObject arguments must be passed together or not at all");
}


//**************************************************
// TreeObject interface
//**************************************************

const treeObjectPrototype = {

    /* Public TreeObject methods.*/

    /**
     * Set the 'parent', 'longitude', and 'latitude' properties of this TreeObject.data based on the 'parent' argument.
     * @param {Object} parent - the object to set as the parent of this child.
     */
    setupChildNode(parent) {
        if (getType(this.data) !== "childNode") {
            throw new Error("This TreeObject should have a type of 'childNode'.");
        }
        if (getType(parent) !== "childNode" && getType(parent) !== "independentNode") {
            throw new Error("The 'parent' argument should have a type of 'childNode', 'independentNode', or 'line'.");
        }
        if (parent.name == null || parent.longitude == null || parent.latitude == null) {
            throw new Error("The 'parent' argument is missing properties.");
        }
        this.data.parent = parent.name;
        const lonValue = (Math.random() * 5) + 5; 
        this.data.longitude = Math.random() < 0.5 ? parent.longitude + lonValue : parent.longitude - lonValue;
        const latValue = (Math.random() * 5) + 5;
        this.data.latitude = Math.random() < 0.5 ? parent.latitude + latValue : parent.latitude - latValue;
    },

    /**
     * Set the 'from', 'to', and 'phases' properties of this TreeObject.data based on the 'source' and 'target' arguments.
     * @param {Object} source - the starting node of the line.
     * @param {Object} target - the ending node of the line.
     */
    setupLine(source, target) {
        if (getType(this.data) !== "line") {
            throw new Error("This TreeObject should have a type of 'line'.");
        }
        const sType = getType(source);
        if (sType !== "childNode" && sType !== "independentNode") {
            throw new Error("The 'source' argument should have a type of 'childNode' or 'independentNode'.");
        }
        const tType = getType(target);
        if (tType !== "childNode" && tType !== "independentNode") {
            throw new Error("The 'target' argument should have a type of 'childNode' or 'independentNode'.");
        }
        if (source.name === undefined) {
            throw new Error("The 'source' argument should have a 'name' property.");
        }
        if (target.name === undefined) {
            throw new Error("The 'target' argument should have a 'name' property.");
        }
        if (source.phases === undefined) {
            const name = source.name !== undefined ? source.name : Object.values(source)[0]; 
            alert(`The source node of this line, "${name}", does not have a 'phases' property.`);
        } else {
            this.data.phases = source.phases;
        }
        this.data.from = source.name;
        this.data.to = target.name;
    },

    /* "Private" helper methods */
};

/**
 * Return a key value which has not been used in tree.
 * @return {string} key
 */
function getNewTreeKey(tree) { 
	let nextKey = Object.keys(tree).length;
	while(tree.hasOwnProperty(nextKey.toString())) {
		nextKey += 1;
	}
	return nextKey.toString();
}

// Fix this function. Some lines have CLOSED instead of ABCN or something.
function countPhases(p) {
	// Return the number of phases a line has.
	//return p.length
	let total = 0
	if (p.search('A') > -1) {total++}
	if (p.search('B') > -1) {total++}
	if (p.search('C') > -1) {total++}
	return total;
}

/** 
 * Return a TreeObject.
 * 
 * A TreeObject (which is not to be confused with a more general "tree object") is either:
 * 1) a copy of a component that is in the process of being added to the tree, OR
 * 2) a copy of an existing object in the tree.
 * 
 * @param {(string|Object)} input - either a key OR a map of properties to create this TreeObject.
 * @param {TreeWrapper} tree - the treeWrapper from which to create this TreeObject.
 * return {TreeObject} - Either a new component that does not exist in the tree, or a copy of an existing tree object 
 * inside of the treeWrapper argument.
 */
function createTreeObject(input, tree) {
    //if (Object.getPrototypeOf(treeWrapper) !== treeWrapperPrototype) {
    //    throw new Error("treeWrapper argument must be an instance of TreeWrapper");
    //}
    const tObject = Object.create(treeObjectPrototype);
    //const tObject = {};
    if (typeof(input) === "string") {
        keyIsStringAndValidNumber(input); // I don't like this
        const obj = tree.tree[input];
        if (obj != null) {
            tObject.key = input;
            tObject.data = deepCopy(obj);
            return tObject;
        }
        throw new Error(`The passed key argument: "${input}" to create the TreeObject does not exist in the treeWrapper.tree.`);
    } else if (typeof input === "object" && !Array.isArray(input)) {
        tObject.key = getNewTreeKey(tree.tree);
        tObject.data = deepCopy(input);
        if (tObject.data.name != null) {
            tObject.data.name += tObject.key;
        }
        return tObject;
    } 
    throw new Error("Input argument must be a string or an object.");
}

//**************************************************
// Table interface 
//**************************************************

/*
These are names of properties in most objects in writeFeeder.tree that should not be deleted from objects because
doing so might make that object hard to identify with reference to the rest of the data.
*/
const nonDeletableProperties = ["name", "object", "from", "to", "latitude", "longitude", "parent", "configuration"];
/* If these properties were to be modified for a given writeFeeder.tree object, it would require significantly modifying the 
other objects.  These properties ARE technically modifiable, but allowing the user to change them would require more work 
than I think is worth it. It is easier just to create a new node.
*/
const nonModifiableProperties = ["name", "object", "from", "to", "parent"];
const titleProperties = ["object"];
/* This array is used to determine if an object is a configuration node, based on the "object" property of that node. If a node
lacks the "object" property entirely, then I know its a configuration node.
Player is a configuration object. Recorder can have a parent, so it is NOT a configuration object.

Apparently nodes can be children of lines.
*/
const configurationTypes = ["regulator_configuration", "transformer_configuration", "triplex_line_configuration", "line_configuration",
"volt_var_control", "line_spacing", "climate", "overhead_line_conductor", "underground_line_conductor", "triplex_line_conductor",
"player"];

/**
 * TODO: add unit tests, $().draggable make the text unfocusable
 * If an object has no name, just get the first property in the object.
 */
function createSelectionTable(ids, tree) {
    const table = document.createElement("table");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody"); 

    const row = createRow({key: "Selected Elements"});
    Array.from(row.self.children).forEach(td => { td.classList.add("tableTitle") });
    row.self.children[1].setAttribute("colspan", "2");
    row.self.children[2].remove();

    tHead.append(row.self);
    table.append(tHead);
    table.append(tBody);
    table.classList.add("dataTable");
    ids.forEach(id => {
        let obj = tree.tree[id];
        let name = obj.name != null ? obj.name : Object.keys(obj)[0];
        let button = document.createElement("button");
        button.textContent = "view";
        button.classList.add("modalButton");
        button.addEventListener("click", function() {
            let table = document.getElementById(`descriptionTable_${id}`);
            if (table == null) {
                const table = createDescriptionTable(id, tree);
                table.id = `descriptionTable_${id}`;
                document.getElementById("descriptionTables").append(table);
            }           
        });
        let row = createRow({key: name, value: button, deletable: true}, document.getElementById(id));
        tBody.append(row.self);
    });
    if (window.jQuery != null) {
        table.style.left = "50vw";
        $(table).draggable();
    }
    return table;
}

/**
 * TODO: add unit tests, don't allow longitude and latitude to be editted for lines!,
 * turn all key inputs into plain text upon clicking save (would look nice), 
 * 
 * Bugs: $().draggable() makes text unfocusable via double click. Unfortunately,
 * this is set behavior of the library because the demo on the jQuery wesbsite behaves the same way. Users must right click
 * text in a table to select it.
 * 
 * The form element is only used to take advantage of the "required" form validation functionality that is native to the
 * browser.
 */
function createDescriptionTable(id, tree) {
    const form = document.createElement("form");
    form.classList.add("formContainer");
    const table = document.createElement("table");
    table.classList.add("dataTable");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody");
    const buttonRow = document.createElement("tr");
    buttonRow.classList.add("buttonRow");
    const buttonCell = document.createElement("td");
    buttonCell.setAttribute("colspan", "3");
    form.append(table);
    table.append(tHead);
    table.append(tBody);
    tBody.append(buttonRow);
    buttonRow.append(buttonCell);
    const tObject = createTreeObject(id, tree);
    if (getType(tObject.data) !== "line") {
        buttonCell.append(createButton({action: "move", tObject: tObject, tree: tree, tableBody: tBody}).self);
    }
    buttonCell.append(createButton({action: "delete", tObject: tObject, tree: tree, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "add", tObject: tObject, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "save"}).self);
    form.addEventListener("submit", function(event) {
        event.preventDefault();
        //const svg = createAddableSvgData(tWrapper.insert(tObject));
        const svg = createAddableSvgData(tWrapper.insert(tObject));
        svg.drawTo(gViewport);
        alert("Object saved");
    });
    Object.keys(tObject.data).forEach(key => {
        let row;
        if (titleProperties.includes(key)) {
            row = createRow({key: key, map: tObject.data});
            Array.from(row.self.children).forEach(td => {
                td.classList.add("tableTitle");
            });
            tHead.append(row.self);
        } else {
            row = createRow({key: key, deletable: true, map: tObject.data});
            tBody.appendChild(row.self);
        }
    });
    if (window.jQuery != null) {
        table.style.left = "50vw";
        $(table).draggable();
    }
    return form;
}

/**
 * TODO: add unit tests
 */
 function destroyTables(ids) {
    ids.forEach(id => {
        const tableDiv = document.getElementById(id);
        Array.from(tableDiv.children).forEach(t => {
            tableDiv.removeChild(t);
        });
    });
}

const buttonPrototype = {

    /* Private helper methods */

    /**
     * TODO: add unit tests
     */
    attachButtonMoveListener() {
        const element = document.getElementById("svgContainer");
        element.setAttribute("style", "cursor: crosshair");
        if (getType(this.tObject.data) === "line") {
            alert("Lines cannot be moved directly.");    
            return
        }
        const tWrapper = createTreeWrapper();
        tWrapper.add(this.tObject.key, this.tWrapper);
        const moveNode = getMoveNodesFunction(tWrapper, this.tableBody, this.tObject);
        //element.addEventListener("click", moveNode);
        element.onclick = moveNode;

        /* A table only exists for an existing tree object. Therefore, I can use the key of the tObject of this button
        to 1) create a new TreeWrapper consisting of just that object 2) move that TreeWrapper 3) get the subtree to
        redraw referencing the gTreeWrapper.
        This means that I'm moving the REAL tree object, and updating the TreeObject. If after the move I don't click save,
        any modifications to the TreeObject won't be persisted to the tree object. This is unlike before, where I modified the
        TreeObject AND inserted it.
        */
    },

    /**
     * TODO: update unit tests
     * Delete the TreeObject of this button from the TreeWrapper of this button
     */
    deleteObject() {
        let subWrapper;
        try {
            subWrapper = this.tWrapper.delete(this.tObject.key);
            createDeletableSvgData(subWrapper.tree).deleteFrom(gViewport);
        } catch (e) {
            if (confirm(e + " Alternatively, do you wish to delete this node and all of its immediately connected objects?")) {
                subWrapper = this.tWrapper.recursiveDelete(this.tObject.key);
                createDeletableSvgData(subWrapper.tree).deleteFrom(gViewport);
            }
        }
    },

    /**
     * TODO: add unit tests
     */
    validateArguments(args) {
        if (args.action === "move") {
            //if (args.tObject == null || args.tWrapper == null || args.tableBody == null) {
            //    throw new Error(`A button with a "${args.action}" action must have non-null tObject, tWrapper, and tableBody arguments`);
            //}
        } else if (args.action === "delete") {
            if (args.tObject == null || args.tWrapper == null || args.tableBody == null) {
                throw new Error(`A button with a "delete" action must have non-null tObject, tWrapper, and tableBody arguments`);
            }
        } else if (args.action === "add") {
            if (args.tObject == null || args.tableBody == null) {
                throw new Error(`A button with an "add" action must have non-null tObject and tableBody arguments`);
            }
        } else if (args.action !== "save") {
            throw new Error(`The action argument must match an existing action`);
        }
    }
}

/**
 * TODO: add unit tests, DON'T remove tObject argument, remove tWrapper argument
 */
function createButton({action, tableBody=null, tObject=null, tWrapper=null}) {
    const button = Object.create(buttonPrototype);
    button.validateArguments(arguments[0]);
    button.self = document.createElement("button");
    button.self.textContent = action;
    button.self.classList.add("modalButton");
    button.tObject = tObject;
    button.tWrapper = tWrapper;
    button.tableBody = tableBody;
    button.self.type = "button";
    switch (action) {
        case "move":
            button.self.addEventListener("click", function() {
                button.attachButtonMoveListener();
            });
            break;
        case "delete":
            button.self.classList.add("deleteButton");
            button.self.addEventListener("click", function() {
                button.deleteObject();                
                document.getElementById("descriptionTables").removeChild(tableBody.parentElement.parentElement);
            });
            break;
        case "add":
            button.self.addEventListener("click", function() {
                const row = createRow({key: "", deletable: true, map: tObject.data});
                tableBody.append(row.self);
            });
            break;
        case "save":
            button.self.type = "submit";
            break;
        default:
            throw new Error("The action argument must be a string that matches an existing action for this button.");
    }
    return button;
}

const rowPrototype = {

    /* Private helper methods */

    /**
     * Throw an error if arguments passed to createRow() were invalid.
     * @param {Object} args - an object containing the arguments that were passed to createRow().
     */
    validateArguments(args) {
        if (args.key != null && args.value != null && args.map != null) {
            throw new Error(`If there are key and map arguments, then the value of the row is determined by map[key] and passing a value
            argument is invalid`);
        } else if (args.map != null && args.map[args.key] === undefined && args.key !== "") {
            throw new Error("If a map argument is passed, the key argument should exist in that map.");
        } else if (args.key === "" && args.map == null) {
            throw new Error("If the key is an empty string, a map argument should be passed to the function");
        }
    },

    /**
     * Return false if the key already exists in the map or, otherwise return true.
     * @param {string} key - the incoming key that the user wants to write into the map belonging to this Row.
     * @return {boolean}
     */
    validateNewKey(key) {
        if (this.map[key] !== undefined || key === "") {
            return false;
        }
        return true;
    },

    /** 
     * Return false if the current key is an empty string, otherwise return true.
     * @return {boolean}
     */
    validateCurrentKey() {
        return this.key === "" ? false : true;
    },

    /**
     * Update a key in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new key that should be written to the map, if it is valid.
     */
    updateMapKey(input) {
        const newKey = input.value.trim();;
        if (this.validateNewKey(newKey)) {
            this.map[newKey] = this.map[this.key] != null ? this.map[this.key] : "";
            delete this.map[this.key];
            this.key = newKey;
        } else {
            alert(`Please enter a unique, valid key for this object.`);
            input.value = this.key;
        } 
    },
    /**
     * Return an HTMLTableCellElement.
     * @return {HTMLTableCellElement}
     */
    getKeyElement() {
        const td = document.createElement("td");
        if (this.key === "") {
            const input = document.createElement("input");
            input.classList.add("modalInput");
            td.appendChild(input);
            input.required = true;
            input.pattern = "[\\s]*[\\S]+.*";
            //if (input.validity.valueMissing) {
            //    input.setCustomValidity("Please fill out this field. Alternatively, delete this row.");
            //}
            const that = this;
            input.addEventListener("change", function() {
                that.updateMapKey(this);
            });
        } else {
            td.textContent = this.key;
        } 
        return td;
    },

    /** 
     * Return true if the value is valid for the Row (based on the key of that Row), otherwise return false.
     * @param {string} value - a value for a corresponding key that should be validated based on the key.
     * @return {boolean}
     */
    validateNewValue(value) {
        if (this.key === "longitude" || this.key === "latitude") {
            return !isNaN(parseFloat(value));
        }
        return true;
    },

    /** 
     * Update a value in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new value that should be written to the map, if the value is valid.
     */
    updateMapValue(input) {
        if (!this.validateCurrentKey()) {
            alert("Please enter a valid key for this row before entering a value.");
            input.value = "";
            return;
        }
        const newValue = input.value.trim();
        if (this.validateNewValue(newValue)) {
            this.map[this.key] = newValue;
        } else {
            alert(`The value "${newValue}" is invalid for for the key "${this.key}" in the table.`);
            input.value = this.map[this.key];
        }
    },
    /** 
     * Return an HTMLTableRowElement.
     * @param {Array} nonModifiableProperties - a hard-coded array of properties that the user shouldn't be able to modify.
     * @return {HTMLTableRowElement}
     */
    getValueElement(nonModifiableProperties) {
        const td = document.createElement("td");
        if (typeof(this.value) === "string") {
            td.textContent = this.value;
            return td;
        } else if (this.value instanceof HTMLElement) {
            td.append(this.value);
            return td;
        } else if (this.value == null) {
            if (this.map == null) {
                return td;
            } else {
                const value = this.key === "" ? "" : this.map[this.key];
                if (nonModifiableProperties.includes(this.key)) {
                    td.textContent = value;
                } else {
                    const input = document.createElement("input");
                    if (this.key === "longitude") {
                        input.dataset.coordinate = "longitude";
                    } else if (this.key === "latitude") {
                        input.dataset.coordinate = "latitude";
                    }
                    input.classList.add("modalInput");
                    td.appendChild(input);
                    const that = this;
                    input.addEventListener("change", function() {
                        that.updateMapValue(this);
                    });
                    input.value = value;
                }
                return td;
            }
        }
        throw new Error("Invalid value was provided for this row");
    },

    /** 
     * TODO: add unit tests
     * Return an HTMLTableRowElement.
     * @param {boolean} deletable - whether or not the returned <td> should have a delete button element child.
     * @param {Array} nonDeletableProperties - a hard-coded array of properties that the user should not be able
     * to delete from a TreeObject.
     * @return {HTMLTableRowElement}
     */
    getDeleteElement(deletable, nonDeletableProperties) {
        const td = document.createElement("td");
        if (deletable === true && !nonDeletableProperties.includes(this.key)) {
            const btn = document.createElement("button");
            btn.innerHTML = "&#9587;"
            btn.setAttribute("class", "modalButton deleteButton"); 
            td.appendChild(btn);
            const that = this;
            btn.addEventListener("click", function() {
                that.delete();
            });
        } 
        return td;
    },

    /**
     * TODO: update unit tests
     * Delete the row from the table. Delete the key from the map, if there was a map.
     */
    delete() {
        this.self.parentElement.removeChild(this.self);
        if (this.map != null) {
            delete this.map[this.key];
        } 
        if (this.element != null) {
            gSelection.remove(this.element);
            const table = document.getElementById(`descriptionTable_${this.element.id}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
            //if (Object.keys(gSelection.getWrapper().tree).length === 0) {
            if (gSelection.getKeys().length === 0) {
                destroyTables(["selectionTable"]);
            }
        }
    },

    /**
     * TODO: add unit tests
     */
    //updateInput() {
    //    //need a direct reference to the input of the row for convenience.
    //}
}

/** 
 * Return a Row that can be appended to a table.
 * 
 * @param {string} key - the key of the row, which must be a property of the map argument if the map argument is not null.
 * @param {string|HTMLElement} - an optional value of the row.
 * @param {Object} map - an optional object that contains the data being manipulated by all of the rows. 
 * @param {boolean} deletable - whether or not the row should have a delete button.
 * @return {Row} - A wrapper object around the HTMLTableRowElement.
 */ 
function createRow({key, value=null, map=null, deletable=false}) {
    const obj = Object.create(rowPrototype);
    obj.validateArguments(arguments[0]);
    obj.key = key;
    obj.value = value;
    obj.map = map;
    obj.self = document.createElement("tr");
    obj.self.append(obj.getDeleteElement(deletable, nonDeletableProperties));
    obj.self.append(obj.getKeyElement());
    obj.self.append(obj.getValueElement(nonModifiableProperties));
    if (arguments[1] != null) {
        obj.element = arguments[1];
    }
    return obj;
}

//**************************************************
// Event listeners
//**************************************************

/**
 * TODO: add unit tests
 */
 function getMoveNodesFunction(tWrapper, tBody=null, tObject=null) {
    if (Object.keys(tWrapper.tree).length > 1 && tBody != null) {
        throw new Error("Cannot update a description table when multiple nodes have been selected to be moved.");
    }
    const moveNodes = function(event) {
        event.stopPropagation();
        const element = document.getElementById("svgContainer");
        //element.removeEventListener("click", moveNodes);
        element.onclick = null;
        element.setAttribute("style", "cursor: default");
        const coords = clickLatLon(event);
        tWrapper.move(coords, {offsetX: gOffsetX, offsetY: gOffsetY});
        // redraw here because we ALWAYS want to redraw after moving. If there was callback, would we want to do something else after moving? No.
        // this will not go on forever. Object.keys() returns an array. That array doesn't change even though the tWrapper changes.
        Object.keys(tWrapper.tree).forEach(key => {
            tWrapper.merge(gTreeWrapper.getSubtreeToRedraw(key));
        });
        createAddableSvgData(tWrapper).drawTo(gViewport);
        if (tObject != null) {
            tObject.data.longitude = tWrapper.tree[tObject.key].longitude;
            tObject.data.latitude = tWrapper.tree[tObject.key].latitude;
        }
        if (tBody != null) {
            Array.from(tBody.getElementsByTagName("input")).forEach(input => {
                if (input.dataset.coordinate === "latitude") {
                    input.value = coords.y + gOffsetY;
                } else if (input.dataset.coordinate === "longitude") {
                    input.value = coords.x + gOffsetX;
                }
            });
        }
    };
    return moveNodes
}

/*
function attachAddListener() {
    if (gSelection.isValidforAdd()) {

    }
}
*/

/**
 * TODO: add unit tests
 */
 function attachMoveSelectionListener() {
    if (gSelection.isValidForMove()) {
        const element = document.getElementById("svgContainer");
        element.setAttribute("style", "cursor: crosshair");
        //destroyTables(["descriptionTables", "selectionTable"]);
        destroyTables(["descriptionTables"]);
        const moveNodes = getMoveNodesFunction(gSelection.getWrapper());
        element.onclick = moveNodes;
        //element.addEventListener("click", moveNodes);
    }
}

function detachListener() {
    const element = document.getElementById("svgContainer");
    element.setAttribute("style", "cursor: default");
    element.onclick = null;
}

//**************************************************
// Initialization
//**************************************************

function attachMouseListeners() {
    document.getElementById("svgContainerWrapper").addEventListener("click", function(event) {
        handleSelection(event);
    });
    document.getElementById("svgContainerWrapper").addEventListener("mousedown", function(event) {
        gDownX = event.clientX;
    });
    document.getElementById("svgContainerWrapper").addEventListener("mouseup", function(event) {
        gDownY = event.clientY;
    });
}

function attachKeyListener() {
    document.body.addEventListener("keydown", function(event) {
        //console.log(event.key);
        switch (event.key) {
            case "m":
                attachMoveSelectionListener();
                break;
            case "-":
                panZoom.zoomOut();
                break;
            case "=":
                panZoom.zoomIn();
                break;
            case "Escape":
                detachListener();
                break;
        }
    });
}

function createInterface() {
    //gTreeWrapper = createTreeWrapper(writeFeeder.tree);
    gTree = createTree(writeFeeder.tree);
    //gTreeWrapper.insertCoordinates(0, 0, 5);
    gTree.insertCoordinates(0, 0, 5);
    gSelection = createSelection();
    //createViewport(gTreeWrapper, document.getElementById("svgContainer"));
    createViewport(writeFeeder.tree, document.getElementById("svgContainer"));
    gViewport = document.getElementsByClassName('svg-pan-zoom_viewport')[0];
    //const svg = createAddableSvgData(gTreeWrapper);
    const svgData = createSvgData(gTree);
    //svg.drawTo(gViewport);
    svgData.drawTo(gViewport);
}

function initializeJQuery() {
    if (window.jQuery != null) {
        applyJQueryStyles();
    } else {
        disableJQueryFunctionality();
    }
}

(function initialize() {
    createInterface();
    initializeJQuery();
    attachMouseListeners();
    attachKeyListener();
    attachHandlers();
    document.getElementById("searchInput").addEventListener("change", getSearchResults);
    document.getElementById('loadingMessage').style.display = 'none'
})();

    //buildFeeder();
    //const t0 = performance.now();

    /* 
    const t1 = performance.now();
    const time = t1 - t0;
    console.log(`Tree rendering time was ${time} ms`);
    */
    
    /*
    setTimeout(function() {
        const deleteSvgData = createDeletableSvgData(gTreeWrapper.tree);
        deleteSvgData.deleteFrom(viewport);
    }, 2000);
    */

//ADD PROMPT TO SAVE CHANGES BEFORE EXIT
{% if showFileMenu %}
	window.onbeforeunload = function(e) {
        if (JSON.stringify(readFeeder) !== JSON.stringify(writeFeeder)) {
            const confirmationMessage = `It looks like you have been editing something. 
            If you leave before saving, your changes will be lost.`;
            return confirmationMessage;
        }
	};
{% endif %}
</script>
<!--<script type='text/javascript' src='/static/distDataValidation.js'></script>-->
{% if spec %}{{ spec | safe }}{% endif %}