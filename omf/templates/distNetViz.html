<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<style >
            /* Define global css variables */
            :root {
                --header-height: 25px;
                --header-padding-top: 10px;
                --header-padding-bottom: 10px;
            }
			* { 
                font-family: Helvetica, Arial, Sans-Serif;
            }
			div.divButton {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				cursor: pointer;
				cursor: hand;
				position:fixed;
				width:30px;
				height:30px;
				text-align:center;
				font-size:30px;
				line-height:30px;
				color:white;
			}
			body {
                /*width: 100%;
                height: 100%;*/
                margin:0px;
            }
			a {
				text-decoration: none;
                color: mediumseagreen;
                /*color: black;*/
			}
            a:visited {
                color: seagreen;
            }

            /* SVG */

            #interfaceContainer {
                position: relative;
            }

            /* This is the element that acts as a hook for svg-pan-zoom.js to attach a viewport, which it creates itself */
			#svgContainer {
                /* width must be 100%, meaning 100% of the document */
				width: 100%; 
                /* height must be manually set to a hard value */
				height: calc(100vh - var(--header-height) - var(--header-padding-bottom) - var(--header-padding-top));
                /* overflow: hidden is set by svg-pan-zoom.js itself. No need to change that here. */
			}
			#saveButton {
				float:right;
			}

            div#loadingMessage {
                width: 100%;
                height: 100%;
				/*background-color: rgba(0,0,0,0.4); */
                background-color: white;
                position: fixed;
                top: 0px;
            }

			/* Load Spinner */

			.loader {
				margin: 60px auto;
				font-size: 10px;
				position: relative;
				text-indent: -9999em;
				border-top: 1.1em solid rgba(255, 255, 255, 0.2);
				border-right: 1.1em solid rgba(255, 255, 255, 0.2);
				border-bottom: 1.1em solid rgba(255, 255, 255, 0.2);
				border-left: 1.1em solid #ffffff;
				-webkit-transform: translateZ(0);
				-ms-transform: translateZ(0);
				transform: translateZ(0);
				-webkit-animation: load8 1.1s infinite linear;
				animation: load8 1.1s infinite linear;
			}
			.loader,
			.loader:after {
				border-radius: 50%;
				width: 10em;
				height: 10em;
			}
			@-webkit-keyframes load8 {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}
			@keyframes load8 {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}

            /**************************************************
            // Header and menu links
            **************************************************/

			#header {
				width:100%;
				height: var(--header-height);
				padding-top: var(--header-padding-top);
				padding-bottom: var(--header-padding-bottom);
				background:black;
                /*position: absolute;*/
				/*min-width:1000px;*/
			}
            #helpDiv a {
                color: white;
            }
			/*#menuLeft{ height:40px; float:left; font-size:medium; color:white; margin-left:5px;}*/
			#menuRight{ 
				/*height:40px;
				font-size:medium;
				color:white;*/
				float:right;
				display:flex;
				/*justify-content: space-between;
				width: 162px*/
			}
			/*#arrow { font-size:8pt; position:absolute; margin-top:2px; margin-left:4px; display:inline; }*/
            .headerDiv {
                margin-right: 15px;
                cursor: pointer;
            }
			ul.menu {
				position: absolute;
				top: 100%;
				left: 0;
				z-index: 1000;
				min-width: 100px;
				padding: 5px 0px 5px 0px;
				margin: 0px;
				list-style: none;
				display: none;
				text-align:left;
				background-color:#F8F8F8;
				padding:0;
				/*border: 1px solid #CCC;*/
				-webkit-border-radius: 5px;
				-moz-border-radius: 5px;
				border-radius: 5px 0px 5px 5px;
				-webkit-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				-moz-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				-webkit-background-clip: padding-box;
			}
			ul.menu.right { 
                right:0;
                left:auto;
                padding:5px 0px 5px 0px;
                overflow-y:auto;
                overflow-x:hidden;
                max-height:550px; 
                cursor: pointer;
            }
			ul.menu.left { right:auto; left:auto; padding:0 0 0 0; }
			ul.menu.center { right:auto; left:-45%; }
			ul.menu li { 
                padding: 4px; 
                }
			ul.menu li:hover { background:green; color:white; }
			ul.menu li:hover a { color:white; }
			ul.menu a { 
                display:block;
                color:black;
                /*padding:4px;*/
                }
			ul.menu a:hover {color:white;}
			ul.menu { display:block; color:black; padding:4px; }
			ul.menu ul.menu:hover, ul.menu:visited:hover { color:white; }
			div.buttonGroup { display:inline-block; position:relative; }
			button.pill {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				color:white;
				font-size:medium;
				width: auto;
				height:35px;
				margin: 0px;
				margin-top:-5px;
				padding:0.3em;
				border-radius: 5px 5px 0 0;
				background-color:#E0E0E0;
				display:inline-block;
				border:none;background:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;
				white-space: nowrap;
				display:inline-block;
                cursor: pointer;
			}
			button.pill:hover{background:transparent;}

            /**************************************************
            // Modal Dialogs
            **************************************************/

            #loadModalTable {
                width: 890px;
            }
            /*#milsoftInput {
                width: 100%;
            }*/
            #progressModalCancel {
                background-color: crimson;
            }
            #progressModal {
                z-index: 1;
            }
            #massAddModal .modalContent {
                width: 400px;
            }
            #climateModal label {
                white-space: nowrap;
            }
            #anonymizeModal {
                white-space: nowrap;
            }
			.modal {
                position: fixed;
                top: 0px;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
				background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
			}
	 		.modalContent {
                padding: 20px;
                border-radius: 10px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: space-evenly;
				background-color: #fefefe;
                /*height: 380px;*/
                overflow: hidden;
			}
            .modalInput {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
                width: 100%;
            }
            .modalInputLine {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
            }
            .modalButton {
                font-size: medium;
                background-color: seagreen;
                -webkit-border-radius: 5px;
                -moz-border-radius: 5px;
                border-radius: 5px;
                border: none;
                color: white;
                cursor: pointer;
                padding: 4px 6px 4px;
            }
            #cancelButton {
                background-color: crimson;
            }
            .modalContent td:nth-of-type(2) {
                text-align: right;
            }
            .modalTableHeader {
                text-align: left;
            }
            .modalTableRow {
                width: 50%;
            }
            .scrollableList {
                overflow: auto;
                height: 240px;
                list-style-type: none;
                margin: 0px 0px 0px 20px;
                padding: 0;
                cursor: pointer;
            }
            .feederItem {
                padding: 5px 5px 5px 5px;
                margin: 10px 0px 10px 0px;
            }
            .feederItem:hover {
                color: white;
                background-color: green;
            }
            /*
            input:valid {
                border: 1px solid white; 
            }
            */
            input:invalid {
                /*Aborder: 1px solid red;*/
            }            

            /* Tree tables */

            .buttonRow {
                /*text-align: center;*/
            }
            .buttonRow button {
                margin-right: 5px;
            }
            /*
            .treeTable {
                background-color: white; 
            }
            .treeTable tr {
            }
            .treeTable tr:last-child {
                border: 0px;
            }
            */
            thead td {
                
            }
            .tableInput {
                font-size: small;
                background-color: gainsboro;
                padding: 3px;
                border: 0px;
            }
            .deleteButton {
                background-color: #CC0000;
                /*padding: 1px 7px 1px 7px;*/
            }
            /* TODO: might need to delete this rule */
            .editButton {
                font-size: small;
                /*width: 100%;*/
            }

			/* dataTable */

            #descriptionTables {
                position: absolute;
                top: 0px;
                height:0px;
            }

            #selectionTable {
                position: absolute;
                top: 0px;
                height:0px;
            }

            .formContainer {
				/*position: fixed;*/
				/*top: 55px;*/
                height:0px;
				/*right: 5px;*/
            }

            /* Don't set overflow-y to hidden */
			.dataTable {
                position: fixed;
				top: 55px;
				border:1px solid black;
				border-collapse: collapse;
                display: inline-block;
                overflow-x: hidden;
				max-height: 90vh;
			}
            .dataTable tr {
                border-bottom: 1px solid black;
            }
            .dataTable tr:last-child {
                border: 0px;
            }
            /*.dataTable p {
                margin: 0px;
            }*/
            .tableTitle {
                background-color: black;
                color: white;
            }
			tbody {
				/*border: 1px solid black;*/
                border-collapse: collapse;
			}
			td {
				background:white;
				padding: 5px;
				border-collapse: collapse;
			}
			th {
				/*font-weight: normal;*/
				/*background:black;*/
				/*color:white;*/
				padding: 5px;
			}
			/*
            #editButtonRow button {
				font-size: small;
				color: white;
				background: seagreen;
				padding: 5px;
				border-radius: 5px;
				width: 100%;
			}
            */
            /*
			#editButtonRow button:hover {
				outline:0;
				outline: none; 
				background:mediumseagreen;
			}
            */
        </style>
        <link rel="stylesheet" href="/static/jquery-ui.min.css">
        <script type="text/javascript" src="/static/jquery.js"></script>
        <script type="text/javascript" src="/static/jquery-ui.min.js"></script>
		<script type='text/javascript' src='/static/svg-pan-zoom.js'></script>
		{% if jasmine %}{{ jasmine | safe }}{% endif %}
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Largest.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Norfork.js'></script> -->
	</head>
	<!--<body onkeypress='hotkeys()'>-->
    <body>
        <div id="interfaceContainer">
            <div id="loadingMessage">
                <p style="font-size:60pt; text-align:center; width:100%;">Feeder Loading...</p>
            </div>
            <div id="descriptionTables"></div>
            <div id="selectionTable"></div>
            <!-- Controls -->
            <div style='background:dimgrey; top:55px; left:5px' class='divButton' onclick='window.panZoom.zoomIn()' title='Zoom In'>+</div>
            <div style='background:dimgrey; top:95px; left:5px' class='divButton' onclick='window.panZoom.zoomOut()' title='Zoom Out'>-</div>
            <div style='background:dimgrey; top:135px; left:5px' class='divButton' onclick='window.panZoom.reset()' title='Reset Zoom'>R</div>
            <div style='background:dimgrey; top:175px; left:5px;' class='divButton' onclick='scaleTo(parseFloat(prompt("Scale line thickness by this multiple:", scaleLevel)))' title='Scale To'>S</div>
            <!-- <div style='background:navy; top:215px; left:5px' id='saveLink' class='divButton' onclick='saveSvg()' title='Save File' download>S</div> -->
            <!-- Menu Bar -->
            <div id='header'>
                <div id="menuRight">
                    <div id="helpDiv" class="headerDiv">
                        <div class="buttonGroup">
                            <button class='pill' type = 'submit'>
                                <a id='helpButton' href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit' target='_blank'>Help</a>
                            </button>
                        </div>
                    </div>
                    <div id="editDiv" class="headerDiv">
                        <div class="buttonGroup">
                            <button id="addOps" class='pill' onclick='dropPill(this, "Edit")'>Edit &#x25BE;</button>
                            <ul id="editMenu" class='menu right' style="display: none">
                                <!--<li>Zoom To Fit</li>-->
                                <!--<li>Zoom Reset</li>-->
                                <li>Static Loads to Houses</li>
                                <li data-web>Scada Loadshapes...</li>
                                <li data-web>Add AMI Profiles...</li>
                                <li>Find...</li>
                                <li>Mass Add...</li>
                                <li>Mass Edit...</li>
                                <li>Attachments...</li>
                                <li data-web>Climate...</li>
                                <li data-web>Anonymization...</li>
                            </ul>
                        </div>
                    </div>
                    <div id="addDiv" class="headerDiv">
                        <div class="buttonGroup">
                            <button id="addOps" class='pill' onclick='dropPill(this, "Add")'>Add &#x25BE;</button>
                            <ul id='componentList' class='menu right' style="display: none">
                        </div>
                    </div>
                    {% if showFileMenu %}
                    <div id="fileDiv" class="headerDiv">
                        <div class='buttonGroup'>
                            <button id="fileOps" class='pill' onclick='dropPill(this, "File")'>File &#x25BE;</button>
                            <ul id='fileMenu' class='menu right' style="display: none">
                                <li data-web>Save</li>
                                <li>View Raw Data</li>
                                <li data-web>Rename</li>
                                <li data-web>Load from Model...</li>
                                <li data-web>New Blank Feeder...</li>
                                <li data-web>Windmil Conversion...</li>
                                <li data-web>GridLAB-D Conversion...</li>
                                <li data-web>CYMDIST Conversion...</li>
                            </ul>
                        </div>
                    </div>
                    {% endif %}
                </div>
            </div>
            <!-- Svg container -->
            <div id="svgContainerWrapper" style="height: auto;">
                <svg id='svgContainer' xmlns='http://www.w3.org/2000/svg'>
                    <style type="text/css">
                        <![CDATA[
                        .house {fill:blue;}
                        .triplex_meter {fill:orange;}
                        .underground_line {stroke:gray;}
                        .transformer {stroke:orange;}
                        .regulator {stroke:red;}
                        line {stroke:black;}
                        line.parentChild {stroke:LightGrey;}
                        circle {stroke:white; fill:gray;}
                        line.selected, circle.selected {stroke:lime;}
                        ]]>
                    </style>
                </svg>
            </div>
            <!-- Modals -->
            <div id='findModal' class="modal" style="display: none">
                <div class='modalContent'>
                    <table>
                        <tr>
                            <td>Term</td>
                            <td><input id='searchInput' type='text' value="Enter a search term" class="modalInput"></td>
                            <td id="searchCount"></td>
                        </tr>
                        <tr>
                            <td><button id="findPrevious" class="modalButton">Previous</button></td>
                            <td><button id="findNext" class="modalButton">Next</button></td>
                            <td><button class="modalButton" onclick='toggleElementDisplay("findModal")'>Cancel</button></td>
                        </tr>
                    </table>
                </div>
            </div>
            <div id="progressModal" class="modal" style="display: none">
                <div class="modalContent">
                    <img src="/static/spinner.gif">
                    <h2>text...</h2>
                    <button class="modalButton" id="progressModalCancel">Cancel</button>
                </div>
            </div>
            <div id="loadModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table id="loadModalTable">
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Public Feeders</th>
                                <th class="modalTableHeader modalTableRow">My Feeders</th>
                            </tr>	
                            <tr>
                                <td class="modalTableRow"> 
                                    <ul id="publicFeederList" class="scrollableList"></ul>
                                </td>
                                <td class="modalTableRow"> 
                                    <ul id="userFeederList" class="scrollableList"></ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <button onclick="toggleElementDisplay('loadModal')" class="modalButton">Cancel</button>
                </div>
            </div>
            <div id="blankFeederModal" class="modal" style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'blankFeederForm'}); return false;"
                    action="/newBlankFeeder/{{thisOwner}}" id="blankFeederForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <input type='hidden' name='referrer' value='distribution'/>
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Blank Feeder</th>
                                </tr>
                                <tr>
                                    <td><label for="blankFeederInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="blankFeederInput" name='feederNameNew' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('blankFeederModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Create</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='milsoftModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'milsoftForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'milsoftInput'}); return false;"
                    action="/milsoftImport/{{thisOwner}}" id="milsoftForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Milsoft Conversion</th>
                                </tr>
                                <tr>
                                    <td><label for="milsoftInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="milsoftInput" name='feederNameM' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Data File (.std)</td>
                                    <td><input type='file' required id="stdFile" name='stdFile' accept='.std' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td>Equipment File (.seq)</td>
                                    <td><input type='file' required id="seqFile" name='seqFile' accept='.seq' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('milsoftModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table> 
                    </form>
                </div>
            </div>
            <div id='gridlabdModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'gridlabdForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'gridlabdInput'}); return false;"
                    action="/gridlabdImport/{{thisOwner}}" id="gridlabdForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">GridLab-D Conversion</th>
                                </tr>
                                <tr>
                                    <td><label for="gridlabdInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="gridlabdInput" name='feederNameG' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Data File (.glm)</td>
                                    <td><input type='file' required id="csvFile" name='glmFile' accept='.glm' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('gridlabdModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='cymeModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'cymeForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'cymeInput'}); return false;"
                    action="/cymeImport/{{thisOwner}}" id="cymeForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Cyme Conversion</th>
                                </tr>
                                <tr>
                                    <td><label for="cymeInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="cymeInput" name='feederNameC' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Network File (.mdb)</td>
                                    <td><input type='file' required id="mdbNetFile" name='mdbNetFile' accept='.mdb' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('cymeModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id="scadaModal" class="modal" style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'scadaForm', pollUrl:'/checkScadaLoadshape/{{thisModelName}}'}); return false;"
                    action="/scadaLoadshape/{{thisOwner}}/{{thisFeederName}}" id="scadaForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Scada Loadshapes</th>
                                    <th style='float:right;'>
                                        <a href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit#scada-loadshapes' target='_blank'>Format Help</a>
                                    </th>
                                </tr>
                                <tr>
                                    <td>File containing Scada load data (.csv)</td>
                                    <td><input type='file' required id="scadaFile" name='scadaFile' accept='.csv' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td colspan='100%'>Note: Model "Simulation Start Date" should lie within the Scada load's dates.</td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('scadaModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='amiModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'amiForm', pollUrl:'/checkLoadModelingAmi/{{thisModelName}}'}); return false;"
                    action="/loadModelingAmi/{{thisOwner}}/{{thisFeederName}}" id="amiForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">AMI Profiles</th>
                                    <th style='float:right;'>
                                        <a href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit' target='_blank'>Format Help</a>
                                    </th>
                                </tr>
                                <tr>
                                    <td>File containing AMI load data (.csv)</td>
                                    <td><input type='file' required id="amiFile" name='amiFile' accept='.csv' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td colspan='100%'>Note: Model "Simulation Start Date" should lie within the AMI profiles's dates.</td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('amiModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='massAddModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="massAdd(); toggleElementDisplay('massAddModal'); return false;">
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Mass Add</th>
                                </tr>
                                <tr>
                                    <td>Add component:</td>
                                    <td><select id='componentSelect'></select></td>
                                </tr>
                                <tr>
                                    <td>To each:</td>
                                    <td><select id='massAddTargetSelect'></select></td>
                                </tr>
                                <tr>
                                    <td>With probability for each attachment (float between 0.0 and 1.0):</td>
                                    <td><input type='text' pattern="^(1.0)|(0?(\.\d+))$" required id='percent' value='1.0' class="modalInput"/></td>

                                </tr>
                                <tr>
                                    <td><button onclick="toggleElementDisplay('massAddModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Apply</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='massEditModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader">Mass Edit</th>
                            </tr>
                            <tr>
                                <td>For each object of type</td>
                                <td><select id='massEditTargetSelect'></select></td>
                                <td>with attribute</td>
                                <td><input type='text' id='massEditAttribute' class="modalInput"></td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="addTo">Add value to attribute</td>
                                <td><input type='text' id='addToValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="delete">Delete Attribute</td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="change">Change attribute to</td>
                                <td><input type='text' id='changeValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            </tr>
                            <tr>		
                                <td><input type="radio" name="attributeOperation" value="multiplyBy">Multiply attribute by</td>
                                <td><input type='text' id='multiplyValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                                <td style="text-align: center" >and add</td>
                                <td><input type='text' id='andAddValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td>Or</td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="addAttribute"> Add new attribute</td>
                                <td><input type='text' id='newAttributeKey' class="modalInput"></td>
                                <td style="text-align: center">with value</td>
                                <td><input type='text' id='newAttributeValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td colspan="2">
                                    <button onclick="toggleElementDisplay('massEditModal')" class="modalButton" style="float: right">Cancel</button>
                                </td>
                                <td>
                                    <button onclick="massEdit(); toggleElementDisplay('massEditModal');" class="modalButton" style="float: left">Apply</button>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id='attachmentsModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <table>
                        <tbody>
                            <tr>
                                <td><select id='attachmentSelect'></select></td>
                            </tr>
                            <tr>
                                <td><button onclick="toggleElementDisplay('attachmentsModal')" class="modalButton">Cancel</button></td>
                                <td><button onclick="toggleElementDisplay('attachmentsModal'); editAttachment()" class="modalButton">Select</button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id='editAttachmentModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <table>
                        <tbody>
                            <tr>
                                <td id='attachmentTd'></td>
                            </tr>
                            <tr>
                                <td>
                                    <textarea rows='25' cols='80' id='editAttachmentBox'></textarea>
                                </td>
                            </tr>
                            <tr>
                                <td><button onclick="toggleElementDisplay('editAttachmentModal')" class="modalButton">Cancel</button></td>
                                <td><button onclick="saveAttachment(); toggleElementDisplay('editAttachmentModal');" class="modalButton">Save</button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id='climateModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'climateForm', pollUrl:'/checkClimateChange/{{thisOwner}}/{{thisModelName}}'}); return false;"
                    action="/climateChange/{{thisOwner}}/{{thisFeederName}}" id="climateForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <!--<input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>-->
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Climate Change</th>
                                </tr>
                                <tr>
                                    <td>
                                        <input id='historicalImport' type='radio' name='climateImportOption' value='historicalImport'>
                                        <label for='historicalImport'>Historical Weather</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td><label for='startDate'>Start Date (YYYY-MM-DD):</label></td>
                                    <td><input id='startDate' type='text' name='startDate' pattern='^\d{4}-\d{2}-\d{2}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td><label for='endDate'>End Date (YYYY-MM-DD):</label></td>
                                    <td><input id='endDate' type='text' name='endDate' pattern='^\d{4}-\d{2}-\d{2}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td><label for='airport'>Airport Code:</label></td>
                                    <td><input id='airport' type='text' name='airport' pattern='^[A-Z]{3}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td>
                                        <input id='tmyImport' type='radio' name='climateImportOption' value='tmyImport'>
                                        <label for='tmyImport'>tmy Import</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td><label for='zipCode'>Zip Code:</label></td>
                                    <td><input id='zipCode' type="text" name="zipCode" pattern='^\d{5}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('climateModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Apply</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='anonymizeModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'anonymizeForm', pollUrl:'/checkAnonymize/{{thisOwner}}/{{thisModelName}}'}); return false;"
                    action='/anonymize/{{thisOwner}}/{{thisFeederName}}' id="anonymizeForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <!--<input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>-->
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr><th>Anonymization</th></tr>
                                <tr><th class="modalTableHeader">Names and labels:</th></tr>
                                <tr>
                                    <td>
                                        <select name='anonymizeNameOption'>
                                            <option value="noChange">No change</option>
                                            <option value="pseudonymize">Pseudonymize</option>
                                            <option value="randomize">Randomize</option>
                                        </select>
                                    </td>
                                </tr>
                                <tr><th class="modalTableHeader">Locations:</th></tr>
                                <tr>
                                    <td>
                                        <input type='radio' id='noChange' name='anonymizeLocationOption' value='noChange' checked>
                                        <label for='noChange'>No Change</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='radio' id='translation' name='anonymizeLocationOption' value='translation'>
                                        <label for='translation'>Translate</label>
                                    </td>
                                </tr>
                                <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='translateRight' class="modalInputLine"> [ft] to the right and</td></tr>
                                <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='translateUp' class="modalInputLine"> [ft] up with a</td></tr>
                                <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='rotate' class="modalInputLine"> [degree] rotation.</td></tr>
                                <tr>
                                    <td>
                                        <input type='radio' id='randomize' name='anonymizeLocationOption' value='randomize'>
                                        <label for='randomize'>Random (Force Layout)</label>
                                    </td>
                                </tr>
                                <tr><th class="modalTableHeader">Electrical properties:</th></tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='modifyLengthSize' name='modifyLengthSize' value='modifyLengthSize'>
                                        <label for='modifyLengthSize'>Modify conductor length and cable size</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='smoothLoadGen' name='smoothLoadGen' value='smoothLoadGen'>
                                        <label for='smoothLoadGen'>Smooth AMI Loadshapes</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='shuffleLoadGen' name='shuffleLoadGen' value='shuffleLoadGen'>
                                        <label for='shuffleLoadGen'>Shuffle loads and generators:</label>
                                        <input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='shufflePerc' class="modalInputLine"> [%]</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='addNoise' name='addNoise' value='addNoise'>
                                        <label for='addNoise'>Add noise:</label>
                                        <input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='noisePerc' class="modalInputLine"> [%]</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <button type="button" onclick="toggleElementDisplay('anonymizeModal')" class="modalButton">Cancel</button>
                                        <button type="submit" class="modalButton" style="float: right">Apply</button>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <!-- Modals-->
        </div>
	</body>
</html>
<script id='componentsInsert'>const gComponents = {% if components %}{{ components | safe }}{% else %}null{% endif %}; 
</script>
<script id='feederInsert'>const readFeeder = {% if thisFeederData %}{{ thisFeederData | safe }}{% else %}null{% endif %}; 
</script>
<script id='panZoomInsert'>
</script>
<script type='text/javascript'>
//"use strict";
let thisFeederName = "{% if thisFeederName %}{{ thisFeederName | safe }}{% else %}null{% endif %}";
const thisFeederNum = {% if thisFeederNum %}{{ thisFeederNum | safe }}{% else %}null{% endif %}; 
const thisModelName = "{% if thisModelName %}{{ thisModelName | safe }}{% else %}null{% endif %}"; 
const thisOwner = "{% if thisOwner %}{{ thisOwner | safe }}{% else %}null{% endif %}"; 
const publicFeeders = {% if publicFeeders %}{{ publicFeeders | safe }}{% else %}null{% endif %};
const userFeeders = {% if userFeeders %}{{ userFeeders | safe }}{% else %}null{% endif %}; 
const writeFeeder = deepCopy(readFeeder);
// The global TreeWrapper can only be created after the entire file has been parsed.
let gTreeWrapper; 
let gViewport; 
let gLonOffset = null;
let gLatOffset = null;
// Scale that all SVG objects are drawn at
let scaleLevel = 1.0; 

//**************************************************
// Selection Interface
//**************************************************

/* We need this only because the 'to' and 'from' properties of a line depend on which element was selected first.
We can't accomplish that purely with document.getElementsByClassName("selected") becauese the order of that array
depends on how elements are ordered in the DOM, not on the order in which the user clicked.
*/
let isSelected;
let removeSelected;
let addSelected;
let emptySelected;
let getSelectedElements;
let getSelectedWrapper;
let validateSelected;
/**
 * TODO: add unit tests, maybe delete this because node selection for lines happens afterwards now. Maybe I can add components
 * both ways, in which case this would still be needed?
 */
{
    let gSelectedElements = [];
    isSelected = function(element) {
        return element.classList.contains("selected");
    };
    removeSelected = function(element) {
        if (element.classList.contains("selected")) {
            element.classList.remove("selected");
            const idx = gSelectedElements.findIndex(e => { return e === element; });
            if (idx < 0) {
                throw new Error("The previously selected element was not found in the selection array and couldn't be removed");
            } 
            gSelectedElements.splice(idx, 1);
        }
    };
    addSelected = function(element) {
        if (!element.classList.contains("selected")) {
            element.classList.add("selected");
            gSelectedElements.push(element);
        }
    };
    emptySelected = function() {
        Array.from(document.getElementsByClassName("selected")).forEach(e => {
            e.classList.remove("selected");
        });
        gSelectedElements = [];
    };
    
    /**
     * Return true if the selected elements are valid for performing an operation with an object of the given type, otherwise
     * return false.
     * @param {string} type - the type of the object used to modify or be modified by the selection. 
     * @return {boolean}
     */
    validateSelected = function({type=null, operation=null}) {
        /* I want to add a child component to stuff, but I can only add to childNodes and independentNodes.
        I want to add a line component, but I can only add lines between childNodes and independentNodes
        I want to add an independent or config component, but 
        I want to move objects, but I can only move configNodes, childNodes, and independentNodes.
        */ 
    }
    /**
     * Return an array of HTMLElements that have the "selected" class.
     */
    getSelectedElements = function() {
        return gSelectedElements;
    };

    /**
     * Return a TreeWrapper that contains tree objects that correspond to HTMLElements with the "selected" class.
     */
    getSelectedWrapper = function() {
        const tWrapper = createTreeWrapper();
        gSelectedElements.forEach(e => {
            tWrapper.add(e.id, gTreeWrapper);            
        });
        return tWrapper;
    };
}

function saveSvg() {
	// Create an SVG that can be saved.
	alert('We are redirecting you to a static version of the SVG that you can save as a .svg file.')
	var svg = document.getElementById('svgContainer').outerHTML
	var win = window.open()
	win.document.write(svg)
}

function downloadTextFile() {
	// WARNING! Performance is very bad because the JSON is enormous! This can hang your browser!
	alert('We are opening a window with JSON in it that you can save as a .json file.')
	var modJson = JSON.stringify(writeFeeder);
	var win = window.open();
	win.document.write(modJson);
}

/**
 * TODO: add unit tests
 */
function createViewport(treeWrapper, svgContainer) {
    const tree = treeWrapper.tree;
    const keys = Object.keys(tree);
    // Set the longitude and latitude to be within the bounds of the provided data
    const firstKey = keys.find(key => {
        return tree[key].longitude !== undefined && tree[key].latitude !== undefined;
    });
    let minLon = parseFloat(tree[firstKey].longitude);
    let maxLon = minLon;
    let minLat = parseFloat(tree[firstKey].latitude);
    let maxLat = minLat;
    /* Find the minimum and maximum longitudes and latitudes. That's not good enough. I need to find a RANGE of values
    for each and scale the viewport to the RANGE
    */
    keys.forEach(key => {
        let lon = tree[key].longitude;
        let lat = tree[key].latitude;
        if (lon !== undefined && lat !== undefined) {
            lon = parseFloat(lon);
            lat = parseFloat(lat);
            if (lon < minLon) {
                minLon = lon;
            }
            if (lon > maxLon) {
                maxLon = lon;
            }
            if (lat < minLat) {
                minLat = lat;
            }
            if (lat > maxLat) {
                maxLat = lat;
            }
        }
    });
    //const translatedMaxLon = maxLon - minLon;
    const translatedMaxLon = (maxLon - minLon);
    gLonOffset = minLon;
    const translatedMaxLat = maxLat - minLat;
    gLatOffset = minLat;
    // Create the viewport
    svgContainer.setAttribute('viewBox',`0 0 ${translatedMaxLon} ${translatedMaxLat}`);
	window.panZoom = svgPanZoom('#svgContainer', {
        /* Override the default values set by 'optionsDefaults' in svg-pan-zoom.js */
        dblClickZoomEnabled: false,
        zoomScaleSensitivity: 0.2,
        minZoom: 0.25,
		maxZoom: 100
    });
}

//**************************************************
// Click event functions
//**************************************************



/**
 * TODO: add unit tests
 * Listener on the SVG object that handles user clicks.
 */
function svgClick(downEvent, upEvent) {
    if (downEvent.clientX !== upEvent.clientX || downEvent.clientY !== upEvent.clientY) {
		// Ignore drags, those should be handled by svg-panzoom.
        //return;
    }
    const element = downEvent.target;
    if (downEvent.altKey && element.id !== "svgContainer" && !element.classList.contains("parentChild")) {
        //destroyTables(["descriptionTables", "selectionTable"]);
        destroyTables(["selectionTable"]);
        if (isSelected(element)) {
            removeSelected(element);
            //Copied from rowPrototype.delete(). Refactor needed
            const table = document.getElementById(`descriptionTable_${element.id}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
        } else {
            addSelected(element);
        }
        let ids = Object.keys(getSelectedWrapper().tree);
        if (ids.length > 0) {
            const table = createSelectionTable(ids, gTreeWrapper);
            document.getElementById("selectionTable").appendChild(table);
        } 
    } else if (!downEvent.altKey) {
        emptySelected();
        destroyTables(["descriptionTables", "selectionTable"]);
        //destroyTables(["selectionTable"]);
        if (element.id !== "svgContainer" && !element.classList.contains("parentChild")) {
            addSelected(element);
            const table = createDescriptionTable(element.id, gTreeWrapper);
            document.getElementById("descriptionTables").appendChild(table);
        } 
    }
}

function hotkeys() {
	// Handle hotkey presses.
	let x;
	if (window.event) {
		// IE8 and earlier
		x = event.keyCode
	} else if (event.which) {
		// IE9/Firefox/Chrome/Opera/Safari
		x = event.which
	}
	var keychar = String.fromCharCode(x);
	if (event.target.type !== 'text') {
		// Dispatch the key:
		if (keychar == '-') {
			window.panZoom.zoomOut()
		} else if (keychar == '=') {
			window.panZoom.zoomIn()
		} else if (keychar =='m') {
			moveNode()
		}
	}
}

function scaleTo(x) {
	// Scale the thickness of all lines and size of all circles. This helps user see details.
	scaleLevel = x
	if (!x) {
		return
	}
	const circles = document.getElementsByTagName('circle')
	const lines = document.getElementsByTagName('line')
	// Scale Circles
	for (let i = 0; i < circles.length; i++) {
		circles[i].setAttribute('r', 2*x)
		circles[i].setAttribute('stroke-width', 0.5*x)
	}
	// Scale Lines
	for (let i = 0; i < lines.length; i++) {
		if (lines[i].getAttribute('class').indexOf('p2') !== -1) {
			lines[i].setAttribute('stroke-width', 2*x)
		}
		else if (lines[i].getAttribute('class').indexOf('p3') !== -1) {
			lines[i].setAttribute('stroke-width', 3*x)
		}
		else if (lines[i].getAttribute('class').indexOf('parentChild') !== -1) {
			lines[i].setAttribute('stroke-width', 0.5*x)
		}
		else {
			lines[i].setAttribute('stroke-width', x)
		}
	}
}

function dropPill(thisButton, name) { // eslint-disable-line
	// This function is used to make the dropdown menus work.
	thisButton.style.color= 'black'
	thisButton.style.background= '#F8F8F8'
	thisButton.style.textAlign = 'left'
	thisButton.nextSibling.nextSibling.style.display = 'inline-block'
	thisButton.innerHTML = name + ' &#x25B4;'
	function clickCloseEvent() {
		thisButton.nextSibling.nextSibling.style.display = 'none'
		thisButton.innerHTML = name + ' &#x25BE;'
		this.removeEventListener('click', arguments.callee, true)
		thisButton.style.color= 'white'
		thisButton.style.background= 'transparent'
		if (window.event.toElement==thisButton) {event.stopPropagation()}
	}
    //document.body.addEventListener('click', clickCloseEvent, true)
    document.getElementById("interfaceContainer").addEventListener('click', clickCloseEvent, true)
}

/*function clickCloseEvent(labelName, buttonName) { // eslint-disable-line
	// This event allows users to close the dropdown menus.
	var thisButton = document.getElementById(buttonName);
	//thisButton.nextSibling.nextSibling.style.display = 'none'
	thisButton.nextElementSibling.style.display = "none";
	thisButton.innerHTML = labelName + ' &#x25BE;';
	//this.removeEventListener('click', arguments.callee, true);
	//if (window.event.toElement==thisButton) {event.stopPropagation()}
}*/

function clickLatLon(event) {
	//Returns real Lat/Long of a click event, used in the moveBus function
	//const sizes = window.panZoom.getSizes();
    //const zoom = sizes.realZoom;
	const pan = window.panZoom.getPan();
    const zoom = panZoom.getSizes().realZoom;
	const svg = document.getElementById('svgContainer');
	let pt = svg.createSVGPoint();
	pt.x = event.clientX;
	pt.y = event.clientY;
	pt = pt.matrixTransform(svg.getScreenCTM().inverse());
	let x = pt.x;
	let y = pt.y;
	//x = (x - pan.x) / zoom;
	//y = (y - pan.y) / zoom;
	//return [x,y];
	const coords = {
		x: (x - pan.x) / zoom,
		y: (y - pan.y) / zoom
	};
	return coords;
}

//**************************************************
// Find modal interface
//**************************************************

/**
 * TODO: add unit tests
 */
function getSearchResults() {
    const tree = gTreeWrapper.tree;
    const keys = getMatchingKeys(this.value, tree);
    document.getElementById("searchCount").textContent = `hits: ${keys.length}`;
    const nextButton = document.getElementById("findNext");
    const previousButton = document.getElementById("findPrevious");
    destroyTables(["descriptionTables"]);
    if (keys.length === 0 || this.value === "") {
        alert(`No results found for term: "${this.value}"`)
        const feedback = function() {
            alert("Please enter a new term to search for"); 
        }
        nextButton.onclick = feedback;
        previousButton.onclick = feedback;
        return;
    }
    const upperIndex = keys.length - 1;
    let idx = 0;
    document.getElementById("descriptionTables").appendChild(createDescriptionTable(tree[keys[idx]], gTreeWrapper));
    viewElement(keys[idx]);
    nextButton.onclick = function() {
        idx++;
        if (idx > upperIndex) {
            idx = 0;
        }
        destroyTables(["descriptionTables"]);
        document.getElementById("descriptionTables").appendChild(createDescriptionTable(tree[keys[idx]], gTreeWrapper));
        viewElement(keys[idx]);
    }
    previousButton.onclick = function() {
        idx--;
        if (idx < 0) {
            idx = upperIndex;
        }
        destroyTables(["descriptionTables"]);
        document.getElementById("descriptionTables").appendChild(createDescriptionTable(tree[keys[idx]], gTreeWrapper));
        viewElement(keys[idx]);
    }
}

/**
 * TODO: add unit tests
 */
function getMatchingKeys(term, tree) {
    const keys = [];
    for (let key in tree) {
        // Only add the key if it represents an object that was drawn
        if ((tree[key].latitude != null && tree[key].longitude != null) ||
        (tree[key].to != null && tree[key].from != null)) {
            for (let propertyKey in tree[key]) {
                let propertyVal = tree[key][propertyKey];
                if (typeof(propertyVal) !== "string") {
                    propertyVal += "";
                }
                if (propertyKey.toLowerCase().includes(term.toLowerCase())) {
                    keys.push(key);
                    break;
                } else if (propertyVal.toLowerCase().includes(term.toLowerCase())) {
                    keys.push(key);
                    break;
                }
            }
        }
    }
    return keys;
}

/** 
 * TODO: add unit tests
 */
function viewElement(key) {
    emptySelected();
    const element = document.getElementById(key);
    addSelected(element);
   let x, y;
    if (element.getAttribute("cx") != null && element.getAttribute("cy") != null) {
        x = element.getAttribute("cx");
        y = element.getAttribute("cy");
    } else {
		x = (parseFloat(element.getAttribute('x1')) + parseFloat(element.getAttribute('x2'))) / 2;
		y = (parseFloat(element.getAttribute('y1')) + parseFloat(element.getAttribute('y2'))) / 2;
    }
    // I can't make this work 
    //panZoom.zoomAtPoint(2, {x: x, y: y});
    // Do this instead 
	panZoom.pan({x:0, y:0})
	var realZoom = window.panZoom.getSizes().realZoom
	var width = window.panZoom.getSizes().width / 2
	var height = window.panZoom.getSizes().height / 2
    panZoom.pan({x:width - (x * realZoom), y:height - (y * realZoom)})
    panZoom.zoom(15/scaleLevel);
}

//**************************************************
// jQuery handling for distNetViz.py
//**************************************************

/** 
 * TODO: add unit tests?
 * If this interface is being used as a file, we can't import jQuery with <script> so we can't use jQuery
 * styling. This function is only called when jQuery is available.
 */
 function applyJQueryStyles() {
    // Make stuff draggable
    $("#findModal .modalContent").draggable();
    $("#progressModal .modalContent").draggable();
    $("#loadModal .modalContent").draggable();
    $("#blankFeederModal .modalContent").draggable();
    $("#milsoftModal .modalContent").draggable();
    $("#gridlabdModal .modalContent").draggable();
    $("#cymeModal .modalContent").draggable();
    $("#scadaModal .modalContent").draggable();
    $("#amiModal .modalContent").draggable();
    $("#massAddModal .modalContent").draggable();
    $("#massEditModal .modalContent").draggable();
    $("#attachmentsModal .modalContent").draggable();
    // Position the description table depending on whether or not it is draggable
    //document.getElementById("descriptionTable").removeAttribute("style");
    //document.getElementById("descriptionTable").style.left = "70vw";
}

/** 
 * Ajax requests depend on jQuery, so any function that uses $.ajax() cannot be used if this interface
 * is loaded as a file. This function is called when jQuery isn't available.
 */
function disableJQueryFunctionality() {
    //Hide stuff that doesn't work in distNetViz.py
    Array.from(document.querySelectorAll("[data-web]")).forEach(li => {
        li.remove();
    });
}

//**************************************************
// Header menu functions
//**************************************************

function attachHandlers() {
    addComponents();
    attachFeederList(document.getElementById("publicFeederList"), publicFeeders, "public");
    attachFeederList(document.getElementById("userFeederList"), userFeeders, thisOwner);
    addFileMenuHandlers();
    addEditMenuHandlers();
}

/** 
 * TODO: add unit-tests, add a click listener instead of doing it backwards!
 * Fill menu of "Add" button and add its handler functions.
 */
function addComponents() {
	const ul = document.getElementById("componentList");
    const select = document.getElementById("componentSelect");
	for (let name in gComponents) {
		const li = document.createElement("li");
		li.textContent = name;
		li.addEventListener("click", function() {
            const tObject = createTreeObject(gComponents[name], gTreeWrapper);
            const tWrapper = getSelectedWrapper();
            if (updateTreeObject(tObject, tWrapper)) {
                const svg = createAddableSvgData(gTreeWrapper.insert(tObject));
                svg.drawTo(gViewport);
            } else {
                alert(getSelectionErrorMessage(getType(tObject.data)));
            }
		});
		ul.appendChild(li);
        select.innerHTML += `<option value=${name}>${name}</option>`;
	}
}

/**
 * TODO: add unit tests, get rid of TreeObject.update(), get rid of this entirely
 * Return true if the TreeObject argument was successfully updated based on the selected HTMLElements, otherwise return false.
 */
function updateTreeObject(tObject, tWrapper) {
    const keys = Object.keys(tWrapper.tree);
    const type = getType(tObject.data);
    switch (type) {
        case "line":
            if (keys.length === 2 && 
                keys.every(key => {
                    let objectType = getType(tWrapper.tree[key]);
                    // Can only add a line between childNodes and/or independentNodes
                    return objectType === "childNode" || objectType === "independentNode"
                })
            ) {
                tObject.update({to: tWrapper.tree[keys[0]], from: tWrapper.tree[keys[1]]});
                return true
            }
            break;
        case "configurationNode":
            break;
        case "childNode":
            if (keys.length === 1) {
                const objectType = getType(tWrapper.tree[keys[0]]);
                if (objectType === "childNode" || objectType === "independentNode") {
                    // Can only add a childNode to another childNode or an independentNode
                    tObject.update({parent: tWrapper.tree[keys[0]]});
                    return true
                }
            } 
            break;
        case "independentNode":
            break;
    }
    return false;
}

/**
 * TODO: add unit tests
 */
function getSelectionErrorMessage(type) {
    let msg;
    switch (type) {
        case "line":
            msg = "Please select exactly 2 circles to insert this object. These circles must not be configuration objects. "; 
            break;
        case "childNode":
            msg = "Please select exactly 1 circle to act as the parent of this object. This circle must not be a configuration object. ";
            break;
        case "configurationNode":
            msg = "Please?";
            break;
        case "independentNode":
            msg = "what?";
            break;
    }
    msg += "Select an object by holding the 'alt' key and left clicking the object. After selecting the correct objects, " +
    "open the 'add' menu again and click on the object you want to add."
    return msg;
}

/** 
 * TODO: add unit-tests
 * @param {Element} ul - An html element where the list will be attached
 * @param {Array} feeders - An array of objects, where each object has properties "model" and "name", or null. 
 * @param {string} owner - Either "public" or the owner of the current writeFeeder.
 */
function attachFeederList (ul, feeders, owner) {
    if (!feeders) return;
    for (let writeFeeder of feeders) {
        if (writeFeeder.name != thisFeederName) {
            const li = document.createElement("li");
            li.classList.add("feederItem");
            li.innerHTML = `<strong>${writeFeeder.name}</strong> from <br>"${writeFeeder.model}"`;
            li.addEventListener("click", function() {
                //overwriteFeeder(writeFeeder.name, writeFeeder.model, owner);
                loadFeeder(writeFeeder.name, writeFeeder.model, owner);
            });
            ul.append(li);
        }
    }
}

/**
 * TODO: add unit tests
 */
function addFileMenuHandlers() {
    const menu = document.getElementById("fileMenu");
    if (menu == null) {
        return;
    }
    const items = Array.from(menu.children);
    if (items.length !== 8) {
        throw new Error("Please update this function to ensure the correct handlers are attached");
    }
    items[0].addEventListener("click", function() {
        saveFeeder(writeFeeder);
    });
    items[1].addEventListener("click", downloadTextFile);
    items[2].addEventListener("click", renameFeeder);
    items[3].addEventListener("click", function() { toggleElementDisplay("loadModal"); });
    items[4].addEventListener("click", function() { toggleElementDisplay("blankFeederModal"); });
    items[5].addEventListener("click", function() { toggleElementDisplay("milsoftModal"); });
    items[6].addEventListener("click", function() { toggleElementDisplay("gridlabdModal"); });
    items[7].addEventListener("click", function() { toggleElementDisplay("cymeModal"); });
}

/** 
 * TODO: add unit tests
 */
function addEditMenuHandlers() {
    const menu = document.getElementById("editMenu");
    const items = Array.from(menu.children);
    if (items.length != 9) {
        throw new Error("Please update this function to ensure the correct handlers are attached");
    }
    //items[0].addEventListener("click", zoomToFit);
    //items[1].addEventListener("click", zoomReset);
    items[0].addEventListener("click", staticLoadsToHouses);
    items[1].addEventListener("click", function() { toggleElementDisplay("scadaModal"); });
    items[2].addEventListener("click", function() { toggleElementDisplay("amiModal"); });
    items[3].addEventListener("click", function() { toggleElementDisplay("findModal"); });
    items[4].addEventListener("click", function() {
        updateAttachTargets("massAddTargetSelect", gTreeWrapper.tree);
        toggleElementDisplay("massAddModal");
    });
    items[5].addEventListener("click", function() {
        updateAttachTargets("massEditTargetSelect", gTreeWrapper.tree);
        toggleElementDisplay("massEditModal");
    });
    items[6].addEventListener("click", function() {
        loadAttachments(); 
        toggleElementDisplay("attachmentsModal");
    });
    items[7].addEventListener("click", function() { toggleElementDisplay("climateModal"); });
    items[8].addEventListener("click", function() { toggleElementDisplay("anonymizeModal"); });
}

/** 
 * TODO: add unit tests
 * If an element isn't displayed, set it's inline display value to the default browser value.
 * If the element is displayed, then hide it.
 */
function toggleElementDisplay(id) {
    const element = document.getElementById(id);
    if (element.style.display === "none") {
        element.removeAttribute("style");
    } else {
        element.style.display = "none";
        if (id === "findModal") {
            return;
        }
        // When we hide a modal, set any of the text fields to empty
        const queryString = `#${id} input[type=text]`;
        document.querySelectorAll(queryString).forEach(input => {
            input.value = "";
        });
    }
}

//**************************************************
// Edit menu interface
//**************************************************

/**
 * Set the viewport to its initial state and center it
 */
//function zoomReset() {
//    panZoom.fit();
//    panZoom.center();
//}

/**
 * Set the viewport value to its initial state.
 */
//function zoomToFit() {
//    panZoom.fit();
//}

function randomGaussian() {
  // Get a Gaussian from a uniform(0,1) via the Box-Muller transform.
  let rad;
  let x1;
  let x2;
  let c;
  do {
	x1 = 2 * Math.random() - 1
	x2 = 2 * Math.random() - 1
	rad = x1 * x1 + x2 * x2
  } while (rad >= 1 || rad == 0) {
    c = Math.sqrt(-2 * Math.log(rad) / rad);
  }
  return x1 * c
}

function randomInt(min,max) {
	return Math.floor(Math.random()*(max - min + 1) + min)
}

function randomChoice(inList) {
	return inList[Math.floor(Math.random() * inList.length)]
}


// TODO: for secondary system has 'load', replace it with triplex_meter and triplex_node
// TODO: rename this function?
function staticLoadsToHouses() {
    const tree = gTreeWrapper.tree;
    const names = gTreeWrapper.names;
	//if (!containsTriplexNodes(tree)) {
	if (!containsTriplexNodeOrLoad(tree)) {
        alert("There are no triplex nodes or triplex loads in this model.");
        return;
	} else {
        let modal = new ProgressModal("Please wait. Houses are being generated.", "", false);
        modal.show();
        // Replace 100 nodes at a time (maximum), to prevent the browser from hanging
        const keys = Object.keys(tree);
        let start = 0;
        let end = 100;
        const intervalId = setInterval(function() {
            //console.log("start: " + start);
            //console.log("end: " + end);
            replaceAllHouses(start, end, keys);
            if (end >= keys.length) {
                clearInterval(intervalId);
                modal.hide();
            } else {
                start = end + 1;
                end += 100;
            }
        }, 10);
    }

    /* Triplex loads should have a "parent" property. Triplex nodes should NOT have a "parent" property usually.
    Therefore, if the parent property DOES exist on either a node/load I should use it. However, it it DOESN'T exist,
    then I should carry on as normal too.
    */
    function containsTriplexNodeOrLoad(tree) {
        for (let key in tree) {
            if (tree[key].object === "triplex_node" || tree[key].object === "triplex_load") {
                return true;
            } 
        }   
        return false;
    }

	function replaceAllHouses(start, end, keys) {
        if (end >= keys.length) {
            end = keys.length - 1;
        }
        for (let i = start; i <= end; i++) {
            if (tree[keys[i]].object === "triplex_node" || tree[keys[i]].object === "triplex_load") {
                let parentKey = names[tree[keys[i]].parent];
                if (parentKey == null) {
                    //There is no parent. No big deal

                } else {
                    //There is a parent. Use the parent to place the new house

                }
            }
            /*
            TODO: delete this
            if (tree[keys[i]].hasOwnProperty('parent') && tree[keys[i]].object === "triplex_node") {
                // Get the key of the parent of this triplex node, which is a triplex meter (i.e. another node)
                let parentKey = names[tree[keys[i]].parent];
                // Delete the triplex_node itself
                deleteObject(keys[i]);
                // Create a new house object to replace the triplex node
                let houseObj = randomHouse();
                let lightsObj = randomLights();
                let heaterObj = randomWaterHeater();
                newChildAtLocation(houseObj.house, parentKey);
                newChildAtLocation(lightsObj.lights, houseObj.key);
                if (heaterObj != false) {
                    newChildAtLocation(heaterObj.heater, houseObj.key);
                }
            }
            */
        }
    }

	function randomHouse() {
		const newHouse = {}
		newHouse['object'] = 'house'
		newHouse['air_temperature'] = '70'
		newHouse['cooling_COP'] = randomInt(25, 40) / 10.0 + ''
		newHouse['cooling_setpoint'] = 'cooling' + randomInt(1, 8) + '*1'
		newHouse['cooling_system_type'] = randomChoice(['ELECTRIC', 'HEAT_PUMP', 'NONE'])
		// House sizing distribution from http://www.census.gov/housing/ahs/
		// between 1100 and 3000. Probably needs a normal distribution.
		let area = 1800 + 500 * randomGaussian()
		if (area < 500) {
			area = 500
		}
		area = area.toPrecision(2) * 1.0 + ''
		newHouse['floor_area'] = area
		newHouse['heating_COP'] = randomInt(20, 35) / 10.0 + ''
		newHouse['heating_setpoint'] = 'heating' + randomInt(1, 8) + '*1'
		newHouse['heating_system_type'] = randomChoice(['RESISTANCE', 'HEAT_PUMP', 'GAS'])
		newHouse['mass_temperature'] = '70'
		let skew = 1200 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHouse['schedule_skew'] = skew
		newHouse['thermal_integrity_level'] = randomChoice([1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6]) + ''
		const newKey = getNewTreeKey(gTreeWrapper.tree);
		newHouse['name'] = 'synhouse' + newKey
		return {
            house: newHouse,
            key: newKey
        }
	}

	function randomLights() {
		const newLights = {}
		newLights['object'] = 'ZIPload'
		newLights['power_fraction'] = '0.400000'
		newLights['current_fraction'] = '0.300000'
		newLights['impedance_pf'] = '1.000'
		newLights['current_pf'] = '1.000'
		newLights['power_pf'] = '1.000'
		newLights['impedance_fraction'] = '0.300000'
		newLights['heatgain_fraction'] = '0.9'
		let power = 1.2 + randomGaussian()
		if (power < 0) {
			power = -1 * power
		}
		power = power.toPrecision(3) * 1.0 + ''
		newLights['base_power'] = 'LIGHTS*' + 1.33
		let skew = 2000 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newLights['schedule_skew'] = skew
		const newKey = getNewTreeKey(gTreeWrapper.tree);
		newLights['name'] = 'synLights' + newKey
		return {
            lights: newLights,
            key: newKey
        }
	}

	function randomWaterHeater() {
		const newHeater = {}
		if (randomChoice([1, 2, 3]) == 3) {
			return false
		}
		// Static properties.
		newHeater['object'] = 'waterheater'
		newHeater['temperature'] = '135'
		newHeater['tank_volume'] = '50'
		newHeater['location'] = 'INSIDE'
		// Uniformly distributed properties.
		newHeater['heating_element_capacity'] = randomInt(37, 53) / 10.0 + ''
		newHeater['thermostat_deadband'] = randomInt(20, 60) / 10.0 + ''
		newHeater['demand'] = 'water' + randomInt(1, 20) + '*1'
		newHeater['tank_UA'] = randomInt(20, 40) / 10.0 + ''
		// Gaussian properties.
		let skew = 2000 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHeater['schedule_skew'] = skew
		newHeater['tank_setpoint'] = (randomGaussian() * 2 + 130).toPrecision(3) + ''
		// between 1100 and 3000. Probably needs a normal distribution.
		const newKey = getNewTreeKey(gTreeWrapper.tree);
		newHeater['name'] = 'synwaterheater' + newKey;
		return {
            heater: newHeater,
            key: newKey
        }
	}
}

/** 
 * TODO: add better validation for percent to ensure 1) it's a float and 2) it's in a valid range. Do this on the input if possible
 * General Function to Add Components 'inverter', 'triplex_meter', PERC
 * Did this function get chopped in half?
 */
function attachFeederList(ul, feeders, owner) {
    if (feeders === null || feeders === undefined) {
        return
    } 
    for (let writeFeeder of feeders) {
        if (writeFeeder.name !== thisFeederName) {
            const li = document.createElement("li");
            li.classList.add("feederItem");
            li.innerHTML = `<strong>${writeFeeder.name}</strong> from <br>"${writeFeeder.model}"`;
            li.addEventListener("click", function() {
                //overwriteFeeder(writeFeeder.name, writeFeeder.model, owner);
                loadFeeder(writeFeeder.name, writeFeeder.model, owner);
            });
            ul.append(li);
        }
    }
}

function massAdd() {
    let tree = gTreeWrapper.tree;
	const componentName = document.getElementById('componentSelect').value;
	const attachType = document.getElementById('massAddTargetSelect').value;
    const percent = document.getElementById('percent').value;
    if (isNaN(percent) || percent === "") {
        alert("Please enter a valid number for attachment probability");
        return
    }
	let objectsAdded = 0;
    let modal = new ProgressModal(`Please wait. We are adding ${componentName} objects to all ${attachType} objects.`, "", false);
    modal.show();
    // Add 100 nodes at a time (maximum), to prevent the browser from hanging
    const keys = Object.keys(tree);
    let start = 0;
    let end = 100;
    const intervalId = setInterval(function() {
        console.log("start: " + start);
        console.log("end: " + end);
        massAddComponent(start, end, keys);
        if (end >= keys.length) {
            clearInterval(intervalId);
            modal.hide();
            alert(`${objectsAdded} ${componentName} objects added to the feeder`);
        } else {
            start = end + 1;
            end += 100;
        }
    }, 100);

    function massAddComponent(start, end, keys) {
        if (end >= keys.length) {
            end = keys.length - 1;
        }
        for (let i = start; i <= end; i++) {
            if (tree[keys[i]].object === attachType) {
				if (Math.random() < percent) {
					const newComponent = deepCopy(gComponents[componentName]);
					newChildAtLocation(newComponent, keys[i]);
					objectsAdded += 1
				}
            }
        }
    }
}

function updateAttachTargets(id, tree) {
	/* Clearing each list so we dont get duplicates in the list. This must be done because the attachTarget list must be 
    refreshed, since the user could have added a new object type to the data which they now want to attach to.
    */
    document.getElementById(id).innerHTML = "";
	let attachList = [];
	for (let key in tree) {
        /* Only list an object type as a valid attachTarget if 1) its object property matches a known component and 2)
        the object type already exists in the graph. "1" is to prevent things like weird configuration nodes from 
        being presented to the user, since the user could not attach anything to those weird objects. "2" is to ensure
        that the user must attach to things that already exist in a particular model.
        */
        if (gComponents.hasOwnProperty(tree[key].object)) {
			if (!attachList.includes(tree[key].object)) {
                attachList.push(tree[key].object);
                document.getElementById(id).innerHTML += `<option value=${tree[key].object}>${tree[key].object}</option>`;
            }
        }
    }
}

function massEdit() {
    const tree = gTreeWrapper.tree;
    const objectType = document.getElementById("massEditTargetSelect").value;
    const keys = [];
    for (let key in tree){
		if (tree[key].object === objectType) {
            keys.push(key);
        }
    }
    let operation = document.querySelector("input[name=attributeOperation]:checked");
    if (operation == null) {
        alert("Please select an operation with radio buttons on the 'Mass Edit' menu.");
        return;
    }
    operation = operation.value;
    if (operation === "addAttribute") {
        massEditAdd(keys);
        return;
    }
    const attributeKey = document.getElementById("massEditAttribute").value;
    for (let key of keys) {
        if (tree[key][attributeKey] === undefined) {
            alert(`Invalid operation. One or more of the objects you selected does not have the attribute you are trying to edit.
            Attribute "${attributeKey}" is missing from tree object with key "${key}".`);
            return;
        }
    }
    switch (operation) {
        case "addTo":
            const operand = parseFloat(document.getElementById("addToValue").value);
            if (isNaN(operand)) {
                alert("Invalid operation. Please enter a valid number if you choose 'Add to Value'.");
                return;
            } else {
                for (let key of keys) {
                    const value = parseFloat(tree[key][attributeKey]);
                    if (isNaN(value)) {
                        alert("Invalid operation. The attribute you are trying to add to is not a number.");
                        return;
                    }
                    tree[key][attributeKey] = (value + operand).toString();
                }
            }
            break;
        case "change":
            const newValue = document.getElementById("changeValue").value;
            for (let key of keys) {
                tree[key][attributeKey] = newValue;
            }
            break;
        case "delete":
            for (let key of keys) {
                delete tree[key][attributeKey];
            }
            break;
        case "multiplyBy":
            const multiplyOperand = parseFloat(document.getElementById("multiplyValue").value);
            const rawAddOperand = document.getElementById("andAddValue").value;
            let addOperand;
            if (rawAddOperand === "") {
                addOperand = 0;
            } else {
                addOperand = parseFloat(rawAddOperand);
            }
            if (isNaN(multiplyOperand) || isNaN(addOperand)) {
                alert("Invalid operation. Please enter valid numbers if you choose 'Multiply attribute by'.");
            }
            for (let key of keys) {
                const value = parseFloat(tree[key][attributeKey]);
                if (isNaN(value)) {
                    alert("Invalid operation. The attribute you are trying to multiply by is not a number.");
                    return;
                }
                tree[key][attributeKey] = ((value * multiplyOperand) + addOperand).toString();
            }
            break;
    }
    alert(`${keys.length} ${objectType} objects edited.`);
}

function massEditAdd(keys) {
    const tree = gTreeWrapper.tree;
    const newKey = document.getElementById("newAttributeKey").value;
    const newValue = document.getElementById("newAttributeValue").value;
    for (let key of keys) {
        tree[key][newKey] = newValue;
    }
    const objectType = document.getElementById("massEditTargetSelect").value;
    alert(`${keys.length} ${objectType} objects edited.`);
}

function loadAttachments() {
    const selectElement = document.getElementById("attachmentSelect");
    selectElement.innerHTML = "";
	for (let key in writeFeeder.attachments) {
        selectElement.innerHTML += `<option value=${key}>${key}</option>`;
    }
}

function editAttachment() {
	//document.body.style.cursor = 'wait'
	//setTimeout(function(){
		toggleElementDisplay('editAttachmentModal');
		let name =  document.getElementById('attachmentSelect').value; //get the select. attachmentsList = attachmentSelect
		document.getElementById('attachmentTd').innerHTML = name;  //get the td. attachmentSelect = attachmentTd
		document.getElementById('editAttachmentBox').innerHTML = writeFeeder.attachments[name];
		//document.body.style.cursor = 'auto'
	//}, 100);
}

function saveAttachment() {
	let name = document.getElementById('attachmentSelect').value;
	writeFeeder.attachments[name] = document.getElementById('editAttachmentBox').value;
}

//ADD PROMPT TO SAVE CHANGES BEFORE EXIT
{% if is_admin or not public %}
	window.onbeforeunload = function(e) {
		let confirmationMessage = 'It looks like you have been editing something. ';
		confirmationMessage += 'If you leave before saving, your changes will be lost.';
		//if (unsavedChanges) return confirmationMessage;
	};
{% endif %}

//**************************************************
// File menu interface
//**************************************************
{% if showFileMenu %}

/** 
 * Used to save the new changes or undo an operation by resaving the old changes.
 */ 
function saveFeeder(feeder) {
    const formData = new FormData();
    formData.set("feederObjectJson", JSON.stringify(feeder));
    const postRequest = $.ajax({
        type: "POST",
        url: `/saveFeeder/${thisOwner}/${thisModelName}/${thisFeederName}`,
        data: formData,
        processData: false,
        contentType: false,
    });
    let cancelled = false;
    let progressModal;
    if (feeder === readFeeder) {
        progressModal = new ProgressModal("Cancelling the previous operation...", "", false);
        postRequest.done(function() {
            progressModal.hide();
            alert("Success. Previous operation was canceled");
        });
    } else if (feeder === writeFeeder) {
        progressModal = new ProgressModal("Saving changes to your file...", "You have canceled the save.", true);
        progressModal.button.addEventListener("click", function() {
            cancelled = true;
            progressModal.header.textContent = progressModal.cancelMessage;
            progressModal.button.style.display = "none";
        });
        postRequest.done(function() {
            if (cancelled) {
                saveFeeder(readFeeder);
            } else {
                progressModal.hide();
                alert("Success. Your data was saved.");
            }
        });
    }
    progressModal.show();
}

async function loadFeeder(serverFeederName, serverModelName, owner) {
    let submitForm = false;
    await $.ajax({
        url: `/uniqObjName/Feeder/${thisOwner}/${serverFeederName}/${serverModelName}`
    }).done(function(data) {
        if (data.exists) {
            submitForm = true;
        } else {
            alert('This feeder no longer exists. Please refresh the page, or select another feeder.');
        }
    });
    if (submitForm === false) {
        return;
    }
    let formData = new FormData();
    formData.set("referrer", "distribution");
    const progressModal = new ProgressModal("Loading feeder from server...", "You have canceled loading the feeder.", true);
    let cancelled = false;
    progressModal.button.addEventListener("click", function() {
        cancelled = true;
        progressModal.header.textContent = progressModal.cancelMessage;
        progressModal.button.style.display = "none";
    });
    progressModal.show();
    $.ajax({
        type: "POST",
        url: `/loadFeeder/${serverFeederName}/${serverModelName}/${thisModelName}/${thisFeederNum}/${owner}/${thisOwner}`,
        data: formData,
        processData: false,
        contentType: false,
    }).done(function() {
        if (cancelled) {
            saveFeeder(readFeeder);
        } else {
            reloadWrapper();
        }
    });
}

/** 
 * TODO: add back ability to cancel these operations
 */
async function submitForm({formId, pollUrl, inputId}) {
    let submitForm = true;
    if (inputId !== undefined) {
        // inputId was defined, therefore we need to check the file name on the server before submitting the form
        submitForm = false;
        const fileName = document.getElementById(inputId).value;
        // Check if the file exists, using the user-provided fileName
        await $.ajax({
            url: `/uniqObjName/Feeder/${thisOwner}/${fileName}/${thisModelName}`
        }).done(function(data) {
            console.log(data);
            if (data.exists === true) {
                alert(`You already have a feeder named "${fileName}". Please choose a different name.`);
            } else {
                // The file does not exist. Submit the form.
                submitForm = true;
            }
        });
    }
    if (submitForm === false) {
        return;
    }
    const form = document.getElementById(formId);
    const formData = new FormData(form);
    const submitModal = new ProgressModal("Submitting your file...", "", false);
    submitModal.show();
    // Submit the form to the server with an ajax request
    const formRequest = $.ajax({
        type: "POST",
        url: form.action,
        data: formData,
        processData: false,
        contentType: false,
    });
    if (pollUrl === undefined) {
        // We don't want to poll the server. Just reload the page.
        formRequest.done(function() {
            reloadWrapper();
        });
    } else {
        formRequest.done(function(data) {
            let cancelled = false;
            const pollModal = new ProgressModal("Converting your file...", "You canceled the file conversion.", true);
            pollModal.button.addEventListener("click", function() {
                cancelled = true;
                pollModal.header.textContent = pollModal.cancelMessage;
                pollModal.button.style.display = "none";
            });
            pollModal.show();
            // Poll the server
            const intervalId = setInterval(function() {
                $.ajax({
                    //url: `/checkConversion/${thisModelName}/${thisOwner}`
                    url: pollUrl
                }).done(function(data) {
                    if (cancelled) {
                        clearInterval(intervalId);
                        pollModal.hide();
                        alert("You cancelled the operation");
                        saveFeeder(readFeeder);
                    }
                    if (data.exists === true) {
                        //processing is ongoing 
                    } else if (data.exists === false) {
                        // The pollModal isn't hidden before the alert happens. This has nothing to do with the reload wrapper.
                        clearInterval(intervalId);
                        pollModal.hide();
                        alert("Conversion complete");
                        reloadWrapper();
                    } else if (data === "milError") {
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('The .std and .seq files used are incorrectly formatted.');
                        //TODO: submit the readFeeder
                    } else if (data === "glmError") {
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('The .glm file used is incorrectly formatted.');
                        //TODO: submit the readFeeder
                    } else {
                        console.log(data);
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('There was a problem. Operation was cancelled');
                    }
                });
            }, 5000);
        });
    }
}

async function renameFeeder() {
	if (JSON.stringify(readFeeder) !== JSON.stringify(writeFeeder)){
		alert('You have unsaved changes. Please save the feeder before proceeding.')
	} else {
		let newName = prompt("Rename the feeder to", `${thisFeederName}`);
		while (! /^[\w\s]+$/.test(newName) || /^\s+$/.test(newName)) {
			newName = prompt("Only letters, digits and underscore are allowed.\nPlease enter a different name", `${thisFeederName}`);
		}
		if (newName){
            let submitRequest = false;
            await $.ajax({
                url: `/uniqObjName/Feeder/${thisOwner}/${newName}/${thisModelName}`
            }).done(function(data) {
                if (data.exists) {
                    alert(`You already have a feeder named "${newName}". Please choose a different name.`);
                } else {
                    submitRequest = true;
                }
            });
            if (submitRequest === false) {
                return;
            }
            $.ajax({
                url: `/renameFeeder/${thisOwner}/${thisModelName}/${thisFeederName}/${newName}/${thisFeederNum}`
            }).done(function() {
                thisFeederName = newName;
                alert("Feeder file was successfully renamed.");
            })
		}
	} 
}
{% endif %}

/** This is done for testing reasons.
 */
function reloadWrapper() {
    /* Force the client to always request new files from the server without using the browser cache. 
    */
    window.location.reload(true);
}

function ProgressModal(message, cancelMessage, showButton) {
    this.self = document.getElementById("progressModal");
    this.button = this.self.getElementsByTagName("button")[0];
    this.header = this.self.getElementsByTagName("h2")[0];
    this.message = message;
    this.cancelMessage = cancelMessage;
    this.showButton = showButton;
}

ProgressModal.prototype.show = function() {
    this.header.textContent = this.message;
    this.self.removeAttribute("style");
    if (this.showButton) {
        this.button.removeAttribute("style");
    } else {
        this.button.style.display = "none";
    }
}

ProgressModal.prototype.hide = function() {
    this.self.style.display = "none";
}

//**************************************************
// TreeWrapper interface
//**************************************************

const treeWrapperPrototype = {

    /* "Public" TreeWrapper methods */

    /** 
     * Return a TreeWrapper that represents which tree objects need to be redrawn as a result of inserting 
     * this TreeObject.
     * 
     * If the TreeObject.key does not exist in this TreeWrapper, the new TreeObject.key and new TreeObject.data are added to the
     * TreeWrapper. If the TreeObject.key does exist in this TreeWrapper, the data at the existing key is overwritten.
     * This is a public interface method, which means it should be used in event handlers and other places to do stuff.
     * While this method will work for ANY TreeWrapper, it is intended to be used with the "gTreeWrapper" only.
     * The gTreeWrapper encapsulates all the data of the model, which is what we want to work with.
     * @param {TreeObject} treeObject - contains a key and some data that will be used to add or overwite
     * data inside of this TreeWrapper.
     * @return {TreeWrapper} tWrapper - contains all of the tree objects that need to be redrawn as a result of 
     * modifying the data.
     */
     insert(treeObject) {
        this.tree[treeObject.key] = treeObject.data;
        const name = treeObject.data.name;
        if (name != null) {
            this.names[name] = treeObject.key;
        } else {
            //console.log(`Inserted TreeObject with key "${treeObject.key}" did not have a "name" property.`);
        }
        const tWrapper = createTreeWrapper();
        tWrapper.add(treeObject.key, this);
        tWrapper.merge(this.getSubtreeToRedraw(treeObject.key));
        return tWrapper;
    },

    /** 
     * Delete the tree object with the passed key argument from this TreeWrapper.
     * @param {string} key - the key used to identify the tree object to delete.
     * @return {TreeWrapper} tWrapper - contains 1 tree object that was affected by the delete operation.
     */
    delete(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            console.log(`Unable to perform delete operation. This TreeWrapper does not contain a tree object with key: "${key}".`);
            return tWrapper;
        }
        const childKeys = Object.keys(this.getChildrenOf(key).tree);
        if (childKeys.length > 0) {
            throw new Error(`Cannot delete object with key "${key}" because it has existing children. Please delete the children first.`);
            //console.log(`Cannot delete tree object with key "${key}" from the tree because it has existing children`);
            return tWrapper;
        }
        const lineKeys = Object.keys(this.getConnectedLinesOf(key).tree);
        if (lineKeys.length > 0) {
            throw new Error(`Cannot delete object with key "${key}" because it has connected lines. Please delete the connected lines first.`);
            //console.log(`Cannot delete tree object with key "${key}" from the tree because it has connected lines`);
            return tWrapper;
        }
        tWrapper.add(key, this);
        delete this.names[this.tree[key].name];
        delete this.tree[key];
        return tWrapper;
    },

    /** 
     * Delete the tree object with the passed key argument from this TreeWrapper. Also recursively delete any connected
     * lines and children. 
     * @param {string} key - the key of the tree object which should be deleted, along with any associated tree objects.
     * @return {TreeWrapper} - contains all of the tree objects that need to be removed from the svg
     * as a result of the recursive delete operation.
     */
    recursiveDelete(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to perform a recursive delete operation. The tree object with key "${key}" does not exist
            //in this TreeWrapper`);
            return tWrapper;
        }
        tWrapper.add(key, this);
        tWrapper.merge(this.getSubtreeToDelete(key, []));
        for (let key in tWrapper.tree) {
            delete this.names[this.tree[key].name];
            delete this.tree[key];
        }
        return tWrapper;
    },

    /* "Private" TreeWrapper methods */

    /** 
     * Add an object from the tWrapper argument into this TreeWrapper.
     * @param {string} key - the key of the object to search for in the tWrapper argument.
     * @param {TreeWrapper} tWrapper - the TreeWrapper from which we want to get data to insert into this TreeWrapper.
     */
    add(key, tWrapper) {
        if (!tWrapper.contains(key)) {
            console.log(`Unable to add the desired tree object to this TreeWrapper. The tree object with the key: "${key}" does
            not exist in the source tWrapper argument.`)
            return;
        }
        this.tree[key] = tWrapper.tree[key];
        const name = this.tree[key].name;
        if (name == null) {
            return;
        }
        this.names[name] = key;
    },

    /** 
     * Return a TreeWrapper that contains direct children of the tree object with the passed key argument.
     * @param {string} key - the key of the tree object that is presumably a parent to some other tree objects.
     * @return {TreeWrapper} childrenTreeWrapper - contains only children tree objects of the key tree object.
     */
    getChildrenOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to get the children of the tree object with key: "${key}". The key does not exist in this
            //TreeWrapper.`);
            return tWrapper;
        }
        const type = getType(this.tree[key]);
        if (type === "childNode" || type === "independentNode") {
            const thisName = this.tree[key].name;
            if (thisName == null) {
                /* Children reference their parent with the parent's name. If a node doesn't have a name, then it must not
                have children. */
                //console.log(`Unable to get the children of the tree object with key: "${key}". The tree object
                //does not have a name.`);
                return tWrapper;
            } 
            // TODO: Build an object in TreeWrapper that allows instant lookup of children for any TreeWrapper.tree object
            Object.keys(this.tree).forEach(key => {
                if (this.tree[key].parent === thisName) {
                    tWrapper.add(key, this);
                }
            });
        }
        return tWrapper;
    },

    /** 
     * Return a TreeWrapper that contains lines connected to the tree object with the passed key argument.
     * @param {string} key - the key of the tree object that presumably has lines connected to it.
     * @return {TreeWrapper} - contains only line tree objects that connect to the desired tree object.
     */
    getConnectedLinesOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            console.log(`Unable to find lines that connect to this node with key: "${key}". The key does not exist in this
            TreeWrapper.`);
            return tWrapper;
        } 
        const type = getType(this.tree[key]);
        if (type === "childNode" || type === "independentNode") {
            const thisName = this.tree[key].name;
            if (thisName == null) {
                /* Lines reference their connected nodes with the node's name. If a node doesn't have a name, then it must not
                have lines. */
                //console.log(`Unable to get the lines of the tree object with key: "${key}". The tree object
                //does not have a name.`);
                return tWrapper;
            } 
            // TODO: Build an object in TreeWrapper that allows instant lookup of connected lines for any TreeWrapper.tree object
            Object.keys(this.tree).forEach(key => {
                if (this.tree[key].to === thisName || this.tree[key].from === thisName) {
                    tWrapper.add(key, this);
                }
            });
        }
        return tWrapper;
    },

    /** 
     * Merge the treeWrapper argument into this TreeWrapper.
     * 
     * If no keys argument is passed, the entire treeWrapper argument is merged into this TreeWrapper.
     * If a keys argument is passed, only those tree objects with matching keys inside of the treeWrapper argument are merged
     * into this TreeWrapper.
     * @param {TreeWrapper} treeWrapper - contains tree objects that will be merged into this TreeWrapper
     * @param {Array} keys - an optional argument that limits which tree objects are merged into this TreeWrapper
     */
    merge(treeWrapper, keys) {
        if (keys === undefined) {
            Object.keys(treeWrapper.tree).forEach(key => {
                this.add(key, treeWrapper);
            });
        } else if (Array.isArray(keys)) {
            keys.forEach(key => {
                this.add(key, treeWrapper);
            });
        } else {
            throw new Error("If the keys argument is passed, it must be an array");
        }
    },

    /** Return a TreeWrapper that contains all tree objects that will be deleted as a result of deleting the
     * tree object with the passed key argument.
     * 
     * @param {string} key - the key of the tree object for which to find its deletable subtree.
     * @param {Array} visited - contains keys of tree objects that have already been visited so the method dosen't
     * recurse infinitely in case of a cycle.
     * @return {TreeWrapper}
     */
    getSubtreeToDelete(key, visited) {
        if (!Array.isArray(visited)) {
            throw new Error("Visited argument must be an array");
        }
        visited.push(key);
        const tWrapper = createTreeWrapper();
        const children = this.getChildrenOf(key);
        tWrapper.merge(children);
        tWrapper.merge(this.getConnectedLinesOf(key));
        if (Object.keys(children.tree).length > 0) {
            for (let childKey in children.tree) {
                if (!visited.includes(childKey)) {
                    tWrapper.merge(this.getSubtreeToDelete(childKey, visited));
                }
            }
        }
        return tWrapper;
    },

    /**
     * Return a TreeWrapper that contains only the parent tree object of the child tree object.
     * 
     * @param {string} childKey - the key of the child tree object.
     * @return {TreeWrapper} subWrapper - contains only the parent tree object of the child tree object.
     */
    getParentOf(childKey) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(childKey)) {
            //console.log(`Unable to get the parent of the tree object with key: "${childKey}". The key does not exist in this
            //TreeWrapper.`);
            return tWrapper;
        }  
        const parentName = this.tree[childKey].parent;
        if (parentName == null) {
            // This tree object doesn't have a parent, which is fine.
            return tWrapper
        }
        const parentKey = this.names[parentName];
        if (parentKey == null) {
            /* If parentKey is undefind, then either 1) the child node has a parent that doesn't exist in this graph or 
            2) the names object of a TreeWrapper was built incorrectly */
            //console.log(`Unable to get the parent of the child tree object with key: "${childKey}". The parent does not 
            //exist in this TreeWrapper.`); //or the 'names' property is being built wrong.
            return tWrapper;
        }
        tWrapper.add(parentKey, this);
        return tWrapper;
    },

    /** Return a TreeWrapper that contains only tree objects that are on the other ends of lines that connect
     * to the tree object with the passed key argument.
     * 
     * @param {string} key - the tree object for which to search for its paired nodes. Nodes have a paired relationship
     * if they are connected by a line.
     * @return {TreeWrapper} - contains only tree objects that are paired nodes of the tree object for which
     * we searched.
     */
    getPairedNodesOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to get the paired nodes of the tree object with the key: "${key}". The key does not exist
            //in this TreeWrapper`);
            return tWrapper;
        }
        const linesTreeWrapper = this.getConnectedLinesOf(key);
        for (let lineKey in linesTreeWrapper.tree) {
            const fromKey = this.names[this.tree[lineKey].from];
            const toKey = this.names[this.tree[lineKey].to];
            if (key === fromKey) {
                // The 'from' node points to this tree object, so we want the other tree object
                tWrapper.add(toKey, this);
            } else if (key === toKey) {
                // The 'to' node points to this tree object, so we want the other tree object
                tWrapper.add(fromKey, this);
            } else {
                throw new Error(`There was a problem finding a "from" or "to" node for line with key: "${lineKey}"`);
            }
        }
        return tWrapper;
    },

    /** 
     * Return a TreeWrapper that contains nodes on either end of the line that is represented by the
     * tree object with the passed key argument.
     * @param {string} key - the key of the tree object that is a line. 
     * @return {TreeWrapper} subWrapper - contains only 2 tree objects that are on either end of the line,
     * or 0 tree objects if the tree object isn't a line!
     */
    getNodeEndsOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to get the node ends of the tree object with the key: "${key}". The key does not exist
            //in this TreeWrapper`);
            return tWrapper;
        } 
        if (getType(this.tree[key]) === "line") {
            const fromKey = this.names[this.tree[key].from];
            const toKey = this.names[this.tree[key].to];
            //const subWrapper = createTreeWrapper();
            if (fromKey == null) {
                if (toKey == null) {
                    console.log(`Tree object with key: "${key}" has nonexistent "from" and "to" nodes.`);
                    return tWrapper;
                } else {
                    console.log(`Tree object line with key: "${key}" has nonexistent "from" node.`);
                    tWrapper.add(toKey, this);
                    return tWrapper;
                }
            } else if (toKey == null) {
                console.log(`Tree object line with key: "${key}" has nonexistent "to" node.`);
                tWrapper.add(fromKey, this);
                return tWrapper;
            } else {
                tWrapper.add(fromKey, this);
                tWrapper.add(toKey, this);
            }
        }
        return tWrapper;
    },

    /**
     * Return a treeWrapper that contains tree objects that will be affected by drawing the tree object with the key argument.
     * @param {string} key
     * @return {TreeWrapper}
     */
    getSubtreeToRedraw(key) {
        const tWrapper = createTreeWrapper();
        tWrapper.merge(this.getParentOf(key));
        tWrapper.merge(this.getChildrenOf(key));
        tWrapper.merge(this.getConnectedLinesOf(key));
        tWrapper.merge(this.getPairedNodesOf(key));
        tWrapper.merge(this.getNodeEndsOf(key));
        return tWrapper;
    },

    /** 
     * Return true if the tree of this TreeWrapper contains the 'key' argument as a property, otherwise return false;
     * @param {string} key - the key to search for in the TreeWrapper.tree
     * @return {boolean}
     */
    contains(key) {
        if (this.tree[key] == null) {
            // Methods that use this method have more specific error messages that make this one redundant
            //console.log(`Unable to perform any operations with the 'key' argument.
            //No tree object with key: "${key}" exists in this TreeWrapper.`);
            return false;
        }
        const name = this.tree[key].name;
        if (name == null) {
            //console.log(`The tree object with the key: "${key}" does not have a 'name' property, therefore it isn't
            //contained in the 'names' property of this TreeWrapper.`);
        } else if (this.names[this.tree[key].name] == null) {
            console.log(`The 'names' property of this TreeWrapper is missing an entry for tree object with key: "${key}",
            name: "${this.tree[key].name}".`); 
        }
        return true;
    },

    ///** TODO: add unit tests
    // * 
    // */
    //getKeyWithName(name) {
    //    const key = this.names[name];
    //    if (key == null) {
    //        console.log(`The name "${name}" does not exist in this TreeWrapper.names`);
    //        return null;
    //    }
    //    return key;
    //},

    /** 
     * It would be nice if createTreeWrapper() could accept another treeWrapper. That way instead of rebuilding a new
     * names object for each treeWrapper I could (maybe) reuse the pre-existing names object in the TreeWrapper argument?
     * It's a micro-optimization I think.
     */
    buildNames() {
        const nameKeyMap = {};
        Object.keys(this.tree).forEach(key => {
            const name = this.tree[key].name;
            if (name != null) {
                keyIsStringAndValidNumber(key);
                nameKeyMap[name] = key;
            }
        });
        return nameKeyMap;
    },

    /**
     * TODO: do some sort of pre-scan to find an empty square in the graph to insert the configuration objects.
     * Parse this TreeWrapper.tree and insert longitude and latitude properties if a non-line type object does not contain them.
     * @param {number} initX - the longitude of the top left corner of the square.
     * @param {number} initY - the latitude of the top left corner of the square.
     * @param {number} spacing - how far apart the nodes should be spaced from one another
     */
    insertCoordinates(initX, initY, spacing) {
        let keys = Object.keys(this.tree);
        let gen = getCoordinatesGenerator(initX, initY, spacing);
        keys.forEach(key => {
            let obj = this.tree[key];
            if (getType(obj) !== "line" && (obj.longitude == null || obj.latitude == null)) {
                let coords = gen.next().value;
                obj.longitude = coords.longitude;
                obj.latitude = coords.latitude;
            }
        });
    }
};

/** 
 * Return an object that has an 'tree' object and a 'names' map.
 * 
 * The 'tree' object is a reference to the tree that exists in writeFeeder, which is the original source of all data.
 * The 'names' object maps the name of a tree object to the key of the tree object in the tree. This allows faster
 * retrieval of to/from/parent nodes when building the svg data. Without this map, we would have to parse the tree to find
 * every to/from/parent node. This would be slow.
 * @param {Object} tree - contains all of the objects that will be used to generate the svg.
 * @return {TreeWrapper} treeWrapper - a wrapper around the tree argument. This wrapper also has the name-key map to speed up 
 * to/from/parent node retrieval.
 */
function createTreeWrapper(tree = {}) {
    if (typeof(tree) !== "object" || Array.isArray(tree)) {
        throw new Error("tree argument must be a JavaScript object");
    }
    const treeWrapper = Object.create(treeWrapperPrototype);
    treeWrapper.tree = tree;
    treeWrapper.names = treeWrapper.buildNames();
    return treeWrapper;
}

//**************************************************
// TreeWrapper-to-SVG interface
//**************************************************

const deletableSvgDataPrototype = {

    /* Public interface methods */

    /**
     * Use the ids inside of the deletableSvgData instance to remove elements from the document viewport.
     */
    deleteFrom(viewport) {
        this.ids.forEach(id => {
            let e = document.getElementById(id);
            if (e != null) {
                viewport.removeChild(document.getElementById(id));
            }
            // could log a console message if it would be helpful
        });
    }
}

/** 
 * TODO: should take a treeWrapper, add unit tests
 * 
 * @param {Object} tree - A tree of all tree objects that 1) were already deleted from the tree and 2) should also
 * be deleted from the svg.
 * @return {Object} DeletableSvgData - Has a method for deleting from a viewport.
 */
function createDeletableSvgData(tree) {
    const obj = Object.create(deletableSvgDataPrototype);
    obj.ids = []
    Object.keys(tree).forEach(key => {
        if (getType(tree[key]) === "childNode") {
            obj.ids.push(key);
            const parentChildLineId = `${tree[key].parent}_${tree[key].name}`
            obj.ids.push(parentChildLineId);
        } else {
            obj.ids.push(key);
        }
        //console.log(`Failed to delete type: "${tree[key].object}", name: "${tree[key].name}", key: ${key}"`);
        //throw new Error(`tree key: ${key}, with data: ${tree[key]} is not a parent-child node, a parentless node, or a line.`); 
    });
    return obj;
}

const addableSvgDataPrototype = {

    /* "Public" interface methods */

    /**
     * Deletes lines and circles from the viewport if they exist, then draws all lines and circles on the viewport.
     * @param {HTMLElement} viewport - a viewport created by svg-pan-zoom.
     */
    drawTo(viewport) {
        this.lines.forEach(line => {
            let e = document.getElementById(line.id);
            if (e != null) {
                e.parentNode.removeChild(e);
                //viewport.removeChild(document.getElementById(line.id).parentNode.childNodes);
                //document.getElementById(line.id).remove();
            }
            viewport.appendChild(line);
        });
        this.circles.forEach(circle => {
            let e = document.getElementById(circle.id);
            if (e != null) {
                e.parentNode.removeChild(e);
                //viewport.removeChild(document.getElementById(circle.id).parent);
                //document.getElementById(circle.id).remove();
            }
            viewport.appendChild(circle);
        });
        scaleTo(scaleLevel);
    },

    /* "Private" helper methods */

    /** 
     * TOOD: add unit tests
     */
    addLine(key) {
        const nodes = Object.values(this.treeWrapper.getNodeEndsOf(key).tree);
        if (nodes.length < 2) {
            console.log(`Could not find both of the nodes on either end of a line with key: "${key}". Line was not drawn`);
            /* TODO: Draw the line anyway with some kind of default values so the user can see there's a broken line?
            I could have a second viewport that is contained in a table with all the broken lines and circles! Neat!
            */
            return;
        }
        const tree = this.treeWrapper.tree;
        let line;
        if (tree[key].from === nodes[0].name) {
            line = createSvgLine(nodes[0], nodes[1], key, tree[key]);
        } else {
            line = createSvgLine(nodes[1], nodes[0], key, tree[key]);
        }
        this.lines.push(line);
    },

    /** 
     * TODO: add unit tests
     */
    addParentChildLine(key) {
        const parent = Object.values(this.treeWrapper.getParentOf(key).tree)[0];
        if (parent == null) {
            //console.log(`Could not draw the parent-child line for child tree object with key: "${key}"`);
            return;
        }
        const parentChildLine = createSvgLine(parent, this.treeWrapper.tree[key]);
        this.lines.push(parentChildLine);
    },

    /**
     * TODO: add unit tests, inject coordinates in a smart way if needed
     */
    addConfigurationNode(key, obj) {
        if (obj.longitude == null || obj.latitude == null) {
            // configuration algorithm
            obj.longitude = 0;
            obj.latitude = 0;
        }
        const circle = createSvgCircle(key, obj);
        this.circles.push(circle);
    },

    /**
     * TODO: add unit tests, inject coordinates if they don't exist based on the parent
     */
    addChildNode(key, obj) {
        /* There are some weird config nodes that have "parent" but no "longitude" and "latitude" properties and the
        interface breaks if I don't do this. */
        //if (obj.longitude == null || obj.latitude == null) {
        //    //this.addConfigurationNode(key);
        //} else {
        const circle = createSvgCircle(key, obj);
        this.circles.push(circle);
        //}
    },

    /**
     * TODO: add unit tests, inject coordinates if they don't exist somehow
     */
    addIndependentNode(key, obj) {
        const circle = createSvgCircle(key, obj);
        this.circles.push(circle);
    }
};

/** 
 * Return an AddableSvgData instance.
 * 
 * An AddableSvgData instance contains an array of circles and an array of lines that can be draw to the svg.
 * @param {TreeWrapper} treeWrapper - contains all tree objects that should be drawn to to the svg.
 * @return {AddableSvgData} - the svg data to add.
 */
function createAddableSvgData(treeWrapper) {
    if (Object.getPrototypeOf(treeWrapper) !== treeWrapperPrototype) {
        throw new Error("treeWrapper argument must be an instance of TreeWrapper");
    }
    const obj = Object.create(addableSvgDataPrototype);
    obj.treeWrapper = treeWrapper;
    obj.lines = [];
    obj.circles = [];
    const tree = treeWrapper.tree;
    Object.keys(tree).forEach(key => {
        let type = getType(tree[key]);
        if (type === "line") {
            obj.addLine(key);
        } else if (type === "configurationNode") {
            obj.addConfigurationNode(key, tree[key]);
        } else if (type === "childNode") {
            obj.addChildNode(key, tree[key]);
            obj.addParentChildLine(key);
        } else if (type === "independentNode") {
            obj.addIndependentNode(key, tree[key]);
        } else {
            console.log(`Failed to draw object type: "${tree[key].object}", name: "${tree[key].name}", key: "${key}"`);
        }
    });
    return obj;
}

//**************************************************
// Utility methods
//**************************************************

/**
 * There are 4 types of objects: lines, child nodes, independent nodes, and configuration nodes.
 * The line between a parent and child doesn't exist in the data itself, it's merely shown in the svg
 * to demonstrate the relationship between two nodes.
 */

/* Public utility methods */

// Really need to test this to ensure that I remember to include gLonOffset and gLatOffset
/**
 * This is currently broken
 */
function moveNode(event) {
    event.stopPropagation();
    //document.getElementById("svgContainerWrapper").removeEventListener("click", moveNode, true);
    document.getElementById("svgContainerWrapper").removeEventListener("mousedown", moveNode, true);
    const coords = clickLatLon(event);
    //that.tObject.data.longitude = coords.x;
    that.tObject.data.longitude = coords.x + gLonOffset;
    //that.tObject.data.latitude = coords.y;
    that.tObject.data.latitude = coords.y + gLatOffset;
    const subWrapper = that.tWrapper.insert(that.tObject);
    createAddableSvgData(subWrapper).drawTo(gViewport);
    element.setAttribute("style", "cursor: default");
    // Update the table with the new coordinates
    Array.from(that.tableBody.getElementsByTagName("input")).forEach(input => {
        if (input.dataset.coordinate === "latitude") {
            input.value = coords.y + gLatOffset;
        } else if (input.dataset.coordinate === "longitude") {
            input.value = coords.x + gLonOffset;
        }
    });
}

/**
 * TODO: add unit tests
 * Add a click listener to the svgContainerWrapper which is the direct parent of the svgContainer. The
 * svgContainerWrapper will intercept a click before it reaches the svgContainer and invoke moveNode().
 */
function addMoveListener() {
    const element = document.getElementById("svgContainerWrapper");
    element.setAttribute("style", "cursor: crosshair");
    //const that = this;
    //element.addEventListener("click", moveNode, true);
    element.addEventListener("mousedown", moveNode, true);
}

/**
 * Return the type of the object with regard to this interface.
 * 
 * This function is important because the order in which an object is checked matters. For example, an object
 * could be both a 'line' type and a 'configurationNode' type, but the 'line' type should take precedence over the 
 * 'configurationNode' type, so 'line' should be returned.
 * @param {Object} obj
 * @return {string}
 */
function getType(obj) {
    if (isLine(obj)) {
        return "line";
    } else if (isConfigurationNode(obj)) {
        return "configurationNode";
    } else if (isChildNode(obj)) {
        return "childNode";
    } else {
        return "independentNode"
    }
}

/** 
 * Return an object that is a copy of the argument object.
 * JSON.stringify will not copy a property of an object with an undefined value.
 * @param {Object} oldObject - the object to copy.
 * @return {Object} - a copy of the object argument.
 */
 function deepCopy(oldObject) {
    if (Object.getPrototypeOf(oldObject) !== Object.prototype) {
        throw new Error("This function cannot be used to copy objects created with a constructor function.");
    }
    const properties = Object.getOwnPropertyNames(oldObject);
    const keys = Object.keys(oldObject);
    for (let key of keys) {
        if (typeof(oldObject[key]) === "function") {
            throw new Error("This function cannot be used to copy objects with methods.");
        } else if (oldObject[key] === undefined) {
            throw new Error("JSON.stringify silently ignores properties with undefined values, so this function cannot handle undefined values.");
        }
    }
    return JSON.parse(JSON.stringify(oldObject));
}

/**  
 * TODO: add unit tests
 */
function keyIsStringAndValidNumber(key) {
    if (typeof(key) !== "string") {
        throw new Error("key argument must be a string.");
    }
    if (isNaN(parseFloat(key))) {
        throw new Error("key argument must be a string that can be parsed to a valid number");
    }
}

/* Private utility methods */

/**
 * Return true if the object has a 'parent' property, otherwise return false.
 * @param {Object} obj
 * @return {boolean}
 */
function isChildNode(obj) {
    return obj.parent != null;
}

/**
 * Return true if the object has 'from' and 'to' properties, otherwise return false.
 * @param {Object} obj
 * @return {boolean}
 */
function isLine(obj) {
    return obj.from != null && obj.to != null;
}

/**
 * Return true if the object is a configuration node.
 * @param {Object} obj
 * @return {boolean}
 */
function isConfigurationNode(obj) {
    if (obj.object == null || configObjectTypes.includes(obj.object)) {
        return true;
    }
    return false;
}

/**
 * Configure the child object based on the property values of the parent object.
 * @param {Object} child
 * @param {Object} parent
 */
function setupChildNode(child, parent) {
    if (parent.name == null || parent.longitude == null || parent.latitude == null) {
        throw new Error(`Cannot add a child to a parent with name "${parent.name}", longitude "${parent.longitude}", and
        latitude ${parent.latitude}.`);
    }
    child.parent = parent.name;
    const lonValue = Math.random() * 10; 
    child.longitude = Math.random() < 0.5 ? parent.longitude + lonValue : parent.longitude - lonValue;
    const latValue = Math.random() * 10;
    child.latitude = Math.random() < 0.5 ? parent.latitude + latValue : parent.latitude - latValue;
}

function setupLine() {

}

/**
 * TODO: add unit tests
 * Return a generator that will provide the longitude and latitude for an object.
 * 
 * @param {number} initX - the longitude of the top left corner of the square.
 * @param {number} initY - the latitude of the top left corner of the square.
 * @param {number} spacing - how far apart to space a node from adjacent nodes in the square.
 * @return {Generator} 
 */
function * getCoordinatesGenerator(initX, initY, spacing) {
    yield {
        longitude: initX,
        latitude: initY
    }
    let x = 0;
    let y = 0;
    let dimension = 1;
    while (true) {
        if (x <= dimension) {
            yield {
                longitude: initX + (x++ * spacing),
                latitude: initY + (dimension * spacing)
            }
        } else {
            yield {
                longitude: initX + (dimension * spacing),
                latitude: initY + (y++ * spacing)
            }
        }
        if (y === dimension) {
            dimension++;
            x = 0;
            y = 0;
        }
    }
}
/*
If generator is done (for a dimension), pass the next dimension to next() and keep calling!
*/

//**************************************************
// SVG interface
//**************************************************

/** 
 * TODO: add unit tests
 * @return {Object} SvgCircle - A fully configured svg circle.
 */
function createSvgCircle(key, {longitude, latitude, object}, {r = 2, strokeWidth = 0.5} = {}) {
    keyIsStringAndValidNumber(key);
    if (longitude == null || latitude == null || object == null) {
        //console.log(`For circle with tree key: "${key}", longitude was: "${longitude}",
        //latitude was: "${latitude}", object was: "${object}"`)
    }
	const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
	circle.setAttribute('id', key);
	circle.setAttribute('class', object);
	circle.setAttribute('r', r);
    circle.setAttribute('stroke-width', strokeWidth);
    // Set coordinates and consider if they need to be translated
    longitude = parseFloat(longitude);
    latitude = parseFloat(latitude);
    if (gLonOffset !== null) {
        longitude -= gLonOffset;
    }
    if (gLatOffset !== null) {
        latitude -= gLatOffset;
    }
    circle.setAttribute('cx', longitude);
    circle.setAttribute('cy', latitude);
    return circle;
}
/** 
 * TODO: add unit tests
 * @return {Object} SvgLine - A fully configured svg line.
 */
function createSvgLine(sourceNode, targetNode, key, thisObject) {
    const svgLine = document.createElementNS('http://www.w3.org/2000/svg', 'line'); 
    if (sourceNode.longitude == null || sourceNode.latitude == null || targetNode.longitude == null ||
    targetNode.latitude == null) {
        console.log(`For line with tree key: "${key}", sourceNode.name was: "${sourceNode.name}",
        sourceNode.longitude was: "${sourceNode.longitude}", sourceNode.latitude was: "${sourceNode.latitude}",
        targetNode.name was: "${targetNode.name}", targetNode.longitude was: "${targetNode.longitude}",
        targetNode.latitude was: "${targetNode.latitude}"`)
        //throw new Error(`For line with tree key: "${key}", sourceNode.longitude was: "${sourceNode.longitude}",
        //sourceNode.latitude was: "${sourceNode.latitude}", targetNode.longitude was: "${targetNode.longitude}",
        //targetNode.latitudw was: "${targetNode.latitude}"`)
    }
    // Set coordinates and consider if they need to be translated
    let sourceLon = parseFloat(sourceNode.longitude);
    let sourceLat = parseFloat(sourceNode.latitude);
    let targetLon = parseFloat(targetNode.longitude);
    let targetLat = parseFloat(targetNode.latitude); 
    if (gLonOffset !== null) {
        sourceLon -= gLonOffset;
        targetLon -= gLonOffset;
    }
    if (gLatOffset !== null) {
        sourceLat -= gLatOffset;
        targetLat -= gLatOffset;
    }
    svgLine.setAttribute("x1", sourceLon); 
    svgLine.setAttribute("x2", targetLon);
    svgLine.setAttribute("y1", sourceLat); 
    svgLine.setAttribute("y2", targetLat);
    if (key == null && thisObject == null) {
        // key and thisObject weren't included, so this line doesn't represent a real object in the tree, so it's a parent-child line.
        svgLine.setAttribute("id", `${sourceNode.name}_${targetNode.name}`);
        svgLine.setAttribute("class", "parentChild");
        svgLine.setAttribute("stroke-width", 0.25);
        return svgLine;
    } else if (key != null && thisObject != null) {
        keyIsStringAndValidNumber(key);
        svgLine.setAttribute("id", key);
        const phaseCount = countPhases(thisObject.phases).toString();
        const domClass = `${thisObject.object} p${phaseCount}`;
        svgLine.setAttribute("class", domClass);
        svgLine.setAttribute("stroke-width", phaseCount);
        return svgLine;
    }
    throw new Error("key and thisObject arguments must be passed together or not at all");
}

//**************************************************
// TreeObject interface
//**************************************************

const treeObjectPrototype = {

    /* "Public" interface methods.*/

    /** 
     * TODO: add unit tests
     */
    update({parent=null, coords=null, to=null, from=null}) {
        const type = getType(this.data);
        if (type === "childNode") {
            if (parent == null) {
                throw new Error("A parent must be provided to configure a child node");
            }
            setupChildNode(this.data, parent);
        } else if (type == "configurationNode") {

        }
    },

    /* "Private" helper methods */
};

/**
 * Return a key value which has not been used in tree.
 * @return {string} key
 */
function getNewTreeKey(tree) { 
	let nextKey = Object.keys(tree).length;
	while(tree.hasOwnProperty(nextKey.toString())) {
		nextKey += 1;
	}
	return nextKey.toString();
}

// Fix this function. Some lines have CLOSED instead of ABCN or something.
function countPhases(p) {
	// Return the number of phases a line has.
	//return p.length
	let total = 0
	if (p.search('A') > -1) {total++}
	if (p.search('B') > -1) {total++}
	if (p.search('C') > -1) {total++}
	return total;
}

/** 
 * Return a TreeObject.
 * 
 * A TreeObject (which is not to be confused with a more general "tree object") is either:
 * 1) a copy of a component that is in the process of being added to the tree, OR
 * 2) a copy of an existing object in the tree.
 * 
 * @param {(string|Object)} input - either a key OR a map of properties to create this TreeObject.
 * @param {TreeWrapper} tree - the treeWrapper from which to create this TreeObject.
 * return {TreeObject} - Either a new component that does not exist in the tree, or a copy of an existing tree object 
 * inside of the treeWrapper argument.
 */
function createTreeObject(input, treeWrapper) {
    if (Object.getPrototypeOf(treeWrapper) !== treeWrapperPrototype) {
        throw new Error("treeWrapper argument must be an instance of TreeWrapper");
    }
    const tObject = Object.create(treeObjectPrototype);
    if (typeof(input) === "string") {
        keyIsStringAndValidNumber(input); // I don't like this
        const obj = treeWrapper.tree[input];
        if (obj != null) {
            tObject.key = input;
            tObject.data = deepCopy(obj);
            return tObject;
        }
        throw new Error(`The passed key argument: "${input}" to create the TreeObject does not exist in the treeWrapper.tree.`);
    } else if (typeof input === "object" && !Array.isArray(input)) {
        tObject.key = getNewTreeKey(treeWrapper.tree);
        tObject.data = deepCopy(input);
        if (tObject.data.name != null) {
            tObject.data.name += tObject.key;
        }
        return tObject;
    } 
    throw new Error("Input argument must be a string or an object.");
}

//**************************************************
// Table interface 
//**************************************************

/*
These are names of properties in most objects in writeFeeder.tree that should not be deleted from objects because
doing so might make that object hard to identify with reference to the rest of the data.
*/
const nonDeletableProperties = ["name", "object", "from", "to", "latitude", "longitude", "parent", "configuration"];
/* If these properties were to be modified for a given writeFeeder.tree object, it would require significantly modifying the 
other objects.  These properties ARE technically modifiable, but allowing the user to change them would require more work 
than I think is worth it. It is easier just to create a new node.
*/
const nonModifiableProperties = ["name", "object", "from", "to", "parent"];
const titleProperties = ["object"];
/* This array is used to determine if an object is a configuration node, based on the "object" property of that node. If a node
lacks the "object" property entirely, then I know its a configuration node.
Player is a configuration object. Recorder can have a parent, so it is NOT a configuration object.

Apparently nodes can be children of lines.
*/
const configObjectTypes = ["regulator_configuration", "transformer_configuration", "triplex_line_configuration", "line_configuration",
"volt_var_control", "line_spacing", "climate", "overhead_line_conductor", "underground_line_conductor", "triplex_line_conductor",
"player"];

/**
 * TODO: add unit tests, $().draggable make the text unfocusable
 * If an object has no name, just get the first property in the object.
 */
function createSelectionTable(ids, tWrapper) {
    const table = document.createElement("table");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody"); 

    const row = createRow({key: "Selected Elements"});
    Array.from(row.self.children).forEach(td => { td.classList.add("tableTitle") });
    row.self.children[1].setAttribute("colspan", "2");
    row.self.children[2].remove();

    tHead.append(row.self);
    table.append(tHead);
    table.append(tBody);
    table.classList.add("dataTable");
    ids.forEach(id => {
        let obj = tWrapper.tree[id];
        let name = obj.name != null ? obj.name : Object.keys(obj)[0];
        let button = document.createElement("button");
        button.textContent = "view";
        button.classList.add("modalButton");
        button.addEventListener("click", function() {
            let table = document.getElementById(`descriptionTable_${id}`);
            if (table == null) {
                const table = createDescriptionTable(id, tWrapper);
                table.id = `descriptionTable_${id}`;
                document.getElementById("descriptionTables").append(table);
            }           
        });
        let row = createRow({key: name, value: button, deletable: true}, document.getElementById(id));
        tBody.append(row.self);
    });
    if (window.jQuery != null) {
        table.style.left = "50vw";
        $(table).draggable();
    }
    return table;
}

/**
 * TODO: add unit tests, don't allow longitude and latitude to be editted for lines!,
 * turn all key inputs into plain text upon clicking save (would look nice), 
 * 
 * Bugs: $().draggable() makes text unfocusable via double click. Unfortunately,
 * this is set behavior of the library because the demo on the jQuery wesbsite behaves the same way. Users must right click
 * text in a table to select it.
 * 
 * The form element is only used to take advantage of the "required" form validation functionality that is native to the
 * browser.
 */
function createDescriptionTable(id, tWrapper) {
    const form = document.createElement("form");
    form.classList.add("formContainer");
    const table = document.createElement("table");
    table.classList.add("dataTable");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody");
    const buttonRow = document.createElement("tr");
    buttonRow.classList.add("buttonRow");
    const buttonCell = document.createElement("td");
    buttonCell.setAttribute("colspan", "3");
    form.append(table);
    table.append(tHead);
    table.append(tBody);
    tBody.append(buttonRow);
    buttonRow.append(buttonCell);
    const tObject = createTreeObject(id, tWrapper);
    if (getType(tObject.data) !== "line") {
        buttonCell.append(createButton({action: "move", tObject: tObject, tWrapper: tWrapper, tableBody: tBody}).self);
    }
    buttonCell.append(createButton({action: "delete", tObject: tObject, tWrapper: tWrapper, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "add", tObject: tObject, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "save"}).self);
    form.addEventListener("submit", function(event) {
        event.preventDefault();
        const svg = createAddableSvgData(tWrapper.insert(tObject));
        svg.drawTo(gViewport);
        alert("Object saved");
    });
    Object.keys(tObject.data).forEach(key => {
        let row;
        if (titleProperties.includes(key)) {
            row = createRow({key: key, map: tObject.data});
            Array.from(row.self.children).forEach(td => {
                td.classList.add("tableTitle");
            });
            tHead.append(row.self);
        } else {
            row = createRow({key: key, deletable: true, map: tObject.data});
            tBody.appendChild(row.self);
        }
    });
    if (window.jQuery != null) {
        table.style.left = "50vw";
        $(table).draggable();
    }
    return form;
}

/**
 * TODO: add unit tests
 */
 function destroyTables(ids) {
    ids.forEach(id => {
        const tableDiv = document.getElementById(id);
        Array.from(tableDiv.children).forEach(t => {
            tableDiv.removeChild(t);
        });
    });
}

const buttonPrototype = {

    /* Private helper methods */

    /**
     * TODO: update unit tests
     * Delete the TreeObject of this button from the TreeWrapper of this button
     */
    deleteObject() {
        let subWrapper;
        try {
            subWrapper = this.tWrapper.delete(this.tObject.key);
            createDeletableSvgData(subWrapper.tree).deleteFrom(gViewport);
        } catch (e) {
            if (confirm(e + " Alternatively, do you wish to delete this node and all of its immediately connected objects?")) {
                subWrapper = this.tWrapper.recursiveDelete(this.tObject.key);
                createDeletableSvgData(subWrapper.tree).deleteFrom(gViewport);
            }
        }
    },

    /**
     * TODO: add unit tests
     */
    validateArguments(args) {
        if (args.action === "move") {
            //if (args.tObject == null || args.tWrapper == null || args.tableBody == null) {
            //    throw new Error(`A button with a "${args.action}" action must have non-null tObject, tWrapper, and tableBody arguments`);
            //}
        } else if (args.action === "delete") {
            if (args.tObject == null || args.tWrapper == null || args.tableBody == null) {
                throw new Error(`A button with a "delete" action must have non-null tObject, tWrapper, and tableBody arguments`);
            }
        } else if (args.action === "add") {
            if (args.tObject == null || args.tableBody == null) {
                throw new Error(`A button with an "add" action must have non-null tObject and tableBody arguments`);
            }
        } else if (args.action !== "save") {
            throw new Error(`The action argument must match an existing action`);
        }
    }
}

/**
 * TODO: add unit tests, DON'T remove tObject argument, remove tWrapper argument
 */
function createButton({action, tableBody=null, tObject=null, tWrapper=null}) {
    const button = Object.create(buttonPrototype);
    button.validateArguments(arguments[0]);
    button.self = document.createElement("button");
    button.self.textContent = action;
    button.self.classList.add("modalButton");
    button.tObject = tObject;
    button.tWrapper = tWrapper;
    button.tableBody = tableBody;
    button.self.type = "button";
    switch (action) {
        case "move":
            button.self.addEventListener("click", function() {
                addMoveListener();
                //button.addMoveListener();
            });
            break;
        case "delete":
            button.self.classList.add("deleteButton");
            button.self.addEventListener("click", function() {
                button.deleteObject();                
                document.getElementById("descriptionTables").removeChild(tableBody.parentElement.parentElement);
            });
            break;
        case "add":
            button.self.addEventListener("click", function() {
                const row = createRow({key: "", deletable: true, map: tObject.data});
                tableBody.append(row.self);
            });
            break;
        case "save":
            button.self.type = "submit";
            break;
        default:
            throw new Error("The action argument must be a string that matches an existing action for this button.");
    }
    return button;
}

const rowPrototype = {

    /* Private helper methods */

    /**
     * Throw an error if arguments passed to createRow() were invalid.
     * @param {Object} args - an object containing the arguments that were passed to createRow()
     */
    validateArguments(args) {
        if (args.key != null && args.value != null && args.map != null) {
            throw new Error(`If there are key and map arguments, then the value of the row is determined by map[key] and passing a value
            argument is invalid`);
        } else if (args.map != null && args.map[args.key] === undefined && args.key !== "") {
            throw new Error("If a map argument is passed, the key argument should exist in that map.");
        } else if (args.key === "" && args.map == null) {
            throw new Error("If the key is an empty string, a map argument should be passed to the function");
        }
    },

    /**
     * Return false if the key already exists in the map or, otherwise return true.
     * @param {string} key - the incoming key that the user wants to write into the map belonging to this Row.
     * @return {boolean}
     */
    validateNewKey(key) {
        if (this.map[key] !== undefined || key === "") {
            return false;
        }
        return true;
    },

    /** 
     * Return false if the current key is an empty string, otherwise return true.
     * @return {boolean}
     */
    validateCurrentKey() {
        return this.key === "" ? false : true;
    },

    /**
     * Update a key in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new key that should be written to the map, if it is valid.
     */
    updateMapKey(input) {
        const newKey = input.value.trim();;
        if (this.validateNewKey(newKey)) {
            this.map[newKey] = this.map[this.key] != null ? this.map[this.key] : "";
            delete this.map[this.key];
            this.key = newKey;
        } else {
            alert(`Please enter a unique, valid key for this object.`);
            input.value = this.key;
        } 
    },
    /**
     * Return an HTMLTableCellElement.
     * @return {HTMLTableCellElement}
     */
    getKeyElement() {
        const td = document.createElement("td");
        if (this.key === "") {
            const input = document.createElement("input");
            input.classList.add("modalInput");
            td.appendChild(input);
            input.required = true;
            input.pattern = "[\\s]*[\\S]+.*";
            //if (input.validity.valueMissing) {
            //    input.setCustomValidity("Please fill out this field. Alternatively, delete this row.");
            //}
            const that = this;
            input.addEventListener("change", function() {
                that.updateMapKey(this);
            });
        } else {
            td.textContent = this.key;
        } 
        return td;
    },

    /** 
     * Return true if the value is valid for the Row (based on the key of that Row), otherwise return false.
     * @param {string} value - a value for a corresponding key that should be validated based on the key.
     * @return {boolean}
     */
    validateNewValue(value) {
        if (this.key === "longitude" || this.key === "latitude") {
            return !isNaN(parseFloat(value));
        }
        return true;
    },

    /** 
     * Update a value in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new value that should be written to the map, if the value is valid.
     */
    updateMapValue(input) {
        if (!this.validateCurrentKey()) {
            alert("Please enter a valid key for this row before entering a value.");
            input.value = "";
            return;
        }
        const newValue = input.value.trim();
        if (this.validateNewValue(newValue)) {
            this.map[this.key] = newValue;
        } else {
            alert(`The value "${newValue}" is invalid for for the key "${this.key}" in the table.`);
            input.value = this.map[this.key];
        }
    },
    /** 
     * Return an HTMLTableRowElement.
     * @param {Array} nonModifiableProperties - a hard-coded array of properties that the user shouldn't be able to modify.
     * @return {HTMLTableRowElement}
     */
    getValueElement(nonModifiableProperties) {
        const td = document.createElement("td");
        if (typeof(this.value) === "string") {
            td.textContent = this.value;
            return td;
        } else if (this.value instanceof HTMLElement) {
            td.append(this.value);
            return td;
        } else if (this.value == null) {
            if (this.map == null) {
                return td;
            } else {
                const value = this.key === "" ? "" : this.map[this.key];
                if (nonModifiableProperties.includes(this.key)) {
                    td.textContent = value;
                } else {
                    const input = document.createElement("input");
                    if (this.key === "longitude") {
                        input.dataset.coordinate = "longitude";
                    } else if (this.key === "latitude") {
                        input.dataset.coordinate = "latitude";
                    }
                    input.classList.add("modalInput");
                    td.appendChild(input);
                    const that = this;
                    input.addEventListener("change", function() {
                        that.updateMapValue(this);
                    });
                    input.value = value;
                }
                return td;
            }
        }
        throw new Error("Invalid value was provided for this row");
    },

    /** 
     * TODO: add unit tests
     * Return an HTMLTableRowElement.
     * @param {boolean} deletable - whether or not the returned <td> should have a delete button element child.
     * @param {Array} nonDeletableProperties - a hard-coded array of properties that the user should not be able
     * to delete from a TreeObject.
     * @return {HTMLTableRowElement}
     */
    getDeleteElement(deletable, nonDeletableProperties) {
        const td = document.createElement("td");
        if (deletable === true && !nonDeletableProperties.includes(this.key)) {
            const btn = document.createElement("button");
            btn.innerHTML = "&#9587;"
            btn.setAttribute("class", "modalButton deleteButton"); 
            td.appendChild(btn);
            const that = this;
            btn.addEventListener("click", function() {
                that.delete();
            });
        } 
        return td;
    },

    /**
     * TODO: update unit tests
     * Delete the row from the table. Delete the key from the map, if there was a map.
     */
    delete() {
        this.self.parentElement.removeChild(this.self);
        if (this.map != null) {
            delete this.map[this.key];
        } 
        if (this.element != null) {
            removeSelected(this.element);
            //document.getElementById(this.element).classList.remove("selected");
            const table = document.getElementById(`descriptionTable_${this.element.id}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
            if (Object.keys(getSelectedWrapper().tree).length === 0) {
                destroyTables(["selectionTable"]);
            }
        }
    },

    /**
     * TODO: add unit tests
     */
    //updateInput() {
    //    //need a direct reference to the input of the row for convenience.
    //}
}

/** 
 * Return a Row that can be appended to a table.
 * 
 * @param {string} key - the key of the row, which must be a property of the map argument if the map argument is not null.
 * @param {string|HTMLElement} - an optional value of the row.
 * @param {Object} map - an optional object that contains the data being manipulated by all of the rows. 
 * @param {boolean} deletable - whether or not the row should have a delete button.
 * @return {Row} - A wrapper object around the HTMLTableRowElement.
 */ 
function createRow({key, value=null, map=null, deletable=false}) {
    const obj = Object.create(rowPrototype);
    obj.validateArguments(arguments[0]);
    obj.key = key;
    obj.value = value;
    obj.map = map;
    obj.self = document.createElement("tr");
    obj.self.append(obj.getDeleteElement(deletable, nonDeletableProperties));
    obj.self.append(obj.getKeyElement());
    obj.self.append(obj.getValueElement(nonModifiableProperties));
    if (arguments[1] != null) {
        obj.element = arguments[1];
    }
    return obj;
}

//**************************************************
// Initialization
//**************************************************

function attachMouseListeners() {
    let downEvent;
    document.getElementById("svgContainer").addEventListener("mousedown", function(event) {
        downEvent = event;
    });
    document.getElementById("svgContainer").addEventListener("mouseup", function(upEvent) {
        svgClick(downEvent, upEvent);
    });
}


//setTimeout(main,100)
(() => {
    //buildFeeder();
    //const t0 = performance.now();

    gTreeWrapper = createTreeWrapper(writeFeeder.tree);
    gTreeWrapper.insertCoordinates(500, 0, 5);
    //createViewport(writeFeeder.tree, document.getElementById("svgContainer"));
    createViewport(gTreeWrapper, document.getElementById("svgContainer"));
    gViewport = document.getElementsByClassName('svg-pan-zoom_viewport')[0];
    const svg = createAddableSvgData(gTreeWrapper);
    svg.drawTo(gViewport);

    //document.getElementById("svgContainer").addEventListener("click", function(event) {
    //    svgClick(event);
    //});
    attachMouseListeners();

    attachHandlers();
    // Interface setup
    document.getElementById("searchInput").addEventListener("change", getSearchResults);
    // jQuery
    if (window.jQuery != null) {
        applyJQueryStyles();
    } else {
        disableJQueryFunctionality();
    }
    document.getElementById('loadingMessage').style.display = 'none'
    /* 
    const t1 = performance.now();
    const time = t1 - t0;
    console.log(`Tree rendering time was ${time} ms`);
    */
    
    /*
    setTimeout(function() {
        const deleteSvgData = createDeletableSvgData(gTreeWrapper.tree);
        deleteSvgData.deleteFrom(viewport);
    }, 2000);
    */
})();

//ADD PROMPT TO SAVE CHANGES BEFORE EXIT
{% if showFileMenu %}
	window.onbeforeunload = function(e) {
        if (JSON.stringify(readFeeder) !== JSON.stringify(writeFeeder)) {
            const confirmationMessage = `It looks like you have been editing something. 
            If you leave before saving, your changes will be lost.`;
            return confirmationMessage;
        }
	};
{% endif %}
</script>
<!--<script type='text/javascript' src='/static/distDataValidation.js'></script>-->
{% if spec %}{{ spec | safe }}{% endif %}