<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<style >
            /* Define global css variables */
            :root {
                --header-height: 25px;
                --header-padding-top: 10px;
                --header-padding-bottom: 10px;
            }
			* { 
                font-family: Helvetica, Arial, Sans-Serif;
            }
			div.divButton {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				cursor: pointer;
				cursor: hand;
				position:fixed;
				width:30px;
				height:30px;
				text-align:center;
				font-size:30px;
				line-height:30px;
				color:white;
                background-color: dimgrey;
                left: 5px;
			}
            #scaleButton {
                top: 175px;
            }
			body {
                /*width: 100%;
                height: 100%;*/
                margin:0px;
            }
			a {
				text-decoration: none;
                color: mediumseagreen;
                /*color: black;*/
			}
            a:visited {
                color: seagreen;
            }

            /* SVG */

            #interfaceContainer {
                position: relative;
            }

            /* This is the element that acts as a hook for svg-pan-zoom.js to attach a viewport, which it creates itself */
			#svgContainer {
                /* width must be 100%, meaning 100% of the document */
				width: 100%; 
                /* height must be manually set to a hard value */
				height: calc(100vh - var(--header-height) - var(--header-padding-bottom) - var(--header-padding-top));
                /* overflow: hidden is set by svg-pan-zoom.js itself. No need to change that here. */
			}
			#saveButton {
				float:right;
			}

            div#loadingMessage {
                width: 100%;
                height: 100%;
				/*background-color: rgba(0,0,0,0.4); */
                background-color: white;
                position: fixed;
                top: 0px;
            }

			/* Load Spinner */

			.loader {
				margin: 60px auto;
				font-size: 10px;
				position: relative;
				text-indent: -9999em;
				border-top: 1.1em solid rgba(255, 255, 255, 0.2);
				border-right: 1.1em solid rgba(255, 255, 255, 0.2);
				border-bottom: 1.1em solid rgba(255, 255, 255, 0.2);
				border-left: 1.1em solid #ffffff;
				-webkit-transform: translateZ(0);
				-ms-transform: translateZ(0);
				transform: translateZ(0);
				-webkit-animation: load8 1.1s infinite linear;
				animation: load8 1.1s infinite linear;
			}
			.loader,
			.loader:after {
				border-radius: 50%;
				width: 10em;
				height: 10em;
			}
			@-webkit-keyframes load8 {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}
			@keyframes load8 {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}

            /**************************************************
            // Header and menu links
            **************************************************/

			#header {
				width:100%;
				height: var(--header-height);
				padding-top: var(--header-padding-top);
				padding-bottom: var(--header-padding-bottom);
				background:black;
                /*position: absolute;*/
				/*min-width:1000px;*/
			}
            #helpDiv a {
                color: white;
            }
			/*#menuLeft{ height:40px; float:left; font-size:medium; color:white; margin-left:5px;}*/
			#menuRight{ 
				/*height:40px;
				font-size:medium;
				color:white;*/
				float:right;
				display:flex;
				/*justify-content: space-between;
				width: 162px*/
			}
			/*#arrow { font-size:8pt; position:absolute; margin-top:2px; margin-left:4px; display:inline; }*/
            .headerDiv {
                margin-right: 15px;
                cursor: pointer;
            }
			ul.menu {
				position: absolute;
				top: 100%;
				left: 0;
				z-index: 1000;
				min-width: 100px;
				padding: 5px 0px 5px 0px;
				margin: 0px;
				list-style: none;
				display: none;
				text-align:left;
				background-color:#F8F8F8;
				padding:0;
				/*border: 1px solid #CCC;*/
				-webkit-border-radius: 5px;
				-moz-border-radius: 5px;
				border-radius: 5px 0px 5px 5px;
				-webkit-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				-moz-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				-webkit-background-clip: padding-box;
			}
			ul.menu.right { 
                right:0;
                left:auto;
                padding:5px 0px 5px 0px;
                overflow-y:auto;
                overflow-x:hidden;
                max-height:550px; 
                cursor: pointer;
            }
			ul.menu.left { right:auto; left:auto; padding:0 0 0 0; }
			ul.menu.center { right:auto; left:-45%; }
			ul.menu li { 
                padding: 4px; 
                }
			ul.menu li:hover { background:green; color:white; }
			ul.menu li:hover a { color:white; }
			ul.menu a { 
                display:block;
                color:black;
                /*padding:4px;*/
                }
			ul.menu a:hover {color:white;}
			ul.menu { display:block; color:black; padding:4px; }
			ul.menu ul.menu:hover, ul.menu:visited:hover { color:white; }
			div.buttonGroup { display:inline-block; position:relative; }
			button.pill {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				color:white;
				font-size:medium;
				width: auto;
				height:35px;
				margin: 0px;
				margin-top:-5px;
				padding:0.3em;
				border-radius: 5px 5px 0 0;
				background-color:#E0E0E0;
				display:inline-block;
				border:none;background:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;
				white-space: nowrap;
				display:inline-block;
                cursor: pointer;
			}
			button.pill:hover{background:transparent;}

            /**************************************************
            // Modal Dialogs
            **************************************************/

            #loadModalTable {
                width: 890px;
            }
            /*#milsoftInput {
                width: 100%;
            }*/
            #progressModalCancel {
                background-color: crimson;
            }
            #progressModal {
                z-index: 1;
            }
            #massAddModal .modalContent {
                width: 400px;
            }
            #climateModal label {
                white-space: nowrap;
            }
            #anonymizeModal {
                white-space: nowrap;
            }
			.modal {
                position: fixed;
                top: 0px;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
				background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
			}
	 		.modalContent {
                padding: 20px;
                border-radius: 10px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: space-evenly;
				background-color: #fefefe;
                /*height: 380px;*/
                overflow: hidden;
			}
            .modalInput {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
                width: 100%;
            }
            .modalInputLine {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
            }
            .modalButton {
                font-size: medium;
                background-color: seagreen;
                -webkit-border-radius: 5px;
                -moz-border-radius: 5px;
                border-radius: 5px;
                border: none;
                color: white;
                cursor: pointer;
                padding: 4px 6px 4px;
            }
            #cancelButton {
                background-color: crimson;
            }
            .modalContent td:nth-of-type(2) {
                text-align: right;
            }
            .modalTableHeader {
                text-align: left;
            }
            .modalTableRow {
                width: 50%;
            }
            .scrollableList {
                overflow: auto;
                height: 240px;
                list-style-type: none;
                margin: 0px 0px 0px 20px;
                padding: 0;
                cursor: pointer;
            }
            .feederItem {
                padding: 5px 5px 5px 5px;
                margin: 10px 0px 10px 0px;
            }
            .feederItem:hover {
                color: white;
                background-color: green;
            }
            /*
            input:valid {
                border: 1px solid white; 
            }
            */
            input:invalid {
                /*Aborder: 1px solid red;*/
            }            

            /* Tree tables */

            .buttonRow {
                /*text-align: center;*/
            }
            .buttonRow button {
                margin-right: 5px;
            }
            /*
            .treeTable {
                background-color: white; 
            }
            .treeTable tr {
            }
            .treeTable tr:last-child {
                border: 0px;
            }
            */
            thead td {
                
            }
            .tableInput {
                font-size: small;
                background-color: gainsboro;
                padding: 3px;
                border: 0px;
            }
            .deleteButton {
                background-color: #CC0000;
                /*padding: 1px 7px 1px 7px;*/
            }
            /* TODO: might need to delete this rule */
            .editButton {
                font-size: small;
                /*width: 100%;*/
            }

			/* dataTable */

            #descriptionTables {
                position: absolute;
                top: 0px;
                height:0px;
            }

            #selectionTable {
                position: absolute;
                top: 0px;
                height:0px;
            }

            .formContainer {
				/*position: fixed;*/
				/*top: 55px;*/
                height:0px;
				/*right: 5px;*/
            }

            /* Don't set overflow-y to hidden */
			.dataTable {
                position: fixed;
				top: 55px;
				border:1px solid black;
				border-collapse: collapse;
                display: inline-block;
                overflow-x: hidden;
				max-height: 90vh;
                right: 10px;
			}
            .dataTable tr {
                border-bottom: 1px solid black;
            }
            .dataTable tr:last-child {
                border: 0px;
            }
            /*.dataTable p {
                margin: 0px;
            }*/
            .tableTitle {
                background-color: black;
                color: white;
            }
			tbody {
				/*border: 1px solid black;*/
                border-collapse: collapse;
			}
			td {
				background:white;
				padding: 5px;
				border-collapse: collapse;
			}
			th {
				/*font-weight: normal;*/
				/*background:black;*/
				/*color:white;*/
				padding: 5px;
			}
			/*
            #editButtonRow button {
				font-size: small;
				color: white;
				background: seagreen;
				padding: 5px;
				border-radius: 5px;
				width: 100%;
			}
            */
            /*
			#editButtonRow button:hover {
				outline:0;
				outline: none; 
				background:mediumseagreen;
			}
            */
        </style>
        <link rel="stylesheet" href="/static/jquery-ui.min.css">
        <script type="text/javascript" src="/static/jquery.js"></script>
        <script type="text/javascript" src="/static/jquery-ui.min.js"></script>
		<script type='text/javascript' src='/static/svg-pan-zoom.js'></script>
		{% if jasmine %}{{ jasmine | safe }}{% endif %}
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Largest.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Norfork.js'></script> -->
	</head>
    <body>
        <div id="interfaceContainer">
            <div id="loadingMessage">
                <p style="font-size:60pt; text-align:center; width:100%;">Feeder Loading...</p>
            </div>
            <div id="descriptionTables"></div>
            <div id="selectionTable"></div>
            <!-- Controls -->
            <div style="top:55px;" class='divButton' onclick='window.panZoom.zoomIn()' title='Zoom In'>+</div>
            <div style="top:95px;" class='divButton' onclick='window.panZoom.zoomOut()' title='Zoom Out'>-</div>
            <div style="top:135px;" class='divButton' onclick='window.panZoom.reset()' title='Reset Zoom'>R</div>
            <div id="scaleButton" class='divButton' title='Scale To'>S</div>
            <!-- <div style='background:navy; top:215px; left:5px' id='saveLink' class='divButton' onclick='saveSvg()' title='Save File' download>S</div> -->
            <!-- Menu Bar -->
            <div id='header'>
                <div id="menuRight">
                    <div id="helpDiv" class="headerDiv">
                        <div class="buttonGroup">
                            <button class='pill' type = 'submit'>
                                <a id='helpButton' href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit' target='_blank'>Help</a>
                            </button>
                        </div>
                    </div>
                    <div id="editDiv" class="headerDiv">
                        <div class="buttonGroup">
                            <button id="addOps" class='pill' onclick='dropPill(this, "Edit")'>Edit &#x25BE;</button>
                            <ul id="editMenu" class='menu right' style="display: none">
                                <!--<li>Zoom To Fit</li>-->
                                <!--<li>Zoom Reset</li>-->
                                <li data-web>Add AMI Profiles...</li>
                                <li data-web>Anonymization...</li>
                                <li>Attachments...</li>
                                <li data-web>Climate...</li>
                                <li>Find...</li>
                                <li>Mass Add...</li>
                                <li>Mass Edit...</li>
                                <li data-web>Scada Loadshapes...</li>
                                <li>Static Loads to Houses</li>
                            </ul>
                        </div>
                    </div>
                    <div id="addDiv" class="headerDiv">
                        <div class="buttonGroup">
                            <button id="addOps" class='pill' onclick='dropPill(this, "Add")'>Add &#x25BE;</button>
                            <ul id='componentList' class='menu right' style="display: none">
                        </div>
                    </div>
                    {% if showFileMenu %}
                    <div id="fileDiv" class="headerDiv">
                        <div class='buttonGroup'>
                            <button id="fileOps" class='pill' onclick='dropPill(this, "File")'>File &#x25BE;</button>
                            <ul id='fileMenu' class='menu right' style="display: none">
                                <li data-web>Save</li>
                                <li>View Raw Data</li>
                                <li data-web>Rename</li>
                                <li data-web>Load from Model...</li>
                                <li data-web>New Blank Feeder...</li>
                                <li data-web>Windmil Conversion...</li>
                                <li data-web>GridLAB-D Conversion...</li>
                                <li data-web>CYMDIST Conversion...</li>
                            </ul>
                        </div>
                    </div>
                    {% endif %}
                </div>
            </div>
            <!-- Svg container -->
            <div id="svgContainerWrapper" style="height: auto;">
                <svg id='svgContainer' xmlns='http://www.w3.org/2000/svg'>
                    <!--
                        line.selected, circle.selected {stroke:lime;}
                    -->
                    <style type="text/css">
                        <![CDATA[
                        .house {fill:blue;}
                        .triplex_meter {fill:orange;}
                        .underground_line {stroke:gray;}
                        .transformer {stroke:orange;}
                        .regulator {stroke:red;}
                        line {stroke:black;}
                        line.parentChild {stroke:LightGrey;}
                        circle {stroke:white; fill:gray;}
                        .undefined, .regulator_configuration, .transformer_configuration, .triplex_line_configuration, .line_configuration, .volt_var_control, .line_spacing, .climate, .overhead_line_conductor, .underground_line_conductor, .triplex_line_conductor, .player, .schedule {fill: #bfbfbf;}
                        ]]>
                    </style>
                </svg>
            </div>
            <!-- Modals -->
            <div id='findModal' class="modal" style="display: none">
                <div class='modalContent'>
                    <table>
                        <tr>
                            <!--<td colspan="2">Term</td>-->
                            <!--<td>Term</td>-->
                            <td colspan="2"><input id='searchInput' type='text' value="Enter a search term" class="modalInput"></td>
                            <td id="searchCount"></td>
                        </tr>
                        <tr>
                            <td>Key of current object:</td>
                            <td id="foundElementKey"></td>
                        </tr>
                        <tr>
                            <td><input type="checkbox" id="showTableOnFind">Show table on view</td>
                        </tr>
                        <tr>
                            <td><button id="findPrevious" class="modalButton">Previous</button></td>
                            <td><button id="findNext" class="modalButton">Next</button></td>
                            <td><button class="modalButton" onclick='toggleElementDisplay("findModal")'>Close</button></td>
                        </tr>
                    </table>
                </div>
            </div>
            <div id="progressModal" class="modal" style="display: none">
                <div class="modalContent">
                    <img src="/static/spinner.gif">
                    <h2>text...</h2>
                    <button class="modalButton" id="progressModalCancel">Cancel</button>
                </div>
            </div>
            <div id="loadModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table id="loadModalTable">
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Public Feeders</th>
                                <th class="modalTableHeader modalTableRow">My Feeders</th>
                            </tr>	
                            <tr>
                                <td class="modalTableRow"> 
                                    <ul id="publicFeederList" class="scrollableList"></ul>
                                </td>
                                <td class="modalTableRow"> 
                                    <ul id="userFeederList" class="scrollableList"></ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <button onclick="toggleElementDisplay('loadModal')" class="modalButton">Cancel</button>
                </div>
            </div>
            <div id="blankFeederModal" class="modal" style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'blankFeederForm'}); return false;"
                    action="/newBlankFeeder/{{thisOwner}}" id="blankFeederForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <input type='hidden' name='referrer' value='distribution'/>
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Blank Feeder</th>
                                </tr>
                                <tr>
                                    <td><label for="blankFeederInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="blankFeederInput" name='feederNameNew' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('blankFeederModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Create</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='milsoftModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'milsoftForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'milsoftInput'}); return false;"
                    action="/milsoftImport/{{thisOwner}}" id="milsoftForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Milsoft Conversion</th>
                                </tr>
                                <tr>
                                    <td><label for="milsoftInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="milsoftInput" name='feederNameM' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Data File (.std)</td>
                                    <td><input type='file' required id="stdFile" name='stdFile' accept='.std' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td>Equipment File (.seq)</td>
                                    <td><input type='file' required id="seqFile" name='seqFile' accept='.seq' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('milsoftModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table> 
                    </form>
                </div>
            </div>
            <div id='gridlabdModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'gridlabdForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'gridlabdInput'}); return false;"
                    action="/gridlabdImport/{{thisOwner}}" id="gridlabdForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">GridLab-D Conversion</th>
                                </tr>
                                <tr>
                                    <td><label for="gridlabdInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="gridlabdInput" name='feederNameG' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Data File (.glm)</td>
                                    <td><input type='file' required id="csvFile" name='glmFile' accept='.glm' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('gridlabdModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='cymeModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'cymeForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'cymeInput'}); return false;"
                    action="/cymeImport/{{thisOwner}}" id="cymeForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Cyme Conversion</th>
                                </tr>
                                <tr>
                                    <td><label for="cymeInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the 'required' attribute-->
                                        <input type='text' required id="cymeInput" name='feederNameC' class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Network File (.mdb)</td>
                                    <td><input type='file' required id="mdbNetFile" name='mdbNetFile' accept='.mdb' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('cymeModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id="scadaModal" class="modal" style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'scadaForm', pollUrl:'/checkScadaLoadshape/{{thisModelName}}'}); return false;"
                    action="/scadaLoadshape/{{thisOwner}}/{{thisFeederName}}" id="scadaForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Scada Loadshapes</th>
                                    <th style='float:right;'>
                                        <a href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit#scada-loadshapes' target='_blank'>Format Help</a>
                                    </th>
                                </tr>
                                <tr>
                                    <td>File containing Scada load data (.csv)</td>
                                    <td><input type='file' required id="scadaFile" name='scadaFile' accept='.csv' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td colspan='100%'>Note: Model "Simulation Start Date" should lie within the Scada load's dates.</td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('scadaModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='amiModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'amiForm', pollUrl:'/checkLoadModelingAmi/{{thisModelName}}'}); return false;"
                    action="/loadModelingAmi/{{thisOwner}}/{{thisFeederName}}" id="amiForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">AMI Profiles</th>
                                    <th style='float:right;'>
                                        <a href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit' target='_blank'>Format Help</a>
                                    </th>
                                </tr>
                                <tr>
                                    <td>File containing AMI load data (.csv)</td>
                                    <td><input type='file' required id="amiFile" name='amiFile' accept='.csv' class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td colspan='100%'>Note: Model "Simulation Start Date" should lie within the AMI profiles's dates.</td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('amiModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='massAddModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="massAdd(); return false;">
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Mass Add</th>
                                </tr>
                                <tr>
                                    <td>Add component:</td>
                                    <td><select id='componentSelect'></select></td>
                                </tr>
                                <tr>
                                    <td>To each:</td>
                                    <td><select id='massAddTargetSelect'></select></td>
                                </tr>
                                <tr>
                                    <td>With probability for each attachment (float between 0.0 and 1.0):</td>
                                    <td><input type='text' pattern="^(1.0)|(0?(\.\d+))$" required id='percent' value='1.0' class="modalInput"/></td>

                                </tr>
                                <tr>
                                    <td><button onclick="toggleElementDisplay('massAddModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Apply</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='massEditModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader">Mass Edit</th>
                            </tr>
                            <tr>
                                <td>For each object of type</td>
                                <td><select id='massEditTargetSelect'></select></td>
                                <td>with attribute</td>
                                <td><input type='text' id='massEditAttribute' class="modalInput"></td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="addTo">Add value to attribute</td>
                                <td><input type='text' id='addToValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="delete">Delete Attribute</td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="change">Change attribute to</td>
                                <td><input type='text' id='changeValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            </tr>
                            <tr>		
                                <td><input type="radio" name="attributeOperation" value="multiplyBy">Multiply attribute by</td>
                                <td><input type='text' id='multiplyValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                                <td style="text-align: center" >and add</td>
                                <td><input type='text' id='andAddValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td>Or</td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="addAttribute"> Add new attribute</td>
                                <td><input type='text' id='newAttributeKey' class="modalInput"></td>
                                <td style="text-align: center">with value</td>
                                <td><input type='text' id='newAttributeValue' pattern='^0\.\d+|1(\.0+)?$' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td colspan="2">
                                    <button onclick="toggleElementDisplay('massEditModal')" class="modalButton" style="float: right">Cancel</button>
                                </td>
                                <td>
                                    <button onclick="massEdit();" class="modalButton" style="float: left">Apply</button>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id='attachmentsModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <table>
                        <tbody>
                            <tr>
                                <td><select id='attachmentSelect'></select></td>
                            </tr>
                            <tr>
                                <td><button onclick="toggleElementDisplay('attachmentsModal')" class="modalButton">Cancel</button></td>
                                <td><button onclick="toggleElementDisplay('attachmentsModal'); editAttachment()" class="modalButton">Select</button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id='editAttachmentModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <table>
                        <tbody>
                            <tr>
                                <td id='attachmentTd'></td>
                            </tr>
                            <tr>
                                <td>
                                    <textarea rows='25' cols='80' id='editAttachmentBox'></textarea>
                                </td>
                            </tr>
                            <tr>
                                <td><button onclick="toggleElementDisplay('editAttachmentModal')" class="modalButton">Cancel</button></td>
                                <td><button onclick="saveAttachment(); toggleElementDisplay('editAttachmentModal');" class="modalButton">Save</button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id='climateModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'climateForm', pollUrl:'/checkClimateChange/{{thisOwner}}/{{thisModelName}}'}); return false;"
                    action="/climateChange/{{thisOwner}}/{{thisFeederName}}" id="climateForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <!--<input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>-->
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="modalTableHeader modalTableRow">Climate Change</th>
                                </tr>
                                <tr>
                                    <td>
                                        <input id='historicalImport' type='radio' name='climateImportOption' value='historicalImport'>
                                        <label for='historicalImport'>Historical Weather</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td><label for='startDate'>Start Date (YYYY-MM-DD):</label></td>
                                    <td><input id='startDate' type='text' name='startDate' pattern='^\d{4}-\d{2}-\d{2}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td><label for='endDate'>End Date (YYYY-MM-DD):</label></td>
                                    <td><input id='endDate' type='text' name='endDate' pattern='^\d{4}-\d{2}-\d{2}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td><label for='airport'>Airport Code:</label></td>
                                    <td><input id='airport' type='text' name='airport' pattern='^[A-Z]{3}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td>
                                        <input id='tmyImport' type='radio' name='climateImportOption' value='tmyImport'>
                                        <label for='tmyImport'>tmy Import</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td><label for='zipCode'>Zip Code:</label></td>
                                    <td><input id='zipCode' type="text" name="zipCode" pattern='^\d{5}$' class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td><button type="button" onclick="toggleElementDisplay('climateModal')" class="modalButton">Cancel</button></td>
                                    <td><button type="submit" class="modalButton">Apply</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id='anonymizeModal' class='modal' style="display: none">
                <div class='modalContent'>
                    <form onsubmit="submitForm({formId:'anonymizeForm', pollUrl:'/checkAnonymize/{{thisOwner}}/{{thisModelName}}'}); return false;"
                    action='/anonymize/{{thisOwner}}/{{thisFeederName}}' id="anonymizeForm">
                        <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                        <!--<input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>-->
                        <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                        <!--<input type='hidden' name='referrer' value='distribution'/>-->
                        <table>
                            <tbody>
                                <tr><th>Anonymization</th></tr>
                                <tr><th class="modalTableHeader">Names and labels:</th></tr>
                                <tr>
                                    <td>
                                        <select name='anonymizeNameOption'>
                                            <option value="noChange">No change</option>
                                            <option value="pseudonymize">Pseudonymize</option>
                                            <option value="randomize">Randomize</option>
                                        </select>
                                    </td>
                                </tr>
                                <tr><th class="modalTableHeader">Locations:</th></tr>
                                <tr>
                                    <td>
                                        <input type='radio' id='noChange' name='anonymizeLocationOption' value='noChange' checked>
                                        <label for='noChange'>No Change</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='radio' id='translation' name='anonymizeLocationOption' value='translation'>
                                        <label for='translation'>Translate</label>
                                    </td>
                                </tr>
                                <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='translateRight' class="modalInputLine"> [ft] to the right and</td></tr>
                                <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='translateUp' class="modalInputLine"> [ft] up with a</td></tr>
                                <tr><td><input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='rotate' class="modalInputLine"> [degree] rotation.</td></tr>
                                <tr>
                                    <td>
                                        <input type='radio' id='randomize' name='anonymizeLocationOption' value='randomize'>
                                        <label for='randomize'>Random (Force Layout)</label>
                                    </td>
                                </tr>
                                <tr><th class="modalTableHeader">Electrical properties:</th></tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='modifyLengthSize' name='modifyLengthSize' value='modifyLengthSize'>
                                        <label for='modifyLengthSize'>Modify conductor length and cable size</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='smoothLoadGen' name='smoothLoadGen' value='smoothLoadGen'>
                                        <label for='smoothLoadGen'>Smooth AMI Loadshapes</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='shuffleLoadGen' name='shuffleLoadGen' value='shuffleLoadGen'>
                                        <label for='shuffleLoadGen'>Shuffle loads and generators:</label>
                                        <input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='shufflePerc' class="modalInputLine"> [%]</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type='checkbox' id='addNoise' name='addNoise' value='addNoise'>
                                        <label for='addNoise'>Add noise:</label>
                                        <input type='text' pattern="^[+-]?\d+(\.\d+)?$" name='noisePerc' class="modalInputLine"> [%]</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <button type="button" onclick="toggleElementDisplay('anonymizeModal')" class="modalButton">Cancel</button>
                                        <button type="submit" class="modalButton" style="float: right">Apply</button>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <!-- Modals-->
        </div>
	</body>
</html>
<script id='componentsInsert'>const gComponents = {% if components %}{{ components | safe }}{% else %}null{% endif %}; 
</script>
<script id='feederInsert'>const readFeeder = {% if thisFeederData %}{{ thisFeederData | safe }}{% else %}null{% endif %}; 
</script>
<script id='panZoomInsert'>
</script>
<script type='text/javascript'>
//"use strict";
let thisFeederName = "{% if thisFeederName %}{{ thisFeederName | safe }}{% else %}null{% endif %}";
const thisFeederNum = {% if thisFeederNum %}{{ thisFeederNum | safe }}{% else %}null{% endif %}; 
const thisModelName = "{% if thisModelName %}{{ thisModelName | safe }}{% else %}null{% endif %}"; 
const thisOwner = "{% if thisOwner %}{{ thisOwner | safe }}{% else %}null{% endif %}"; 
const publicFeeders = {% if publicFeeders %}{{ publicFeeders | safe }}{% else %}null{% endif %};
const userFeeders = {% if userFeeders %}{{ userFeeders | safe }}{% else %}null{% endif %}; 
const writeFeeder = deepCopy(readFeeder);
// The global gTree can only be created after the entire file has been parsed.
let gTree;
let gSelection;
let gViewport; 
let gOffsetX;
let gOffsetY;
let gLongitudeRange;
let gLatitudeRange;
let gDrawScaleFactor;
let gDownX;
let gDownY;
// Scale that all SVG objects are drawn at
let gScaleLevel = 1.0; 
//**************************************************
// Selection Interface
//**************************************************

const selectionPrototype = {

    /* Public methods */

    hasId(id) {
        if (this.selectedElements.find(e => e.id === id) != null) return true;
        return false;
    },
    remove(element) {
        const elements = this.selectedElements.filter(e => e.id === element.id);
        if (elements.length === 0) {
            throw new Error("Remove operation failed. The element argument does not exist in this selection.");
        }
        elements.forEach(e => {
            e.classList.remove("selected");
            Array.from(e.children).forEach(child => {
                e.removeChild(child);
            })
            this.selectedElements.splice(this.selectedElements.indexOf(e), 1);
        });
    },
    add(element) {
        if (this.selectedElements.includes(element)) {
            throw new Error("Add operation failed. The element argument already exists in this selection.");
        } else if (element.classList.contains("selected")) {
            throw new Error("Add operation failed. The element argument already has the 'selected' class.");
        }
        element.classList.add("selected");
        this.addAnimation(element);
        this.selectedElements.push(element);
    },
    empty() {
        this.selectedElements.forEach(e => {
            e.classList.remove("selected");
            Array.from(e.children).forEach(child => {
                e.removeChild(child);
            });
        });
        this.selectedElements = [];
    },
    getKeys() {
        return this.selectedElements.map(element => {
            return element.id;
        });
    },

    /* Private methods */

    /** 
     * An <animate> element points to exactly one other element. If there is no 'href' attribute, then the element is the direct parent of the <animate> element. I cannot apply a single <animate> element to multiple elements.
     * @param {HTMLElement} e
     */
    addAnimation(e) {
        e.innerHTML = `<animate id="anim1${e.id}" attributeName="stroke" values="#FFFFFF;#00FF00;#FFFFFF" dur="0.6s" repeatCount="indefinite"/>`;
    },
}

function createSelection() {
    const obj = Object.create(selectionPrototype);
    obj.selectedElements = [];
    return obj;
}

function saveSvg() {
	// Create an SVG that can be saved.
	alert('We are redirecting you to a static version of the SVG that you can save as a .svg file.')
	var svg = document.getElementById('svgContainer').outerHTML
	var win = window.open()
	win.document.write(svg)
}

function downloadTextFile() {
	// WARNING! Performance is very bad because the JSON is enormous! This can hang your browser!
	alert('We are opening a window with JSON in it that you can save as a .json file.')
	var modJson = JSON.stringify(writeFeeder);
	var win = window.open();
	win.document.write(modJson);
}

function scaleGraphForVisualAppearance(objectCount) {
    if (objectCount < 100) {
        gScaleLevel = 4;
    } else if (objectCount < 1000) {
        gScaleLevel = .7;
    } else {
        gScaleLevel = .5;
    }
}

/**
 * TODO: add unit tests
 * Get dimensions with: panZoom.getSizes()
 * scale of .0000004 displays real lat/lon fairly well
 */
function createViewport(tree, svgContainer) {
    const keys = Object.keys(tree);
    //scaleGraphForVisualAppearance(keys.length);
    // Set the longitude and latitude to be within the bounds of the provided data
    const firstKey = keys.find(key => {
        return tree[key].longitude !== undefined && tree[key].latitude !== undefined;
    });
    let minLon;
    let maxLon;
    let minLat;
    let maxLat;
    if (firstKey == null) {
        // There were no coordinates, so insert some!
        const objects = Object.values(tree);
        insertCoordinates(objects, 0, 0, 50);
        scaleGraphForVisualAppearance(keys.length)
        minLon = 0;
        maxLon = 0;
        minLat = 0;
        maxLat = 0;
    } else {
        minLon = parseFloat(tree[firstKey].longitude);
        maxLon = minLon;
        minLat = parseFloat(tree[firstKey].latitude);
        maxLat = minLat;
    }
    /* Find the minimum and maximum longitudes and latitudes. That's not good enough. I need to find a RANGE of values
    for each and scale the viewport to the RANGE
    */
    keys.forEach(key => {
        let lon = tree[key].longitude;
        let lat = tree[key].latitude;
        if (lon !== undefined && lat !== undefined) {
            lon = parseFloat(lon);
            lat = parseFloat(lat);
            if (lon < minLon) {
                minLon = lon;
            }
            if (lon > maxLon) {
                maxLon = lon;
            }
            if (lat < minLat) {
                minLat = lat;
            }
            if (lat > maxLat) {
                maxLat = lat;
            }
        }
    });
    gLongitudeRange = maxLon - minLon;
    gOffsetX = minLon;
    gLatitudeRange = maxLat - minLat;
    gOffsetY = minLat;
    /* Multiply by the gDrawScaleFactor when drawing. Divide by the gDrawScaleFactor when storing. 
    We use the larger of the range values to set the gDrawScaleFactor to make the graph fit in the viewport initially.
    */
    if (gLongitudeRange > gLatitudeRange) {
        gDrawScaleFactor = 1000/gLongitudeRange;
    } else {
        gDrawScaleFactor = 1000/gLatitudeRange;
    }
    svgContainer.setAttribute('viewBox',`0 0 ${1000} ${1000}`);
    /* Uncomment below to make gScaleFactor go away */
    //gDrawScaleFactor = 1;
    //svgContainer.setAttribute('viewBox',`0 0 ${gLongitudeRange} ${gLatitudeRange}`);
    /* Uncomment above to make gScaleFactor go away */
	window.panZoom = svgPanZoom('#svgContainer', {
        /* Override the default values set by 'optionsDefaults' in svg-pan-zoom.js */
        dblClickZoomEnabled: false,
        zoomScaleSensitivity: 0.2,
        minZoom: 0.1,
		maxZoom: 500
    });
}

//**************************************************
// Click event functions
//**************************************************

/**
 * TODO: add unit tests, this should only handle selection objects. creating tables is a special listener attached to svgContainer,
 * not svgContainerWrapper
 * Listener on the SVG object that handles user clicks.
 */
function handleSelection(event) {
    if (detectDrag(event)) return;
    const element = event.target;
    if (event.altKey && (element.tagName === "circle" || element.tagName === "line") && !element.classList.contains("parentChild")) {
        if (gSelection.hasId(element.id)) {
            gSelection.remove(element);
            //Copied from rowPrototype.delete(). Refactor needed
            const table = document.getElementById(`descriptionTable_${element.id}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
        } else {
            gSelection.add(element);
        }
        rebuildSelectionTable();
    } else if (!event.altKey) {
        gSelection.empty();
        destroyTables(["descriptionTables", "selectionTable"]);
        //destroyTables(["selectionTable"]);
        if ((element.tagName === "circle" || element.tagName === "line") && !element.classList.contains("parentChild")) {
            gSelection.add(element);
            const table = createDescriptionTable(element.id);
            table.id = `descriptionTable_${element.id}`;
            document.getElementById("descriptionTables").appendChild(table);
        } 
    }
}

//function hotkeys() {
//	// Handle hotkey presses.
//	let x;
//	if (window.event) {
//		// IE8 and earlier
//		x = event.keyCode
//	} else if (event.which) {
//		// IE9/Firefox/Chrome/Opera/Safari
//		x = event.which
//	}
//	var keychar = String.fromCharCode(x);
//	if (event.target.type !== 'text') {
//		// Dispatch the key:
//		if (keychar == '-') {
//			window.panZoom.zoomOut()
//		} else if (keychar == '=') {
//			window.panZoom.zoomIn()
//		} else if (keychar =='m') {
//            attachMoveSelectionListener();
//		}
//	}
//}

/**
 * Scale the thickness of all lines and size of all circles. This helps user see details.
 * @param {number} x
 */
function scaleTo(x) {
    gScaleLevel = x;
	const circles = document.getElementsByTagName('circle')
	const lines = document.getElementsByTagName('line')
	// Scale Circles
	for (let i = 0; i < circles.length; i++) {
		circles[i].setAttribute('r', 2*x)
		circles[i].setAttribute('stroke-width', 0.5*x)
	}
	// Scale Lines
	for (let i = 0; i < lines.length; i++) {
		if (lines[i].getAttribute('class').indexOf('p2') !== -1) {
			lines[i].setAttribute('stroke-width', 2*x)
		}
		else if (lines[i].getAttribute('class').indexOf('p3') !== -1) {
			lines[i].setAttribute('stroke-width', 3*x)
		}
		else if (lines[i].getAttribute('class').indexOf('parentChild') !== -1) {
			lines[i].setAttribute('stroke-width', 0.5*x)
		}
		else {
			lines[i].setAttribute('stroke-width', x)
		}
	}
}

function dropPill(thisButton, name) { // eslint-disable-line
	// This function is used to make the dropdown menus work.
	thisButton.style.color= 'black'
	thisButton.style.background= '#F8F8F8'
	thisButton.style.textAlign = 'left'
	thisButton.nextSibling.nextSibling.style.display = 'inline-block'
	thisButton.innerHTML = name + ' &#x25B4;'
	function clickCloseEvent() {
		thisButton.nextSibling.nextSibling.style.display = 'none'
		thisButton.innerHTML = name + ' &#x25BE;'
		this.removeEventListener('click', arguments.callee, true)
		thisButton.style.color= 'white'
		thisButton.style.background= 'transparent'
		if (window.event.toElement==thisButton) {event.stopPropagation()}
	}
    //document.body.addEventListener('click', clickCloseEvent, true)
    document.getElementById("interfaceContainer").addEventListener('click', clickCloseEvent, true)
}

//Returns real Lat/Long of a click event, used in the moveBus function
function clickLatLon(event) {
	const pan = window.panZoom.getPan();
    const zoom = panZoom.getSizes().realZoom;
	const svg = document.getElementById('svgContainer');
	let pt = svg.createSVGPoint();
	pt.x = event.clientX;
	pt.y = event.clientY;
	pt = pt.matrixTransform(svg.getScreenCTM().inverse());
	let x = pt.x;
	let y = pt.y;
	const coords = {
		x: (x - pan.x) / zoom,
		y: (y - pan.y) / zoom
	};
	return coords;
}

//**************************************************
// Find modal interface
//**************************************************

/**
 * TODO: add unit tests
 */
function getSearchResults() {
    const tree = gTree.tree;
    const keys = getMatchingKeys(this.value.trim(), tree);
    document.getElementById("searchCount").textContent = `hits: ${keys.length}`;
    const nextButton = document.getElementById("findNext");
    const previousButton = document.getElementById("findPrevious");
    if (keys.length === 0 || this.value === "") {
        alert(`No results found for term: "${this.value}".`)
        const feedback = function() {
            alert("Please enter a new term to search for."); 
        }
        nextButton.onclick = feedback;
        previousButton.onclick = feedback;
        return;
    }
    const upperIndex = keys.length - 1;
    let idx = 0;
    viewElement(keys[idx]);
    nextButton.onclick = function() {
        idx++;
        if (idx > upperIndex) {
            idx = 0;
        }
        viewElement(keys[idx]);
    }
    previousButton.onclick = function() {
        idx--;
        if (idx < 0) {
            idx = upperIndex;
        }
        viewElement(keys[idx]);
    }
}

/**
 * TODO: add unit tests
 */
function getMatchingKeys(term, tree) {
    const keys = [];
    if (term === "") {
        return keys;
    }
    for (let key in tree) {
        if (term == key) keys.push(key);
        for (let propertyKey in tree[key]) {
            let propertyVal = tree[key][propertyKey];
            if (typeof(propertyVal) !== "string") {
                propertyVal += "";
            }
            if (propertyKey.toLowerCase().includes(term.toLowerCase())) {
                keys.push(key);
                break;
            } else if (propertyVal.toLowerCase().includes(term.toLowerCase())) {
                keys.push(key);
                break;
            }
        }
    }
    return keys;
}

/** 
 * TODO: add unit tests
 */
function viewElement(key) {
    destroyTables(["descriptionTables"]);
    if (document.getElementById("showTableOnFind").checked) {
        document.getElementById("descriptionTables").appendChild(createDescriptionTable(key));
    }
    document.getElementById("foundElementKey").textContent = key;
    gSelection.empty();
    const element = document.getElementById(key);
    gSelection.add(element);
    let x, y;
    if (element.getAttribute("cx") != null && element.getAttribute("cy") != null) {
        x = element.getAttribute("cx");
        y = element.getAttribute("cy");
    } else {
		x = (parseFloat(element.getAttribute('x1')) + parseFloat(element.getAttribute('x2'))) / 2;
		y = (parseFloat(element.getAttribute('y1')) + parseFloat(element.getAttribute('y2'))) / 2;
    }
    // I can't make this work 
    //panZoom.zoomAtPoint(2, {x: x, y: y});
    // Do this instead 
	panZoom.pan({x:0, y:0})
	var realZoom = window.panZoom.getSizes().realZoom
	var width = window.panZoom.getSizes().width / 2
	var height = window.panZoom.getSizes().height / 2
    panZoom.pan({x:width - (x * realZoom), y:height - (y * realZoom)})
    panZoom.zoom(20/gScaleLevel);
}

//**************************************************
// jQuery handling for distNetViz.py
//**************************************************

/** 
 * TODO: add unit tests?
 * If this interface is being used as a file, we can't import jQuery with <script> so we can't use jQuery
 * styling. This function is only called when jQuery is available.
 */
 function applyJQueryStyles() {
    // Make stuff draggable
    $("#findModal .modalContent").draggable();
    $("#progressModal .modalContent").draggable();
    $("#loadModal .modalContent").draggable();
    $("#blankFeederModal .modalContent").draggable();
    $("#milsoftModal .modalContent").draggable();
    $("#gridlabdModal .modalContent").draggable();
    $("#cymeModal .modalContent").draggable();
    $("#scadaModal .modalContent").draggable();
    $("#amiModal .modalContent").draggable();
    $("#massAddModal .modalContent").draggable();
    $("#massEditModal .modalContent").draggable();
    $("#attachmentsModal .modalContent").draggable();
    // Position the description table depending on whether or not it is draggable
    //document.getElementById("descriptionTable").removeAttribute("style");
    //document.getElementById("descriptionTable").style.left = "70vw";
}

/** 
 * Ajax requests depend on jQuery, so any function that uses $.ajax() cannot be used if this interface
 * is loaded as a file. This function is called when jQuery isn't available.
 */
function disableJQueryFunctionality() {
    //Hide stuff that doesn't work in distNetViz.py
    Array.from(document.querySelectorAll("[data-web]")).forEach(li => {
        li.remove();
    });
    //document.getElementById("findModal").style.justifyContent = "left";
}

//**************************************************
// Header menu functions
//**************************************************

// keep this
function attachHandlers() {
    attachAddComponentListeners();
    attachFeederList(document.getElementById("publicFeederList"), publicFeeders, "public");
    attachFeederList(document.getElementById("userFeederList"), userFeeders, thisOwner);
    addFileMenuHandlers();
    addEditMenuHandlers();
}

//delete this eventually
function insertIndependentComponent(component) {
    alert("Please click a location on the graph to insert this component.");
    const svgContainer = document.getElementById("svgContainer");
    svgContainer.setAttribute("style", "cursor: crosshair");
    svgContainer.onclick = function(event) {
        if (detectDrag(event)) return;
        const tObject = createTreeObject(component, gTree);
        insertCoordinates([tObject.data], 0, 0, 0);
        getMoveNodesFunction([tObject.data])(event);
        gTree.insert(tObject);
        createSvgData([tObject.key]).draw(gViewport);
    }
}

//delete this eventually
function insertChildComponent(keys, component) {
    const svgContainer = document.getElementById("svgContainer");
    if (keys.length === 0) {
        alert("Please click on another circle/line object that is not a configuration node to add this component as a child.");
        svgContainer.setAttribute("style", "cursor: crosshair");
        svgContainer.onclick = function(event) {
            if (detectDrag(event)) return;
            event.stopPropagation();
            detachListener();
            let parent;
            try {
                parent = gTree.getObject(event.target.id);
                if (parent != null && getType(parent) !== "configurationNode") {
                    const tObject = createTreeObject(component, gTree);
                    tObject.setupChildNode(event.target.id);
                    gTree.insert(tObject);
                    createSvgData([tObject.key]).draw(gViewport);
                } else {
                    alert("Insertion failed. You clicked on a configuration node.");
                }
            } catch (e) {
                alert("Insertion failed. You click on an invalid object");
            }
        }
    } else {
        const newObjects = [];
        keys.forEach(key => {
            const tObject = createTreeObject(component, gTree);
            tObject.setupChildNode(key);
            gTree.insert(tObject);
            newObjects.push(tObject.key);
        });
        createSvgData(newObjects).draw(gViewport); 
    }
}

// delete this eventually
function insertLineComponent(keys, component) {
    const svgContainer = document.getElementById("svgContainer");
    if (keys.length === 0) {
        alert("Please click on two circles that are not configuration nodes to add this line.");
        const nodes = [];
        svgContainer.setAttribute("style", "cursor: crosshair");
        svgContainer.onclick = function(event) {
            if (detectDrag(event)) return;
            event.stopPropagation();
            try {
                const node = gTree.getObject(event.target.id);
                const type = getType(node);
                if (type === "childNode" || type === "independentNode") {
                    if (!gSelection.hasId(event.target.id)) {
                        gSelection.add(event.target);
                        nodes.push(event.target.id);
                    }
                } else {
                    alert(`You clicked on a "${type}" type object. Please click on a circle that is not a configuration node.`);
                    return;
                }
            } catch (e) {
                alert(`You clicked on an invalid object. Please click on a circle that is not a configuration node.`);
                return;
            }
            if (nodes.length === 2) {
                const tObject = createTreeObject(component, gTree);
                tObject.setupLine(nodes[0], nodes[1]);
                gTree.insert(tObject);
                createSvgData([tObject.key]).draw(gViewport)
                gSelection.empty();
                detachListener();
            }
        }
    } else {
        const newObjects = [];
        for (let i = 0; i < keys.length - 1; i++) {
            let tObject = createTreeObject(component, gTree);
            tObject.setupLine(keys[i], keys[i + 1]);
            gTree.insert(tObject);
            newObjects.push(tObject.key);
        }
        createSvgData(newObjects).draw(gViewport);
    }
}
/** 
 * TODO: add a click listener instead of doing it backwards!
 * Fill menu of "Add" button and add its handler functions.
 */
function attachAddComponentListeners() {
	const ul = document.getElementById("componentList");
    const select = document.getElementById("componentSelect");
    const keys = Object.keys(gComponents).map(key => key.toLowerCase()).sort();
    keys.forEach(key => {
		const li = document.createElement("li");
        ul.appendChild(li);
        let component = gComponents[key];
        if (component == null) {
            key = getMixedCaseKey(gComponents, key);
            component = gComponents[key];
        }
        li.textContent = key;
        const type = getType(component);
        switch (type) {
            case "independentNode":
            case "configurationNode":
                li.addEventListener("click", function() {
                    if (isValidForAdd(gSelection.getKeys(), component)) {
                        insertIndependentComponent(component);
                    }
                });
                break;
            case "childNode":
                li.addEventListener("click", function() {
                    if (isValidForAdd(gSelection.getKeys(), component)) {
                        insertChildComponent(gSelection.getKeys(), component);
                    }
                });
                select.innerHTML += `<option value=${key}>${key}</option>`;
                break;
            case "line":
                li.addEventListener("click", function() {
                    if (isValidForAdd(gSelection.getKeys(), component)) {
                        insertLineComponent(gSelection.getKeys(), component);
                    }
                });
                break;
        }
    });
}

/** 
 * TODO: add unit-tests
 * @param {Element} ul - An html element where the list will be attached
 * @param {Array} feeders - An array of objects, where each object has properties "model" and "name", or null. 
 * @param {string} owner - Either "public" or the owner of the current writeFeeder.
 */
function attachFeederList (ul, feeders, owner) {
    if (!feeders) return;
    const sortedNames = feeders.map(feeder => feeder.name.toLowerCase()).sort();
    sortedNames.forEach(lowercaseName => {
        const feeder = feeders.find(feeder => {
            return feeder.name.toLowerCase() === lowercaseName;
        });
        if (feeder.name != thisFeederName) {
            const li = document.createElement("li");
            li.classList.add("feederItem");
            li.innerHTML = `<strong>${feeder.name}</strong> from <br>"${feeder.model}"`;
            li.addEventListener("click", function() {
                loadFeeder(feeder.name, feeder.model, owner);
            });
            ul.append(li);
        }
    });
}

/**
 *
 */
function addFileMenuHandlers() {
    const menu = document.getElementById("fileMenu");
    if (menu == null) {
        return;
    }
    const items = Array.from(menu.children);
    if (items.length !== 8) {
        throw new Error("Please update this function to ensure the correct handlers are attached");
    }
    items[0].addEventListener("click", function() {
        saveFeeder(writeFeeder);
    });
    items[1].addEventListener("click", downloadTextFile);
    items[2].addEventListener("click", renameFeeder);
    items[3].addEventListener("click", function() { toggleElementDisplay("loadModal"); });
    items[4].addEventListener("click", function() { toggleElementDisplay("blankFeederModal"); });
    items[5].addEventListener("click", function() { toggleElementDisplay("milsoftModal"); });
    items[6].addEventListener("click", function() { toggleElementDisplay("gridlabdModal"); });
    items[7].addEventListener("click", function() { toggleElementDisplay("cymeModal"); });
}

/** 
 * 
 */
function addEditMenuHandlers() {
    const menu = document.getElementById("editMenu");
    const items = Array.from(menu.children);
    if (items.length != 9) {
        throw new Error("Please update this function to ensure the correct handlers are attached");
    }
    //items[0].addEventListener("click", zoomToFit);
    //items[1].addEventListener("click", zoomReset);
    items[0].addEventListener("click", function() { toggleElementDisplay("amiModal"); });
    items[1].addEventListener("click", function() { toggleElementDisplay("anonymizeModal"); });
    items[2].addEventListener("click", function() {
        loadAttachments(); 
        toggleElementDisplay("attachmentsModal");
    });
    items[3].addEventListener("click", function() { toggleElementDisplay("climateModal"); });
    items[4].addEventListener("click", function() {
        toggleElementDisplay("findModal"); 
        document.getElementById("searchInput").focus(); 
    });
    items[5].addEventListener("click", function() {
        updateAttachTargets("massAddTargetSelect", gTree.tree);
        toggleElementDisplay("massAddModal");
    });
    items[6].addEventListener("click", function() {
        updateAttachTargets("massEditTargetSelect", gTree.tree);
        toggleElementDisplay("massEditModal");
    });
    items[7].addEventListener("click", function() { toggleElementDisplay("scadaModal"); });
    items[8].addEventListener("click", staticLoadsToHouses);
}

/** 
 * TODO: add unit tests
 * If an element isn't displayed, set it's inline display value to the default browser value.
 * If the element is displayed, then hide it.
 */
function toggleElementDisplay(id) {
    const element = document.getElementById(id);
    if (element.style.display === "none") {
        element.removeAttribute("style");
    } else {
        element.style.display = "none";
        if (id === "findModal") {
            return;
        }
        // When we hide a modal, set any of the text fields to empty
        const queryString = `#${id} input[type=text]`;
        document.querySelectorAll(queryString).forEach(input => {
            input.value = "";
        });
    }
}

//**************************************************
// Edit menu interface
//**************************************************

/**
 * Set the viewport to its initial state and center it
 */
//function zoomReset() {
//    panZoom.fit();
//    panZoom.center();
//}

/**
 * Set the viewport value to its initial state.
 */
//function zoomToFit() {
//    panZoom.fit();
//}

function randomGaussian() {
  // Get a Gaussian from a uniform(0,1) via the Box-Muller transform.
  let rad;
  let x1;
  let x2;
  let c;
  do {
	x1 = 2 * Math.random() - 1
	x2 = 2 * Math.random() - 1
	rad = x1 * x1 + x2 * x2
  } while (rad >= 1 || rad == 0) {
    c = Math.sqrt(-2 * Math.log(rad) / rad);
  }
  return x1 * c
}

function randomInt(min,max) {
	return Math.floor(Math.random()*(max - min + 1) + min)
}

function randomChoice(inList) {
	return inList[Math.floor(Math.random() * inList.length)]
}


// TODO: for secondary system has 'load', replace it with triplex_meter and triplex_node
// TODO: rename this function?
/*
Don't touch existing houses or their loads
Don't ever replace regular load objects
1) Delete triplex nodes (have NO parent) and replace them with houses that have randomly generated loads
2) Replace triplex loads (have parent) with houses that have randomly generated loads

-There are no files with both triplex loads and triplex nodes.
-File with triplex loads: ./omf/data/Model/public/Demo gridlabMulti scadaCalibration/Calibrated Feeder.omd
-File with triplex nodes: 
    ./omf/data/Model/public/Demo gridlabMulti scadaCalibration/Uncalibrated Feeder.omd
    ./omf/data/Model/public/Demo superModel/superModel Today.omd

*/
function staticLoadsToHouses() {
    const tree = gTree.tree;
    const names = gTree.treeMap.names;
	//if (!containsTriplexNodes(tree)) {
	if (!containsTriplexNodeOrLoad(tree)) {
        alert("There are no triplex nodes or triplex loads in this model.");
        return;
	} else {
        let modal = new ProgressModal("Please wait. Houses are being generated.", "", false);
        modal.show();
        // Replace 100 nodes at a time (maximum), to prevent the browser from hanging
        const keys = Object.keys(tree);
        let start = 0;
        let end = 100;
        const intervalId = setInterval(function() {
            //console.log("start: " + start);
            //console.log("end: " + end);
            replaceAllHouses(start, end, keys);
            if (end >= keys.length) {
                clearInterval(intervalId);
                modal.hide();
            } else {
                start = end + 1;
                end += 100;
            }
        }, 10);
    }

    /* Triplex loads should have a "parent" property. Triplex nodes should NOT have a "parent" property usually.
    Therefore, if the parent property DOES exist on either a node/load I should use it. However, it it DOESN'T exist,
    then I should carry on as normal too.
    */
    function containsTriplexNodeOrLoad(tree) {
        for (let key in tree) {
            if (tree[key].object === "triplex_node" || tree[key].object === "triplex_load") {
                return true;
            } 
        }   
        return false;
    }

	function replaceAllHouses(start, end, keys) {
        if (end >= keys.length) {
            end = keys.length - 1;
        }
        for (let i = start; i <= end; i++) {
            if (tree[keys[i]].object === "triplex_node" || tree[keys[i]].object === "triplex_load") {
                let parentKey = names[tree[keys[i]].parent];
                if (parentKey == null) {
                    //There is no parent. No big deal

                } else {
                    //There is a parent. Use the parent to place the new house

                }
            }
            /*
            TODO: delete this
            if (tree[keys[i]].hasOwnProperty('parent') && tree[keys[i]].object === "triplex_node") {
                // Get the key of the parent of this triplex node, which is a triplex meter (i.e. another node)
                let parentKey = names[tree[keys[i]].parent];
                // Delete the triplex_node itself
                deleteObject(keys[i]);
                // Create a new house object to replace the triplex node
                let houseObj = randomHouse();
                let lightsObj = randomLights();
                let heaterObj = randomWaterHeater();
                newChildAtLocation(houseObj.house, parentKey);
                newChildAtLocation(lightsObj.lights, houseObj.key);
                if (heaterObj != false) {
                    newChildAtLocation(heaterObj.heater, houseObj.key);
                }
            }
            */
        }
    }

	function randomHouse() {
		const newHouse = {}
		newHouse['object'] = 'house'
		newHouse['air_temperature'] = '70'
		newHouse['cooling_COP'] = randomInt(25, 40) / 10.0 + ''
		newHouse['cooling_setpoint'] = 'cooling' + randomInt(1, 8) + '*1'
		newHouse['cooling_system_type'] = randomChoice(['ELECTRIC', 'HEAT_PUMP', 'NONE'])
		// House sizing distribution from http://www.census.gov/housing/ahs/
		// between 1100 and 3000. Probably needs a normal distribution.
		let area = 1800 + 500 * randomGaussian()
		if (area < 500) {
			area = 500
		}
		area = area.toPrecision(2) * 1.0 + ''
		newHouse['floor_area'] = area
		newHouse['heating_COP'] = randomInt(20, 35) / 10.0 + ''
		newHouse['heating_setpoint'] = 'heating' + randomInt(1, 8) + '*1'
		newHouse['heating_system_type'] = randomChoice(['RESISTANCE', 'HEAT_PUMP', 'GAS'])
		newHouse['mass_temperature'] = '70'
		let skew = 1200 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHouse['schedule_skew'] = skew
		newHouse['thermal_integrity_level'] = randomChoice([1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6]) + ''
		const newKey = getNewTreeKey(gTree.tree);
		newHouse['name'] = 'synhouse' + newKey
		return {
            house: newHouse,
            key: newKey
        }
	}

	function randomLights() {
		const newLights = {}
		newLights['object'] = 'ZIPload'
		newLights['power_fraction'] = '0.400000'
		newLights['current_fraction'] = '0.300000'
		newLights['impedance_pf'] = '1.000'
		newLights['current_pf'] = '1.000'
		newLights['power_pf'] = '1.000'
		newLights['impedance_fraction'] = '0.300000'
		newLights['heatgain_fraction'] = '0.9'
		let power = 1.2 + randomGaussian()
		if (power < 0) {
			power = -1 * power
		}
		power = power.toPrecision(3) * 1.0 + ''
		newLights['base_power'] = 'LIGHTS*' + 1.33
		let skew = 2000 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newLights['schedule_skew'] = skew
		const newKey = getNewTreeKey(gTree.tree);
		newLights['name'] = 'synLights' + newKey
		return {
            lights: newLights,
            key: newKey
        }
	}

	function randomWaterHeater() {
		const newHeater = {}
		if (randomChoice([1, 2, 3]) == 3) {
			return false
		}
		// Static properties.
		newHeater['object'] = 'waterheater'
		newHeater['temperature'] = '135'
		newHeater['tank_volume'] = '50'
		newHeater['location'] = 'INSIDE'
		// Uniformly distributed properties.
		newHeater['heating_element_capacity'] = randomInt(37, 53) / 10.0 + ''
		newHeater['thermostat_deadband'] = randomInt(20, 60) / 10.0 + ''
		newHeater['demand'] = 'water' + randomInt(1, 20) + '*1'
		newHeater['tank_UA'] = randomInt(20, 40) / 10.0 + ''
		// Gaussian properties.
		let skew = 2000 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHeater['schedule_skew'] = skew
		newHeater['tank_setpoint'] = (randomGaussian() * 2 + 130).toPrecision(3) + ''
		// between 1100 and 3000. Probably needs a normal distribution.
		const newKey = getNewTreeKey(gTree.tree);
		newHeater['name'] = 'synwaterheater' + newKey;
		return {
            heater: newHeater,
            key: newKey
        }
	}
}

function massAdd() {
    let percent = document.getElementById('percent').value;
    if (!isNumberString(percent) || parseFloat(percent) > 1.0 || parseFloat(percent) < 0) {
        alert("Please enter a valid number for attachment probability");
        return;
    }
	const componentName = document.getElementById('componentSelect').value;
	const attachObject = document.getElementById('massAddTargetSelect').value;
    const newObjects = [];
    const pm = new ProgressModal(`Adding a "${componentName}" object to every "${attachObject}" object. This could take a few seconds.`);
    pm.show();
    percent = parseFloat(percent);
    setTimeout(() => {
        Object.keys(gTree.tree).forEach(key => {
            if (gTree.getObject(key).object === attachObject && Math.random() < percent) {
                const tObject = createTreeObject(gComponents[componentName], gTree);
                tObject.setupChildNode(key);
                gTree.insert(tObject);
                newObjects.push(tObject.key);
            }
        });
        createSvgData(newObjects).draw(gViewport);
        pm.hide();
        alert(`${newObjects.length} "${componentName}" objects added to the feeder`);
        toggleElementDisplay('massAddModal');
    }, 10);
}

/* Clearing each list so we dont get duplicates in the list. This must be done because the attachTarget list must be 
refreshed, since the user could have added a new object type to the data which they now want to attach to.
*/
function updateAttachTargets(id, tree) {
    document.getElementById(id).innerHTML = "";
	let attachList = [];
	for (let key in tree) {
        let isValidType = true;
        if (id === "massAddTargetSelect") {
            isValidType = getType(tree[key]) !== "configurationNode";
        }
        let isComponent = gComponents.hasOwnProperty(tree[key].object);
        let notAlreadyAdded = !attachList.includes(tree[key].object);
        if (isValidType && isComponent && notAlreadyAdded) {
            attachList.push(tree[key].object);
        }
    }
    attachList.map(name => name.toLowerCase()).sort().forEach(lowercaseName => {
        const key = gComponents.hasOwnProperty(lowercaseName) ? lowercaseName : getMixedCaseKey(gComponents, lowercaseName);
        document.getElementById(id).innerHTML += `<option value=${key}>${key}</option>`;
    });
}

// keep this, rename it
function getKeysOfObjectsWithoutNumericValues(keys, attributeKey) {
    const tree = gTree.tree;
    invalidKeys = keys.filter(key => {
        let value = tree[key][attributeKey];
        if (typeof value !== "string") {
            value = String(tree[key][attributeKey]);
        }
        if (!isNumberString(value)) {
            return true;
        }
    });
    return invalidKeys;
}

//only toggle upon successful completion of operation
function massEdit() {
    let operation = document.querySelector("input[name=attributeOperation]:checked");
    if (operation == null) {
        alert("Please select an operation with radio buttons on the 'Mass Edit' menu.");
        return;
    }
    operation = operation.value;
    const objectType = document.getElementById("massEditTargetSelect").value;
    const keys = Object.keys(gTree.tree).filter(key => gTree.getObject(key).object === objectType)
    if (operation === "addAttribute") {
    massAddAttribute(keys, objectType);
        return;
    }
    const attributeKey = document.getElementById("massEditAttribute").value.trim();
    //Make sure the attribute exists
    let invalidKeys = [];
    for (let key of keys) {
        if (gTree.getObject(key)[attributeKey] === undefined) {
            invalidKeys.push(key);
        }
    }
    if (invalidKeys.length > 0) {
        alert(`Mass edit failed. The attribute "${attributeKey}" is missing from one or more objects:\nObject names: "${invalidKeys.map(key => gTree.getObject(key).name).join(", ")}".\nObject keys: "${invalidKeys.join(", ")}".`);
        return;
    }
    //Make sure the attribute exists
    switch (operation) {
        case "addTo":
        case "multiplyBy":
        case "change":
            if (nonModifiableProperties.includes(attributeKey)) {
                alert(`Mass edit failed. The following properties cannot be modified: "${nonModifiableProperties.join(", ")}".`);
                return;
            }
            if (operation === "addTo" || operation === "multiplyBy") {
                invalidKeys = getKeysOfObjectsWithoutNumericValues(keys, attributeKey);
                if (invalidKeys.length > 0) {
                    alert(`Mass edit failed. The attribute "${attributeKey}" does not have a numeric value in the following objects: \nObject names: "${invalidKeys.map(key => gTree.getObject(key).name).join(", ")}".\nObject keys: "${invalidKeys.join(", ")}".`);
                    return;
                }
                if (operation === "addTo") {
                    massAddition(keys, attributeKey, objectType);
                } else if (operation === "multiplyBy") {
                    massMultiplication(keys, attributeKey, objectType);
                }
            } else if (operation === "change") {
                massChange(keys, attributeKey, objectType);
            }
            break;
        case "delete":
            if (nonDeletableProperties.includes(attributeKey)) {
                alert(`Mass edit failed. The properties "${nonDeletableProperties.join(", ")}" cannot be deleted.`);
                return;
            }
            for (let key of keys) {
                delete gTree.getObject(key)[attributeKey];
            }
            alert(`${keys.length} ${objectType} objects had the "${attributeKey}" attribute deleted.`);
            toggleElementDisplay('massEditModal');
            createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
            break;
    }
}

function isValidParentName(name) {
    try {
        if (getType(gTree.getObject(gTree.treeMap.getKey(name))) === "configurationNode") return false;
    } catch (e) {
        return false;
    }
    return true;
}

function isValidToOrFromNode(name) {
    const invalidTypes = ["configurationNode", "line"];
    try {
        const type = getType(gTree.getObject(gTree.treeMap.getKey(name)));
        if (invalidTypes.includes(type)) {
            return false;
        }
    } catch (e) {
        return false;
    }
    return true;
}

/**
 * Create an array of tree objects. Delete all the real objects. change all the tree objects, insert all the tree objects, redraw.
 */
function massChange(keys, attributeKey, objectType) {
    const newValue = document.getElementById("changeValue").value.trim();
    switch (attributeKey) {
        case "parent":
            if (!isValidParentName(newValue)) {
                alert(`Mass change failed. The name "${newValue}" is not a valid parent name.`);
                return;
            }
        case "to":
        case "from":
            if (!isValidToOrFromNode(newValue)) {
                alert(`Mass change failed. The name "${newValue}" is not a valid name for a source or target of a line.`);
                return;
            }
    }
    const treeObjectCopies = [];
    keys.forEach(key => {
        treeObjectCopies.push(createTreeObject(key, gTree));
    });
    createSvgData(keys).delete(gViewport);
    let count = keys.length;
    const unedited = [];
    treeObjectCopies.forEach(tObject => {
        if (attributeKey === "to") {
            if (tObject.data.from !== newValue) {
                tObject.data[attributeKey] = newValue;
            } else {
                count--;
                unedited.push(tObject.key);
            }
        } else if (attributeKey === "from") { 
            if (tObject.data.to !== newValue) {
                tObject.data[attributeKey] = newValue;
            } else {
                count--; 
                unedited.push(tObject.key);
            }
        } else {
            tObject.data[attributeKey] = newValue;
        }
        gTree.insert(tObject);
    });
    let msg = `${count} ${objectType} objects had the "${attributeKey}" attribute changed.`;
    msg = unedited.length === 0 ? msg : msg + ` The following objects did not have their "${attributeKey}" attribute changed: "${unedited.map(key => gTree.getObject(key).name).join(", ")}".`
    alert(msg);
    toggleElementDisplay('massEditModal');
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

function massAddition(keys, attributeKey, objectType) {
    let operand = document.getElementById("addToValue").value.trim();
    if (!isNumberString(operand)) {
        alert("Mass edit failed. Please enter a valid number if you choose 'Add to Value'.");
        return;
    }
    operand = parseFloat(operand);
    for (let key of keys) {
        gTree.getObject(key)[attributeKey] = gTree.getObject(key)[attributeKey] + operand;
    }
    alert(`${keys.length} ${objectType} objects had their "${attributeKey}" attribute edited.`);
    toggleElementDisplay('massEditModal');
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

function massMultiplication(keys, attributeKey, objectType) {
    let multiplyOperand = document.getElementById("multiplyValue").value.trim();
    let addOperand = document.getElementById("andAddValue").value.trim() === "" ? "0" : document.getElementById("andAddValue").value.trim();
    if (!isNumberString(multiplyOperand) || !isNumberString(addOperand)) {
        alert("Mass edit failed. Please enter valid operands if you choose 'Multiply attribute by'.");
        return;
    }
    multiplyOperand = parseFloat(multiplyOperand);
    addOperand = parseFloat(addOperand);
    for (let key of keys) {
        gTree.getObject(key)[attributeKey] = gTree.getObject(key)[attributeKey] * multiplyOperand + addOperand;
    }
    alert(`${keys.length} ${objectType} objects had their "${attributeKey}" attribute edited.`);
    toggleElementDisplay('massEditModal');
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

function massAddAttribute(keys, objectType) {
    const newKey = document.getElementById("newAttributeKey").value.trim();
    if (newKey === "") {
        alert(`Mass edit failed. Please enter a name for the attribute you want to add.`);
        return;
    }
    if (nonModifiableProperties.includes(newKey)) {
        alert(`Mass edit failed. The properties "${nonModifiableProperties.join(", ")}" cannot be overwritten.`);
        return;
    }
    const newValue = document.getElementById("newAttributeValue").value;
    for (let key of keys) {
        gTree.getObject(key)[newKey] = newValue;
    }
    alert(`${keys.length} ${objectType} objects had the "${newKey}" attribute added.`);
    toggleElementDisplay('massEditModal');
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

function loadAttachments() {
    const selectElement = document.getElementById("attachmentSelect");
    selectElement.innerHTML = "";
	for (let key in writeFeeder.attachments) {
        selectElement.innerHTML += `<option value=${key}>${key}</option>`;
    }
}

function editAttachment() {
	//document.body.style.cursor = 'wait'
	//setTimeout(function(){
		toggleElementDisplay('editAttachmentModal');
		let name =  document.getElementById('attachmentSelect').value; //get the select. attachmentsList = attachmentSelect
		document.getElementById('attachmentTd').innerHTML = name;  //get the td. attachmentSelect = attachmentTd
		document.getElementById('editAttachmentBox').innerHTML = writeFeeder.attachments[name];
		//document.body.style.cursor = 'auto'
	//}, 100);
}

function saveAttachment() {
	let name = document.getElementById('attachmentSelect').value;
	writeFeeder.attachments[name] = document.getElementById('editAttachmentBox').value;
}

//**************************************************
// File menu interface
//**************************************************
{% if showFileMenu %}

/** 
 * Used to save the new changes or undo an operation by resaving the old changes.
 */ 
function saveFeeder(feeder) {
    const formData = new FormData();
    formData.set("feederObjectJson", JSON.stringify(feeder));
    const postRequest = $.ajax({
        type: "POST",
        url: `/saveFeeder/${thisOwner}/${thisModelName}/${thisFeederName}`,
        data: formData,
        processData: false,
        contentType: false,
    });
    let cancelled = false;
    let progressModal;
    if (feeder === readFeeder) {
        progressModal = new ProgressModal("Cancelling the previous operation...", "", false);
        postRequest.done(function() {
            progressModal.hide();
            alert("Success. Previous operation was canceled");
        });
    } else if (feeder === writeFeeder) {
        progressModal = new ProgressModal("Saving changes to your file...", "You have canceled the save.", true);
        progressModal.button.addEventListener("click", function() {
            cancelled = true;
            progressModal.header.textContent = progressModal.cancelMessage;
            progressModal.button.style.display = "none";
        });
        postRequest.done(function() {
            if (cancelled) {
                saveFeeder(readFeeder);
            } else {
                progressModal.hide();
                alert("Success. Your data was saved.");
            }
        });
    }
    progressModal.show();
}

async function loadFeeder(serverFeederName, serverModelName, owner) {
    let submitForm = false;
    await $.ajax({
        url: `/uniqObjName/Feeder/${thisOwner}/${serverFeederName}/${serverModelName}`
    }).done(function(data) {
        if (data.exists) {
            submitForm = true;
        } else {
            alert('This feeder no longer exists. Please refresh the page, or select another feeder.');
        }
    });
    if (submitForm === false) {
        return;
    }
    let formData = new FormData();
    formData.set("referrer", "distribution");
    const progressModal = new ProgressModal("Loading feeder from server...", "You have canceled loading the feeder.", true);
    let cancelled = false;
    progressModal.button.addEventListener("click", function() {
        cancelled = true;
        progressModal.header.textContent = progressModal.cancelMessage;
        progressModal.button.style.display = "none";
    });
    progressModal.show();
    $.ajax({
        type: "POST",
        url: `/loadFeeder/${serverFeederName}/${serverModelName}/${thisModelName}/${thisFeederNum}/${owner}/${thisOwner}`,
        data: formData,
        processData: false,
        contentType: false,
    }).done(function() {
        if (cancelled) {
            saveFeeder(readFeeder);
        } else {
            reloadWrapper();
        }
    });
}

/** 
 * TODO: add back ability to cancel these operations
 */
async function submitForm({formId, pollUrl, inputId}) {
    let submitForm = true;
    if (inputId !== undefined) {
        // inputId was defined, therefore we need to check the file name on the server before submitting the form
        submitForm = false;
        const fileName = document.getElementById(inputId).value;
        // Check if the file exists, using the user-provided fileName
        await $.ajax({
            url: `/uniqObjName/Feeder/${thisOwner}/${fileName}/${thisModelName}`
        }).done(function(data) {
            //console.log(data);
            if (data.exists === true) {
                alert(`You already have a feeder named "${fileName}". Please choose a different name.`);
            } else {
                // The file does not exist. Submit the form.
                submitForm = true;
            }
        });
    }
    if (submitForm === false) {
        return;
    }
    const form = document.getElementById(formId);
    const formData = new FormData(form);
    const submitModal = new ProgressModal("Submitting your file...", "", false);
    submitModal.show();
    // Submit the form to the server with an ajax request
    const formRequest = $.ajax({
        type: "POST",
        url: form.action,
        data: formData,
        processData: false,
        contentType: false,
    });
    if (pollUrl === undefined) {
        // We don't want to poll the server. Just reload the page.
        formRequest.done(function() {
            reloadWrapper();
        });
    } else {
        formRequest.done(function(data) {
            let cancelled = false;
            const pollModal = new ProgressModal("Converting your file...", "You canceled the file conversion.", true);
            pollModal.button.addEventListener("click", function() {
                cancelled = true;
                pollModal.header.textContent = pollModal.cancelMessage;
                pollModal.button.style.display = "none";
            });
            pollModal.show();
            // Poll the server
            const intervalId = setInterval(function() {
                $.ajax({
                    //url: `/checkConversion/${thisModelName}/${thisOwner}`
                    url: pollUrl
                }).done(function(data) {
                    if (cancelled) {
                        clearInterval(intervalId);
                        pollModal.hide();
                        alert("You cancelled the operation");
                        saveFeeder(readFeeder);
                    }
                    if (data.exists === true) {
                        //processing is ongoing 
                    } else if (data.exists === false) {
                        // The pollModal isn't hidden before the alert happens. This has nothing to do with the reload wrapper.
                        clearInterval(intervalId);
                        pollModal.hide();
                        alert("Conversion complete");
                        reloadWrapper();
                    } else if (data === "milError") {
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('The .std and .seq files used are incorrectly formatted.');
                        //TODO: submit the readFeeder
                    } else if (data === "glmError") {
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('The .glm file used is incorrectly formatted.');
                        //TODO: submit the readFeeder
                    } else {
                        console.log(data);
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert('There was a problem. Operation was cancelled');
                    }
                });
            }, 5000);
        });
    }
}

async function renameFeeder() {
	if (JSON.stringify(readFeeder) !== JSON.stringify(writeFeeder)){
		alert('You have unsaved changes. Please save the feeder before proceeding.')
	} else {
		let newName = prompt("Rename the feeder to", `${thisFeederName}`);
		while (! /^[\w\s]+$/.test(newName) || /^\s+$/.test(newName)) {
			newName = prompt("Only letters, digits and underscore are allowed.\nPlease enter a different name", `${thisFeederName}`);
		}
		if (newName){
            let submitRequest = false;
            await $.ajax({
                url: `/uniqObjName/Feeder/${thisOwner}/${newName}/${thisModelName}`
            }).done(function(data) {
                if (data.exists) {
                    alert(`You already have a feeder named "${newName}". Please choose a different name.`);
                } else {
                    submitRequest = true;
                }
            });
            if (submitRequest === false) {
                return;
            }
            $.ajax({
                url: `/renameFeeder/${thisOwner}/${thisModelName}/${thisFeederName}/${newName}/${thisFeederNum}`
            }).done(function() {
                thisFeederName = newName;
                alert("Feeder file was successfully renamed.");
            })
		}
	} 
}
{% endif %}

/** This is done for testing reasons.
 */
function reloadWrapper() {
    /* Force the client to always request new files from the server without using the browser cache. 
    */
    window.location.reload(true);
}

function ProgressModal(message, cancelMessage, showButton) {
    this.self = document.getElementById("progressModal");
    this.button = this.self.getElementsByTagName("button")[0];
    this.header = this.self.getElementsByTagName("h2")[0];
    this.message = message;
    this.cancelMessage = cancelMessage;
    this.showButton = showButton;
}

ProgressModal.prototype.show = function() {
    this.header.textContent = this.message;
    this.self.removeAttribute("style");
    if (this.showButton) {
        this.button.removeAttribute("style");
    } else {
        this.button.style.display = "none";
    }
}

ProgressModal.prototype.hide = function() {
    this.self.style.display = "none";
}
//**************************************************
// TreeMap interface
//**************************************************

const treeMapPrototype = {

    /* Public methods */

    /**
     * good. doesn't need unit tests
     */
    add(key) {
        this.mapName(key);
        this.mapChild(key);
        this.mapLine(key);
    },

    /**
     * good. doesn't need unit tests
     * @param {Array} keys
     */
    remove(keys) {
        keys.forEach(key => {
            this.unmapLine(key);
            this.unmapChild(key);
        });
        keys.forEach(key => {
            this.unmapName(key);
        });
    },

    /**
     * good. doesn't need unit tests
     * This should throw an Error. If I provide what I believe is a valid name, I expect to get a key!
     */
    getKey(name) {
        if (name == null) {
            throw new Error(`getKey() failed. The name: "${name}" is invalid.`);
        }
        const key = this.names[name];
        if (key === undefined) {
            throw new Error(`getKey() failed. Did not find the name "${name}" in this.names.`);
        }
        return key;
    },

    /**
     * good. doesn't need unit tests
     */
    getChildKeys(key) {
        return this.children[key];
    },

    /**
     * good. doesn't need unit tests
     */
    getLineKeys(key) {
        return this.lines[key];
    },

    /**
     * good. doesn't need unit tests
     */
    getParentKey(childKey) {
        const parentName = this.tree[childKey].parent;
        if (parentName === undefined) return;
        let parentKey;
        try {
            parentKey = this.getKey(parentName);
        } catch (e) {
            console.error(`The child object named "${this.tree[childKey].name}" has a nonexistent parent object named "${parentName}". The parent-child line was not drawn.`);
            return;
        }
        return parentKey;
    },

    /* Private TreeMap methods. Don't touch! */

    /**
     * good. not tested b/c private
     */
    getNodeEndKeys(lineKey) {
        const sourceName = this.tree[lineKey].to;
        const targetName = this.tree[lineKey].from;
        let sourceKey, targetKey;
        if (sourceName === undefined && targetName === undefined) return {};
        if (sourceName !== undefined && targetName !== undefined) {
            try {
                sourceKey = this.getKey(sourceName);
                targetKey = this.getKey(targetName);
            } catch(e) {
                //Commented out because this message is redundant and less helpful than other error messages
                //console.error(`The line object named "${this.tree[lineKey].name}" has nonexistent 'to' and/or 'from' nodes.`);
                return {};
            }
        } else {
            console.error(`The line object named "${this.tree[lineKey].name}" is missing a 'to' or 'from' property.`);
            return {};
        }
        return {sourceKey: sourceKey, targetKey: targetKey};
    },

    /**
     * good. doesn't need unit tests
     */
    mapName(key) {
        const name = this.tree[key].name;
        if (name == null) return;
        const lowercaseName = String(name).toLowerCase();
        if (lowercaseName === "null" || lowercaseName === "undefined") return;
        this.names[name] = key;
    },

    /**
     * good. doesn't need unit tests
     */
    unmapName(key) {
        const name = this.tree[key].name;
        if (name == null) return;
        delete this.names[name];
    },

    /**
     * good
     */
    mapChild(childKey) {
        const parentKey = this.getParentKey(childKey);
        if (parentKey == null) return;
        if (this.children[parentKey] == null) {
            this.children[parentKey] = [childKey];
        } else if (!this.children[parentKey].includes(childKey)) {
            this.children[parentKey].push(childKey);
        } 
    },

    /**
     * good
     */
    unmapChild(childKey) {
        const parentKey = this.getParentKey(childKey);
        if (parentKey == null) return;
        const idx = this.children[parentKey].indexOf(childKey);
        if (idx >= 0) {
            this.children[parentKey].splice(idx, 1);
            if (this.children[parentKey].length === 0) {
                delete this.children[parentKey];
            }
        } else {
            console.error(`Could not unmap child with key "${childKey}" from parent with key ${parentKey}.`);
        }
    },

    /**
     * good
     */
    mapLine(lineKey) {
        let {sourceKey, targetKey} = this.getNodeEndKeys(lineKey);
        if (sourceKey == null || targetKey == null) return;
        if (this.lines[sourceKey] == null) {
            this.lines[sourceKey] = [lineKey];
        } else if (!this.lines[sourceKey].includes(lineKey)) {
            this.lines[sourceKey].push(lineKey);
        }
        if (this.lines[targetKey] == null) {
            this.lines[targetKey] = [lineKey];
        } else if (!this.lines[targetKey].includes(lineKey)) {
            this.lines[targetKey].push(lineKey);
        }
    },

    /**
     * good
     */
    unmapLine(lineKey) {
        let {sourceKey, targetKey} = this.getNodeEndKeys(lineKey);
        if (sourceKey == null || targetKey == null) return;
        [sourceKey, targetKey].forEach(key => {
            const idx = this.lines[key].indexOf(lineKey);
            if (idx >= 0) {
                this.lines[key].splice(idx, 1);
                if (this.lines[key].length === 0) {
                    delete this.lines[key];
                }
            } else {
                console.error(`Could not unmap line with key "${lineKey}" from node with key "${key}".`);
            }
        });
    },
};

/**
 * good
 */
function createTreeMap(tree) {
    const map = Object.create(treeMapPrototype);
    map.tree = tree;
    map.names = {};
    map.children = {};
    map.lines = {};
    const keys = Object.keys(tree);
    keys.forEach(key => {
        map.mapName(key);
    });
    keys.forEach(key => {
        map.mapChild(key);
        map.mapLine(key);
    });
    return map;
}

//**************************************************
// Tree interface
//**************************************************

const treePrototype = {

    /* Public methods */

    /**
     * good.
     */
    getObject(key) {
        const obj = this.tree[key];
        if (obj == null) throw new Error(`getObject() failed. The object with the key "${key}" does not exist in the Tree.`);
        return this.tree[key];
    },

    /**
     * good. doesn't need unit tests
     */
    getParent(childKey) {
        const parentKey = this.treeMap.getParentKey(childKey);
        if (parentKey == null) return;
        return this.getObject(parentKey);
    },

    /**
     * good. doesn't need unit tests
     */
    getToNodeKey(lineKey) {
        const sourceName = this.tree[lineKey].to;
        if (sourceName == null) return;
        let key;
        try {
            key = this.treeMap.getKey(sourceName);
        } catch (e) {
            console.error(`The line object named "${this.getObject(lineKey).name}" has a nonexistent source node named "${sourceName}". The line was not drawn.`);
        }
        return key;
    },

    /**
     * good. doesn't need unit tests
     */
    getToNode(lineKey) {
        const sourceKey = this.getToNodeKey(lineKey);
        if (sourceKey == null) return;
        return this.getObject(sourceKey);
    },

    /**
     * good. doesn't need unit tests
     */
    getFromNodeKey(lineKey) {
        const targetName = this.tree[lineKey].from;
        if (targetName == null) return;
        let key;
        try {
            key = this.treeMap.getKey(targetName);
        } catch (e) {
            console.error(`The line object named "${this.getObject(lineKey).name}" has a nonexistent target node named "${targetName}". The line was not drawn.`);
        }
        return key;
    },

    /**
     * good. doesn't need unit tests
     */
    getFromNode(lineKey) {
        const targetKey = this.getFromNodeKey(lineKey);
        if (targetKey == null) return;
        return this.getObject(targetKey);
    },

    /**
     * good. doesn't need unit tests
     */
    getPairedNodeKeys(nodeKey) {
        const pairedNodes = [];
        const lineKeys = this.treeMap.getLineKeys(nodeKey);
        if (lineKeys == null) return;
        lineKeys.forEach(key => {
            if (this.getToNodeKey(key) === nodeKey) {
                pairedNodes.push(this.getFromNodeKey(key));
            } else {
                pairedNodes.push(this.getToNodeKey(key));
            }
        });
        return pairedNodes;
    },

    /**
     * good
     */
    insert(treeObject) {
        this.tree[treeObject.key] = treeObject.data;
        this.treeMap.add(treeObject.key);
    },

    /** 
     * good
     */
    isDeletable(key) {
        this.getObject(key);
        const children = this.treeMap.getChildKeys(key);
        if (children != null) return false;
        const lines = this.treeMap.getLineKeys(key);
        if (lines != null) return false;
        return true;
    },

    /**
     * good. doesn't need unit tests
     * @param {Array} keys
     */
    delete(keys) {
        this.treeMap.remove(keys);
        keys.forEach(key => {
            this.getObject(key);
            delete this.tree[key];
        });
    },

    /** 
     * Return an array of keys that need to be deleted as a result of deleting a tree object.
     * 
     * @param {string} key - the key of the tree object for which to find its deletable subtree.
     * @param {Array} visited - contains keys of tree objects that have already been visited so the method dosen't
     * recurse infinitely in case of a cycle.
     * @return {Array}
     */
    getSubtreeToDelete(key, visited = []) {
        if (!Array.isArray(visited)) throw new Error("Visited argument must be an array");
        visited.push(key);
        const keySet = new Set();
        const lines = this.treeMap.getLineKeys(key);
        const children = this.treeMap.getChildKeys(key);
        if (lines != null) lines.forEach(key => keySet.add(key));
        if (children != null) children.forEach(key => keySet.add(key));
        keySet.forEach(outerKey => {
            if (!visited.includes(outerKey)) {
                this.getSubtreeToDelete(outerKey, visited).forEach(innerKey => keySet.add(innerKey));
            }
        });
        return Array.from(keySet);
    },

    /* Private methods */
};

/**
 * good
 */
function createTree(tree = {}) {
    const invalidKeys = [];
    const invalidCoordinateKeys = [];
    Object.keys(tree).forEach(key => {
        if (!isNumberString(key)) invalidKeys.push(key);
        ["longitude", "latitude"].forEach(prop => {
            if (tree[key][prop] != null) {
                if (isNumberString(tree[key][prop])) {
                    tree[key][prop] = parseFloat(tree[key][prop])
                } else if (typeof tree[key][prop] !== "number") {
                    invalidCoordinateKeys.push(key);
                }
            }
        });
    });
    if (invalidKeys.length !== 0) {
        throw new Error(`Interface could not be built. The following object keys aren't numbers: "${invalidKeys}".`);
    }
    if (invalidCoordinateKeys.length !== 0) {
        throw new Error(`Interface could not be built. The following object keys have objects with non-numeric longitude or latitude values: "${invalidCoordinateKeys.join(", ")}".`);
    }
    const treeWrapper = Object.create(treePrototype);
    treeWrapper.tree = tree;
    treeWrapper.treeMap = createTreeMap(tree);
    return treeWrapper;
}

//not optimal, but it works
function getMixedCaseKey(object, lowercaseKey) {
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
        if (keys[i].toLowerCase() === lowercaseKey) {
            return keys[i];
        }
    }
    throw new Error(`key "${lowercaseKey}" not found in object.`);
}

/**
 * Return true if this TreeWrapper can be moved, otherwise return false;
 * @return {boolean}
 */
function isValidForMove(objects) {
    //const objects = Object.values(this.tree);
    if (objects.length === 0) {
        alert(`Please select at least one circle to move.`);
        return false
    }
    const names = getNamesOfTypes(objects, "line");
    if (names.length !== 0) {
        alert(`Lines cannot be moved. Please unselect the following lines: ${names.join(", ")}.`);
        return false
    }
    return true
}

/**
 * This cannot be used directly for placing new components, because this function assumes that all objects
 * that are being moved already exist in the data. Its only acceptable for this function to be canceled
 * if the objects have already all been drawn.
 * @param {Array} keys
 */
function attachMoveListener(keys, tBody=null, tObject=null) {
//function attachMoveListener(tWrapper, tBody=null, tObject=null) {
    const objects = [];
    keys.forEach(key => {
        objects.push(gTree.getObject(key));
    });
    //const objects = Object.values(tWrapper.tree);
    if (isValidForMove(objects)) {
        const element = document.getElementById("svgContainer");
        element.setAttribute("style", "cursor: crosshair");
        const moveNodes = getMoveNodesFunction(objects, tBody, tObject);
        element.onclick = function(event) {
            moveNodes(event);
            createSvgData(keys).draw(gViewport);
        }
    }
}

/**
 * Translate the 'longitude' and 'latitude' properties of all nodes in this TreeWrapper according
 * to the arguments.
 * 
 * These x, y coordinate arguments are relative to the viewport, which means they have a minimum
 * value of 0 and that the gOffsetX and gOffsetY must be added to them before they are real 
 * coordinates to be stored in the tree.
 * @param {number} x - an x coordinate relative to the viewport, usually created with a click on the screen.
 * @param {number} y - a y coordinate relative to the viewport, usually created with a click on the screen.
 * @param {number} offsetX - corresponds to gOffsetX, which is how much the gTree is translated on 
 * the x-axis to fit in the created viewport.
 * @param {number} offsetY - corresponds to gOffsetY, which is how much the gTree is translated on 
 * the y-axis to fit in the created viewport.
 */
function move(objects, {x, y}, {offsetX, offsetY}) {
    const nodes = [];
    let avgLon = 0;
    let avgLat = 0;
    objects.forEach(obj => {
        if (getType(obj) !== "line") {
            nodes.push(obj);
            avgLon += obj.longitude;
            avgLat += obj.latitude;
        }
    });
    if (nodes.length === 0) {
        return;
    }
    avgLon /= nodes.length;
    avgLat /= nodes.length;
    nodes.forEach(node => {
        node.longitude = node.longitude - avgLon + offsetX + x/gDrawScaleFactor;
        node.latitude = node.latitude - avgLat + offsetY + y/gDrawScaleFactor;
    });
}

/**
 * TODO: do some sort of pre-scan to find an empty square in the graph to insert the configuration objects.
 * Parse this TreeWrapper.tree and insert longitude and latitude properties if a non-line type object does not contain them.
 * @param {number} initX - the longitude of the top left corner of the square.
 * @param {number} initY - the latitude of the top left corner of the square.
 * @param {number} spacing - how far apart the nodes should be spaced from one another
 */
function insertCoordinates(objects, initX, initY, spacing) {
    let gen = getCoordinates(initX, initY, spacing);
    objects.forEach(obj => {
        if (getType(obj) !== "line" && (obj.longitude == null || obj.latitude == null)) {
            let coords = gen.next().value;
            obj.longitude = coords.longitude;
            obj.latitude = coords.latitude;
        }
    });
}

/**
 * @param {Object[]} objects
 * @param {string[]} types
 * @return string[]
 */
function getNamesOfTypes(objects, ...types) {
    return objects.filter(obj => {
        const type = getType(obj);
        return types.includes(type);
    }).map(obj => obj.name !== undefined ? obj.name : Object.values(obj)[0]);
}

/**
 * @param {Object[]} selection
 * @param {Object} component
 * @return {boolean}
 */
function isValidForAdd(keys, component) {
    const selection = keys.map(key => gTree.getObject(key));
    const type = getType(component);
    const configNames = getNamesOfTypes(selection, "configurationNode");
    const lineNames = getNamesOfTypes(selection, "line");
    const errorMsgStart = `This component "${component.object}" `;
    const errorMsgConfig = `Please unselect the following configuration nodes: "${configNames.join(", ")}" before trying to add this component again.`;
    const errorMsgLine = `Please unselect the following lines: "${lineNames.join(", ")}" before trying to add this component again.`;
    switch (type) {
        case "independentNode":
        case "configurationNode":
            if (selection.length !== 0) {
                alert(errorMsgStart + "cannot be inserted using other objects. Please unselect all objects before adding this component again.");
                return false;
            }
            break;
        case "childNode":
            if (configNames.length > 0) {
                alert(errorMsgStart + "cannot be added as a child of a configuration node. " + errorMsgConfig);
                return false;
            }
            break;
        case "line":
            if (selection.length === 1) {
                alert("Please select at least 2 circles to add this line.");
                return false;
            } else if (configNames.length > 0) {
                alert(errorMsgStart + "cannot be connected to configuration nodes. " + errorMsgConfig);
                return false;
            } else if (lineNames.length > 0) {
                alert(errorMsgStart  + "cannot be connected to lines. " + errorMsgLine);
                return false;
            } 
            /* If any nodes in the selection already have a line between them, fail. special case will require refactor of this method */
            for (let i = 0; i < keys.length; i++) {
                const pairedNodes = gTree.getPairedNodeKeys(keys[i]);
                if (pairedNodes != null) {
                    let previouslyConnectedNodes = pairedNodes.filter(key => keys.includes(key));
                    if (previouslyConnectedNodes.length > 0) {
                        alert(`Insertion failed. The node named "${gTree.getObject(keys[i]).name}" is already connected to nodes "${previouslyConnectedNodes.map(key => gTree.getObject(key).name).join(", ")}".`);
                        return false;
                    }
                }
            }
            break;
    }
    return true;
}
/* Functions to port */

//**************************************************
// Utility methods
//**************************************************

/**
 * There are 4 types of objects: lines, child nodes, independent nodes, and configuration nodes.
 * The line between a parent and child doesn't exist in the data itself, it's merely shown in the svg
 * to demonstrate the relationship between two nodes.
 */

/* Public utility methods */

/**
 * Return true if the string is a valid number, otherwise return false. Thanks stackoverflow.
 * @param {string}
 * @return {boolean}
 */
function isNumberString(str) {
    if (typeof str !== "string" || /\s/.test(str)) {
        //console.error(`Expected "${str}" to be a string without whitespace, but it was not.`);
        return false;
    } 
    if (isNaN(str) || isNaN(parseFloat(str))) {
        //console.error(`Expected "${str}" to be a string that could be parsed to a number, but it was not.`);
        return false;
    }
    return true;
}

/**
 * Return the type of the object with regard to this interface.
 * 
 * This function is important because the order in which an object is checked matters. For example, an object
 * could be both a 'line' type and a 'configurationNode' type, but the 'line' type should take precedence over the 
 * 'configurationNode' type, so 'line' should be returned.
 * @param {Object} obj
 * @return {string}
 */
function getType(obj) {
    if (isLine(obj)) {
        return "line";
    } else if (isConfigurationNode(obj)) {
        return "configurationNode";
    } else if (isChildNode(obj)) {
        return "childNode";
    }
    return "independentNode"
}

/** 
 * Return an object that is a copy of the argument object.
 * JSON.stringify will not copy a property of an object with an undefined value.
 * @param {Object} oldObject - the object to copy.
 * @return {Object} - a copy of the object argument.
 */
 function deepCopy(oldObject) {
    if (Object.getPrototypeOf(oldObject) !== Object.prototype) {
        throw new Error("This function cannot be used to copy objects that are not plain JavaScript objects.");
    }
    const properties = Object.getOwnPropertyNames(oldObject);
    const keys = Object.keys(oldObject);
    for (let key of keys) {
        if (typeof(oldObject[key]) === "function") {
            throw new Error("This function cannot be used to copy objects with methods.");
        } else if (oldObject[key] === undefined) {
            throw new Error("JSON.stringify silently ignores properties with undefined values, so this function cannot handle undefined values.");
        }
    }
    return JSON.parse(JSON.stringify(oldObject));
}

/* Private utility methods */

/**
 * Return true if the object has a 'parent' property, otherwise return false.
 * @param {Object} obj
 * @return {boolean}
 */
function isChildNode(obj) {
    return obj.parent !== undefined;
}

/**
 * Return true if the object has 'from' and 'to' properties, otherwise return false.
 * @param {Object} obj
 * @return {boolean}
 */
function isLine(obj) {
    return obj.from !== undefined && obj.to !== undefined;
}

/**
 * Return true if the object is a configuration node.
 * @param {Object} obj
 * @return {boolean}
 */
function isConfigurationNode(obj) {
    if (obj.object == null || configurationTypes.includes(obj.object)) return true;
    return false;
}

/**
 * TODO: add unit tests
 * Return a generator that will provide the longitude and latitude for an object.
 * 
 * @param {number} initX - the longitude of the top left corner of the square.
 * @param {number} initY - the latitude of the top left corner of the square.
 * @param {number} spacing - how far apart to space a node from adjacent nodes in the square.
 * @return {Generator}
 */
function * getCoordinates(initX, initY, spacing) {
    yield {
        longitude: initX,
        latitude: initY
    }
    let x = 0;
    let y = 0;
    let dimension = 1;
    while (true) {
        if (x <= dimension) {
            yield {
                longitude: initX + (x++ * spacing),
                latitude: initY + (dimension * spacing)
            }
        } else {
            yield {
                longitude: initX + (dimension * spacing),
                latitude: initY + (y++ * spacing)
            }
        }
        if (y === dimension) {
            dimension++;
            x = 0;
            y = 0;
        }
    }
}

//**************************************************
// SVG interface
//**************************************************

const circlePrototype = {
    /**
     * good. doesn't need tests
     */
    getNewInstance() {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this.update(circle);
        return circle; 
    },
    /**
     * good. doesn't need tests
     */
    update(circle) {
        if (circle.classList.contains("selected")) {
            circle.setAttribute("class", `${this.class} selected`);
        } else {
            circle.setAttribute('class', this.class);
        }
        circle.setAttribute('id', this.id);
        circle.setAttribute('r', this.r);
        circle.setAttribute('stroke-width', this["stroke-width"]);
        circle.setAttribute('cx', this.cx);
        circle.setAttribute('cy', this.cy);
    }
};

/**
 * good. doesn't need unit tests
 */
function createCircle(nodeKey) {
    const circle = Object.create(circlePrototype);
    let tree = gTree;
    if (arguments[1] != null) tree = arguments[1]; // Need this for testing
    const node = tree.getObject(nodeKey);
    circle.id = nodeKey;
    circle.class = node.object;
    circle.r = 2 * gScaleLevel;
    circle["stroke-width"] = .5 * gScaleLevel;
    const lon = node.longitude;
    if (typeof lon !== "number") throw new Error(`'longitude' must be a number.`);
    const lat = node.latitude;
    if (typeof lat !== "number") throw new Error(`'latitude' must be a number.`);
    circle.cx = (lon - gOffsetX) * gDrawScaleFactor;
    circle.cy = (lat - gOffsetY) * gDrawScaleFactor;
    return circle;
}

const linePrototype = {
    /**
     * good. doesn't need tests
     */
    getNewInstance() {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        this.update(line);
        return line; 
    },

    /**
     * good. doesn't need tests
     */
    update(line) {
        if (line.classList.contains("selected")) {
            line.setAttribute("class", `${this.class} selected`);
        } else {
            line.setAttribute('class', this.class);
        }
        line.setAttribute('id', this.id);
        line.setAttribute('stroke-width', this["stroke-width"]);
        line.setAttribute('x1', this.x1);
        line.setAttribute('x2', this.x2);
        line.setAttribute('y1', this.y1);
        line.setAttribute('y2', this.y2);
    }
};

/**
 * good. doesn't need tests
 */
function createParentChildLineWithLine(lineKey, childKey) {
    let tree = gTree;
    if (arguments[2] != null) tree = arguments[2]; // Need this for testing
    const line = Object.create(linePrototype);
    const toNode = tree.getToNode(lineKey);
    const fromNode = tree.getFromNode(lineKey);
    if (toNode == null || fromNode == null) return; // The parent line could itself have nonexistent 'to' or 'from' nodes.
    const child = tree.getObject(childKey);
    line.x1 = (((toNode.longitude + fromNode.longitude)/2) - gOffsetX) * gDrawScaleFactor;
    line.y1 = (((toNode.latitude + fromNode.latitude)/2) - gOffsetY) * gDrawScaleFactor;
    line.x2 = (child.longitude - gOffsetX) * gDrawScaleFactor;
    line.y2 = (child.latitude - gOffsetY) * gDrawScaleFactor;
    line.id = getParentChildLineId(lineKey, childKey, tree);    
    line.class = "parentChild";
    line["stroke-width"] = .5 * gScaleLevel;
    return line;
}

// TODO: allow inserting testing tree if needed
function getParentChildLineId(parentKey, childKey) {
    let tree = gTree;
    if (arguments[2] != null) tree = arguments[2]; // Need this for testing
    const parent = tree.getObject(parentKey);
    const parentName = parent.name != null ? parent.name : `undefined${parentKey}`;
    const child = tree.getObject(childKey);
    const childName = child.name != null ? child.name : `undefined${childKey}`;
    return `${parentName}_${childName}`; 
}

/**
 * good. doesn't need tests
 */
function createParentChildLineWithNode(parentKey, childKey) {
    let tree = gTree;
    if (arguments[2] != null) tree = arguments[2]; // Need this for testing
    const line = Object.create(linePrototype);
    const parent = tree.getObject(parentKey);
    const child = tree.getObject(childKey); // Don't need to check for nonexistent parent because I already do that elsewhere
    line.x1 = (parent.longitude - gOffsetX) * gDrawScaleFactor;
    line.y1 = (parent.latitude - gOffsetY) * gDrawScaleFactor;
    line.x2 = (child.longitude - gOffsetX) * gDrawScaleFactor;
    line.y2 = (child.latitude - gOffsetY) * gDrawScaleFactor;
    line.id = getParentChildLineId(parentKey, childKey, tree);
    line.class = "parentChild";
    line["stroke-width"] = .5 * gScaleLevel;
    return line;
}

/**
 * good. doesn't need unit tests
 */
function createLine(lineKey) {
    let tree = gTree;
    if (arguments[1] != null) tree = arguments[1]; // Need this for testing
    const line = Object.create(linePrototype);
    const toNode = tree.getToNode(lineKey);
    const fromNode = tree.getFromNode(lineKey);
    if (toNode == null || fromNode == null) return; // A line could have nonexistent 'to' or 'from' nodes
    line.x1 = (fromNode.longitude - gOffsetX) * gDrawScaleFactor;
    line.y1 = (fromNode.latitude - gOffsetY) * gDrawScaleFactor;
    line.x2 = (toNode.longitude - gOffsetX) * gDrawScaleFactor;
    line.y2 = (toNode.latitude - gOffsetY) * gDrawScaleFactor;
    line.id = lineKey;
    const lineObject = tree.getObject(lineKey);
    const phaseCount = countPhases(lineObject.phases);
    line.class =  `${lineObject.object} p${phaseCount}`;
    switch (phaseCount) {
        case 2:
            line["stroke-width"] = 2 * gScaleLevel;
            break;
        case 3:
            line["stroke-width"] = 3 * gScaleLevel;
            break;
        default:
            line["stroke-width"] = gScaleLevel;
    }
    return line;
}

const svgDataPrototype = {

    /* Public methods */

    /**
     * good. doesn't need tests
     */
    draw(viewport) {
        this.setSubtreeToRedraw();
        this.quickDraw(viewport);
    },

    /**
     * good. doesn't need tests
     * Use this function when initializing the interface because it's a bit faster since it doesn't traverse subtrees.
     */
    quickDraw(viewport) {
        this.createData();
        this.parentChildLines.forEach(line => {
            this.appendSvg(line, viewport);
        });
        this.lines.forEach(line => {
            this.appendSvg(line, viewport);
        });
        this.circles.forEach(circle => {
            this.appendSvg(circle, viewport);
        });
    },

    /**
     * Just update existing objects. This is an optimization I can worry about later.
     */
    update() {},

    /**
     * good. Doesn't need tests. Need to figure out delete strategy
     */
    delete(viewport) {
        this.primaryKeySet.forEach(key => {
            const obj = this.tree.getObject(key);
            const type = getType(obj);
            if (type === "childNode") {
                const parentKey = this.tree.treeMap.getParentKey(key);
                if (parentKey != null) { // child could have a nonexistent parent
                    const id = getParentChildLineId(parentKey, key);
                    const e = document.getElementById(id);
                    viewport.removeChild(e);
                }
            }
            const e = document.getElementById(key);
            if (gSelection.hasId(key)) gSelection.remove(e);
            viewport.removeChild(e);
        });
        this.tree.delete(Array.from(this.primaryKeySet));
    },

    /* Private methods */

    /**
     * good. doesn't need tests
     */
    appendSvg(obj, viewport) {
        const e = document.getElementById(obj.id);
        if (e != null) {
            // Element already exists. Since we are doing a full redraw, remove it, update it, and re-append it.
            e.parentElement.removeChild(e);
            obj.update(e);
            viewport.appendChild(e);
        } else {
            viewport.appendChild(obj.getNewInstance());
        }
    },

    /**
     * good.
     */
    createData() {
        this.parentChildLines = [];
        this.lines = [];
        this.circles = [];
        this.subtreeKeySet.forEach(key => {
            const type = getType(this.tree.getObject(key));
            switch (type) {
                case "line":
                    const line = createLine(key, this.tree);
                    if (line != null) this.lines.push(line);
                    break;
                case "childNode":
                    this.circles.push(createCircle(key, this.tree));
                    const parentKey = this.tree.treeMap.getParentKey(key);
                    // child could have nonexistent parent. Also, we only want parent-child lines for children of objects in the subtreeKeySet
                    if (parentKey != null && this.subtreeKeySet.has(parentKey)) {
                        const parentType = getType(this.tree.getObject(parentKey));
                        if (parentType === "line") {
                            const line = createParentChildLineWithLine(parentKey, key, this.tree);
                            if (line != null) this.parentChildLines.push(line);
                        } else {
                            const line = createParentChildLineWithNode(parentKey, key, this.tree)
                            if (line != null) this.parentChildLines.push(line);
                        }
                    }
                    break;
                case "independentNode":
                case "configurationNode":
                    this.circles.push(createCircle(key, this.tree));
                    break;
            };
        });
    },

    /**
     * good.
     * Get the parent, children, connected lines, children of connected lines, paired nodes, and node ends of the object being redrawn.
     */
    setSubtreeToRedraw() {
        this.primaryKeySet.forEach(key => {
            const parentKey = this.tree.treeMap.getParentKey(key);
            if (parentKey != null) {
                this.subtreeKeySet.add(parentKey);
                if (getType(this.tree.getObject(parentKey)) === "line") {
                    // If the parent line is redrawn, it will cover it's connected nodes unless I do this
                    this.subtreeKeySet.add(this.tree.getToNodeKey(parentKey));
                    this.subtreeKeySet.add(this.tree.getFromNodeKey(parentKey));
                }
            }
            const children = this.tree.treeMap.getChildKeys(key);
            if (children != null) children.forEach(childKey => this.subtreeKeySet.add(childKey));
            const lines = this.tree.treeMap.getLineKeys(key);
            if (lines != null) {
                lines.forEach(lineKey => {
                    this.subtreeKeySet.add(lineKey);
                    // Must also get the children of lines!
                    const lineChildren = this.tree.treeMap.getChildKeys(lineKey);
                    if (lineChildren != null) lineChildren.forEach(childKey => this.subtreeKeySet.add(childKey));
                });
            }
            const pairs = this.tree.getPairedNodeKeys(key);
            if (pairs != null) pairs.forEach(nodeKey => this.subtreeKeySet.add(nodeKey));
            // Don't forget to account for adding a line, even though lines cannot be moved!
            const toNodeKey = this.tree.getToNodeKey(key);
            if (toNodeKey != null) this.subtreeKeySet.add(toNodeKey);
            const fromNodeKey = this.tree.getFromNodeKey(key);
            if (fromNodeKey != null) this.subtreeKeySet.add(fromNodeKey); 
        });
    },
}

/**
 * good. doesn't need tests
 * @param {Array} keys
 */
function createSvgData(keys) {
    const svgData = Object.create(svgDataPrototype);
    svgData.tree = gTree;
    if (arguments[1] != null) svgData.tree = arguments[1]; // Need this for testing
    svgData.primaryKeySet = new Set();
    svgData.subtreeKeySet = new Set();
    keys.forEach(key => {
        svgData.primaryKeySet.add(key);
        svgData.subtreeKeySet.add(key)
    });
    return svgData;
}

//**************************************************
// TreeObject interface
//**************************************************

const treeObjectPrototype = {

    /* Public TreeObject methods.*/

    /**
     * good. Doesn't need unit tests
     * Set the 'parent', 'longitude', and 'latitude' properties of this TreeObject.data based on the 'parent' argument.
     * @param {Object} parent - the object to set as the parent of this child.
     */
    setupChildNode(parentKey) {
        if (getType(this.data) !== "childNode") throw new Error("This TreeObject should have a type of 'childNode'.");
        const parent = gTree.getObject(parentKey);
        const type = getType(parent);
        if (type === "configurationNode") throw new Error("The 'parent' argument cannot be a configuration node.");
        this.data.parent = parent.name;
        if (type === "line") {
            this.setupChildNodeWithLine(parentKey);
        } else {
            this.setupChildNodeWithNode(parentKey);
        }
    },

    /**
     * good. Doesn't need unit tests
     * Set the 'from', 'to', and 'phases' properties of this TreeObject.data based on the 'source' and 'target' arguments.
     * @param {Object} source - the starting node of the line.
     * @param {Object} target - the ending node of the line.
     */
    setupLine(sourceKey, targetKey) {
        if (getType(this.data) !== "line") throw new Error("This TreeObject should have a type of 'line'.");
        const source = gTree.getObject(sourceKey);
        const target = gTree.getObject(targetKey);
        const sType = getType(source);
        const tType = getType(target);
        const types = ["childNode", "independentNode"];
        if (!types.includes(sType) || !types.includes(tType)) throw new Error("The 'source' and 'target' arguments should have a type of 'childNode' or 'independentNode'.");
        if (source.name == null || target.name == null) throw new Error("The 'source' and 'target' arguments should have a 'name' property.");
        if (source.phases === undefined) {
            const name = source.name !== undefined ? source.name : Object.values(source)[0]; 
            alert(`The source node of this line, "${name}", does not have a 'phases' property.`);
        } else {
            this.data.phases = source.phases;
        }
        this.data.from = source.name;
        this.data.to = target.name;
    },

    /* "Private" helper methods */

    setupChildNodeWithLine(lineKey) {
        const toNode = gTree.getToNode(lineKey);
        const fromNode = gTree.getFromNode(lineKey);
        const parentLongitude = (toNode.longitude + fromNode.longitude)/2;
        const parentLatitude = (toNode.latitude + fromNode.latitude)/2;
        const lonValue = this.getRandomOffset();
        this.data.longitude = Math.random() < 0.5 ? parentLongitude + lonValue : parentLongitude - lonValue; 
        const latValue = this.getRandomOffset();
        this.data.latitude = Math.random() < 0.5 ? parentLatitude + latValue : parentLatitude - latValue;
    },

    setupChildNodeWithNode(nodeKey) {
        const parent = gTree.getObject(nodeKey);
        const lonValue = this.getRandomOffset();
        this.data.longitude = Math.random() < 0.5 ? parent.longitude + lonValue : parent.longitude - lonValue;
        const latValue = this.getRandomOffset();
        this.data.latitude = Math.random() < 0.5 ? parent.latitude + latValue : parent.latitude - latValue;
    },

    getRandomOffset() {
        return lonValue = ((Math.random() * 4) + 4)/gDrawScaleFactor; 
    }
};

/**
 * Return a key value which has not been used in tree.
 * @return {string} key
 */
function getNewTreeKey(tree) { 
	let nextKey = Object.keys(tree).length;
	while(tree.hasOwnProperty(nextKey.toString())) {
		nextKey += 1;
	}
	return nextKey.toString();
}

/**
 * good
 */
// Return the number of phases a line has.
function countPhases(str) {
	let total = 0
    if (str == null) return total;
	if (str.search('A') > -1) {total++}
	if (str.search('B') > -1) {total++}
	if (str.search('C') > -1) {total++}
	return total;
}

/** 
 * Return a TreeObject.
 * 
 * A TreeObject (which is not to be confused with a more general "tree object") is either:
 * 1) a copy of a component that is in the process of being added to the tree, OR
 * 2) a copy of an existing object in the tree.
 * 
 * @param {(string|Object)} input - either a key OR a map of properties to create this TreeObject.
 * @param {TreeWrapper} tree - the treeWrapper from which to create this TreeObject.
 * return {TreeObject} - Either a new component that does not exist in the tree, or a copy of an existing tree object 
 * inside of the treeWrapper argument.
 */
function createTreeObject(input, tree) {
    if (Object.getPrototypeOf(tree) !== treePrototype) throw new Error("'tree' argument must be an instance of the Tree class.");
    const tObject = Object.create(treeObjectPrototype);
    if (typeof(input) === "string") {
        if (isNumberString(input)) {
            const obj = tree.getObject(input);
            tObject.key = input;
            tObject.data = deepCopy(obj);
            ['longitude', 'latitude'].forEach(prop => {
                if (tObject.data[prop] != null && typeof tObject.data[prop] === "string") {
                    throw new Error(`TreeObject creation failed. The tree object with key: "${input}" has a string value for its "${prop}" property.`);
                }
            });
            return tObject;
        } else {
            throw new Error(`TreeObject creation failed. If the 'input' argument is a string, it must be a numeric string.`);
        }
    } else if (typeof input === "object" && !Array.isArray(input)) {
        tObject.key = getNewTreeKey(tree.tree);
        tObject.data = deepCopy(input);
        //if (tObject.data.name != null && tObject.data.object != null) tObject.data.name = tObject.data.object + tObject.key;
        if (tObject.data.object != null) tObject.data.name = tObject.data.object + tObject.key;
        ['longitude', 'latitude'].forEach(prop => {
            if (tObject.data[prop] != null && typeof tObject.data[prop] === "string") {
                tObject.data[prop] = parseFloat(tObject.data[prop]);
            }
        });
        return tObject;
    } 
    throw new Error("TreeObject creation failed. The 'input' argument must be a string or an object.");
}

//**************************************************
// Table interface 
//**************************************************

/*
These are names of properties in most objects in writeFeeder.tree that should not be deleted from objects because
doing so might make that object hard to identify with reference to the rest of the data.
*/
const nonDeletableProperties = ["name", "object", "from", "to", "parent", "latitude", "longitude", "configuration"];
/* If these properties were to be modified for a given writeFeeder.tree object, it would require significantly modifying the 
other objects.  These properties ARE technically modifiable, but allowing the user to change them would require more work 
than I think is worth it. It is easier just to create a new node.
*/
const nonModifiableProperties = ["name", "object"];
const titleProperties = ["object"];
/* This array is used to determine if an object is a configuration node, based on the "object" property of that node. If a node
lacks the "object" property entirely, then I know its a configuration node.
Player is a configuration object. Recorder can have a parent, so it is NOT a configuration object.
*/
const configurationTypes = ["regulator_configuration", "transformer_configuration", "triplex_line_configuration", "line_configuration",
"volt_var_control", "line_spacing", "climate", "overhead_line_conductor", "underground_line_conductor", "triplex_line_conductor",
"player", "schedule"];

// delete this eventually
function rebuildSelectionTable() {
    destroyTables(["selectionTable"]);
    const ids = gSelection.getKeys();
    if (ids.length > 0) {
        const table = createSelectionTable(ids, gTree);
        document.getElementById("selectionTable").appendChild(table);
    } 
}
/**
 * TODO: add unit tests, $().draggable make the text unfocusable
 * If an object has no name, just get the first property in the object.
 */
function createSelectionTable(ids, tree) {
    const table = document.createElement("table");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody"); 

    const titleRow = createRow({key: "Selected Elements"});
    Array.from(titleRow.self.children).forEach(td => { td.classList.add("tableTitle") });
    titleRow.self.children[1].setAttribute("colspan", "2");
    titleRow.self.children[2].remove();

    tHead.append(titleRow.self);
    table.append(tHead);
    table.append(tBody);
    table.classList.add("dataTable");

    // duplicate
    const buttonRow = document.createElement("tr");
    buttonRow.classList.add("buttonRow");
    const buttonCell = document.createElement("td");
    buttonCell.setAttribute("colspan", "3");
    buttonCell.append(getTableButton("move", function() {
        destroyTables(["descriptionTables"]);
        attachMoveListener(gSelection.getKeys());
    }));
    buttonRow.append(buttonCell);
    tBody.append(buttonRow);
    // duplicate

    ids.forEach(id => {
        let obj = tree.getObject(id);
        let name = obj.name != null ? obj.name : obj.object != null ? obj.object : Object.keys(obj)[0];
        const button = getTableButton("view", getDisplayTableFunction(id));
        let row = createRow({key: name, value: button, deletable: true}, document.getElementById(id));
        tBody.append(row.self);
    });
    if (window.jQuery != null) {
        table.style.left = "50vw";
        $(table).draggable();
    }
    return table;
}

/* Helper functions */

function getDisplayTableFunction(id) {
    let displayTable = function() {
        let table = document.getElementById(`descriptionTable_${id}`);
        if (table == null) {
            const table = createDescriptionTable(id);
            table.id = `descriptionTable_${id}`;
            document.getElementById("descriptionTables").append(table);
        }           
    }
    return displayTable;
}

function getTableButton(text, func) {
    const button = document.createElement("button");
    button.textContent = text;
    button.classList.add("modalButton");
    button.addEventListener("click", func);
    return button;
}


/**
 * TODO: add unit tests, don't allow longitude and latitude to be editted for lines!,
 * turn all key inputs into plain text upon clicking save (would look nice), 
 * 
 * Bugs: $().draggable() makes text unfocusable via double click. Unfortunately,
 * this is set behavior of the library because the demo on the jQuery wesbsite behaves the same way. Users must right click
 * text in a table to select it.
 * 
 * The form element is only used to take advantage of the "required" form validation functionality that is native to the
 * browser.
 */
function createDescriptionTable(id) {
    const form = document.createElement("form");
    form.classList.add("formContainer");
    const table = document.createElement("table");
    table.classList.add("dataTable");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody");
    // duplicate
    const buttonRow = document.createElement("tr");
    buttonRow.classList.add("buttonRow");
    const buttonCell = document.createElement("td");
    buttonCell.setAttribute("colspan", "3");
    buttonRow.append(buttonCell);
    // duplicate
    form.append(table);
    table.append(tHead);
    table.append(tBody);
    tBody.append(buttonRow);
    const tObject = createTreeObject(id, gTree);
    if (getType(tObject.data) !== "line") {
        buttonCell.append(createButton({action: "move", tObject: tObject, tableBody: tBody}).self);
    }
    buttonCell.append(createButton({action: "delete", tObject: tObject, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "add", tObject: tObject, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "save"}).self);
    form.addEventListener("submit", function(event) {
        event.preventDefault();
        // Delete the object entirely just in case parent/to/from/ was changed, in order to delete parent-child lines
        const svg = createSvgData([tObject.key]);
        svg.delete(gViewport);
        gTree.insert(tObject);// overwrite the real object. It is remapped in the process.
        svg.draw(gViewport);
        alert("Object saved");
    });
    Object.keys(tObject.data).forEach(key => {
        let row;
        if (titleProperties.includes(key)) {
            row = createRow({key: key, tObject: tObject});
            Array.from(row.self.children).forEach(td => {
                td.classList.add("tableTitle");
            });
            tHead.append(row.self);
        } else {
            row = createRow({key: key, deletable: true, tObject: tObject});
            tBody.appendChild(row.self);
        }
    });
    if (window.jQuery != null) {
        table.style.left = "50vw";
        $(table).draggable();
    }
    return form;
}

/**
 * TODO: add unit tests
 */
 function destroyTables(ids) {
    ids.forEach(id => {
        const tableDiv = document.getElementById(id);
        Array.from(tableDiv.children).forEach(t => {
            tableDiv.removeChild(t);
        });
    });
}

const buttonPrototype = {

    /* Private helper methods */

    /**
     * TODO: update unit tests
     * Delete the TreeObject of this button from the TreeWrapper of this button
     */
    deleteObject() {
        const key = this.tObject.key;
        if (gTree.isDeletable(key)) {
            createSvgData([key]).delete(gViewport);
            rebuildSelectionTable();
        } else {
            let msg = "";
            const children = gTree.treeMap.getChildKeys(key);
            if (children != null) {
                msg += `Cannot delete object named "${gTree.getObject(key).name}" because it has children: "${children.join(", ")}". `;
            }
            const lines = gTree.treeMap.getLineKeys(key);
            if (lines != null) {
                msg += `Cannot delete object named "${gTree.getObject(key).name}" because it has connected lines: "${lines.join(", ")}". `;
            }
            msg += "Do you want to delete this object and all of its immediately connected objects?";
            if (confirm(msg)) {
                const keys = gTree.getSubtreeToDelete(key);
                keys.push(key);
                createSvgData(keys).delete(gViewport);
                //console.log(document.getElementById("svgContainer").onclick);
                rebuildSelectionTable();
            }
        }
    },

    /**
     * TODO: add unit tests
     */
    validateArguments(args) {
        if (args.action === "move") {
            //if (args.tObject == null || args.tWrapper == null || args.tableBody == null) {
            //    throw new Error(`A button with a "${args.action}" action must have non-null tObject, tWrapper, and tableBody arguments`);
            //}
        } else if (args.action === "delete") {
            if (args.tObject == null || args.tableBody == null) {
                throw new Error(`A button with a "delete" action must have non-null tObject and tableBody arguments`);
            }
        } else if (args.action === "add") {
            if (args.tObject == null || args.tableBody == null) {
                throw new Error(`A button with an "add" action must have non-null tObject and tableBody arguments`);
            }
        } else if (args.action !== "save") {
            throw new Error(`The action argument must match an existing action`);
        }
    }
}

/**
 * TODO: add unit tests, DON'T remove tObject argument, remove tWrapper argument
 */
function createButton({action, tableBody=null, tObject=null}) {
    const button = Object.create(buttonPrototype);
    button.validateArguments(arguments[0]);
    button.self = document.createElement("button");
    button.self.textContent = action;
    button.self.classList.add("modalButton");
    button.tObject = tObject;
    button.tableBody = tableBody;
    button.self.type = "button";
    switch (action) {
        case "move":
            button.self.addEventListener("click", function() {
                attachMoveListener([tObject.key], tableBody, tObject);
            });
            break;
        case "delete":
            button.self.classList.add("deleteButton");
            button.self.addEventListener("click", function() {
                button.deleteObject();                
                document.getElementById("descriptionTables").removeChild(tableBody.parentElement.parentElement);
            });
            break;
        case "add":
            button.self.addEventListener("click", function() {
                const row = createRow({key: "", deletable: true, tObject: tObject});
                tableBody.append(row.self);
            });
            break;
        case "save":
            button.self.type = "submit";
            break;
        default:
            throw new Error("The action argument must be a string that matches an existing action for this button.");
    }
    return button;
}

const rowPrototype = {

    /* Private helper methods */

    /**
     * Throw an error if arguments passed to createRow() were invalid.
     * @param {Object} args - an object containing the arguments that were passed to createRow().
     */
    validateArguments(args) {
        if (args.key != null && args.value != null && args.tObject != null) {
            throw new Error(`If there are key and tObject arguments, then the value of the row is determined by map[key] and passing a value
            argument is invalid`);
        } else if (args.tObject != null && args.tObject.data[args.key] === undefined && args.key !== "") {
            throw new Error("If a tObject argument is passed, the key argument should exist in that tObject.data.");
        } else if (args.key === "" && args.tObject == null) {
            throw new Error("If the key is an empty string, a tObject argument should be passed to the function");
        }
    },

    /**
     * Return false if the key already exists in the map or, otherwise return true.
     * @param {string} key - the incoming key that the user wants to write into the map belonging to this Row.
     * @return {boolean}
     */
    validateNewKey(key) {
        // These keys cannot be added becasue they would turn the object into a different type. If a user wants such an object, they should add a new one and edit its attributes.
        const invalidKeys = [undefined, "", "to", "from", "parent"];
        if (invalidKeys.includes(key)) return false;
        if (this.tObject.data[key] !== undefined) return false;
        return true;
    },

    /** 
     * Return false if the current key is an empty string, otherwise return true.
     * @return {boolean}
     */
    validateCurrentKey() {
        return this.key === "" ? false : true;
    },

    /**
     * Update a key in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new key that should be written to the map, if it is valid.
     */
    updateMapKey(input) {
        const newKey = input.value.trim();;
        if (this.validateNewKey(newKey)) {
            this.tObject.data[newKey] = this.tObject.data[this.key] != null ? this.tObject.data[this.key] : "";
            delete this.tObject.data[this.key];
            this.key = newKey;
        } else {
            alert(`A new attribute must not match an existing attribute. Additionally, the attributes "", "parent", "to", and "from" cannot be added.`);
            input.value = this.key;
        } 
    },
    /**
     * Return an HTMLTableCellElement.
     * @return {HTMLTableCellElement}
     */
    getKeyElement() {
        const td = document.createElement("td");
        if (this.key === "") {
            const input = document.createElement("input");
            input.classList.add("modalInput");
            td.appendChild(input);
            input.required = true;
            input.pattern = "[\\s]*[\\S]+.*";
            const that = this;
            input.addEventListener("change", function() {
                that.updateMapKey(this);
            });
        } else {
            td.textContent = this.key;
        } 
        return td;
    },

    /** 
     * Return true if the value is valid for the Row (based on the key of that Row), otherwise return false.
     * @param {string} value - a value for a corresponding key that should be validated based on the key.
     * @return {boolean}
     */
    validateNewValue(value) {
        if (this.key === "longitude" || this.key === "latitude") return isNumberString(value);
        if (this.key === "parent") {
            if (isValidParentName(value)) return true;
            return false;
        }
        if (this.key === "to" || this.key === "from") {
            if (isValidToOrFromNode(value)) {
                if (this.key === "to" && this.tObject.data.from === value) return false;
                if (this.key === "from" && this.tObject.data.to === value) return false;
            }
        }
        return true;
    },

    /** 
     * Update a value in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new value that should be written to the map, if the value is valid.
     */
    updateMapValue(input) {
        if (!this.validateCurrentKey()) {
            alert("Please enter a valid key for this row before entering a value.");
            input.value = "";
            return;
        }
        let newValue = input.value.trim();
        if (this.validateNewValue(newValue)) {
            if (this.key === "longitude" || this.key === "latitude") newValue = parseFloat(newValue);
            this.tObject.data[this.key] = newValue;
        } else {
            alert(`The value "${newValue}" is invalid for for the key "${this.key}" in the table.`);
            input.value = this.tObject.data[this.key];
        }
    },
    /** 
     * Return an HTMLTableRowElement.
     * @param {Array} nonModifiableProperties - a hard-coded array of properties that the user shouldn't be able to modify.
     * @return {HTMLTableRowElement}
     */
    getValueElement(nonModifiableProperties) {
        const td = document.createElement("td");
        if (typeof(this.value) === "string") {
            // Display a string with no regard to any TreeObject
            td.textContent = this.value;
            return td;
        } else if (this.value instanceof HTMLElement) {
            // Display another HTMLElement instead of a string
            td.append(this.value);
            return td;
        } else if (this.value == null) {
            if (this.tObject == null) {
                // Don't display any value
                return td;
            } else {
                // Display value within TreeObject.data
                const value = this.key === "" ? "" : this.tObject.data[this.key];
                if (nonModifiableProperties.includes(this.key)) {
                    td.textContent = value;
                } else {
                    const input = document.createElement("input");
                    if (this.key === "longitude") {
                        input.dataset.coordinate = "longitude";
                    } else if (this.key === "latitude") {
                        input.dataset.coordinate = "latitude";
                    }
                    input.classList.add("modalInput");
                    td.appendChild(input);
                    const that = this;
                    input.addEventListener("change", function() {
                        that.updateMapValue(this);
                    });
                    input.value = value;
                }
                return td;
            }
        }
        throw new Error("Invalid value was provided for this row");
    },

    /** 
     * TODO: add unit tests
     * Return an HTMLTableRowElement.
     * @param {boolean} deletable - whether or not the returned <td> should have a delete button element child.
     * @param {Array} nonDeletableProperties - a hard-coded array of properties that the user should not be able
     * to delete from a TreeObject.
     * @return {HTMLTableRowElement}
     */
    getDeleteElement(deletable, nonDeletableProperties) {
        const td = document.createElement("td");
        if (deletable === true && !nonDeletableProperties.includes(this.key)) {
            const btn = document.createElement("button");
            btn.innerHTML = "&#9587;"
            btn.setAttribute("class", "modalButton deleteButton"); 
            td.appendChild(btn);
            btn.addEventListener("click", () => { this.delete() });
        } 
        return td;
    },

    /**
     * TODO: update unit tests
     * Delete the row from the table. Delete the key from the map, if there was a map.
     */
    delete() {
        this.self.parentElement.removeChild(this.self);
        if (this.tObject != null) {
            delete this.tObject.data[this.key];
        } 
        // This is only used with the selection table rows (very confusing btw)
        if (this.element != null) {
            gSelection.remove(this.element);
            const table = document.getElementById(`descriptionTable_${this.element.id}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
            if (gSelection.getKeys().length === 0) {
                destroyTables(["selectionTable"]);
            }
        }
    },
}

/** 
 * Return a Row that can be appended to a table.
 * 
 * @param {string} key - the key of the row, which must be a property of the tObject.data argument if the tObject argument is not null.
 * @param {string|HTMLElement} - an optional value of the row.
 * @param {Object} map - an optional object that contains the data being manipulated by all of the rows. 
 * @param {?} value - either a string or an HTMLElement to be displayed outright, with no relationship to the tObject (which should be null if this argument is passed).
 * @param {boolean} deletable - whether or not the row should have a delete button.
 * @return {Row} - A wrapper object around the HTMLTableRowElement.
 */ 
function createRow({key, value=null, tObject=null, deletable=false}) {
    const obj = Object.create(rowPrototype);
    obj.validateArguments(arguments[0]);
    obj.key = key;
    obj.value = value;
    obj.tObject = tObject;
    //obj.map = map;
    obj.self = document.createElement("tr");
    obj.self.append(obj.getDeleteElement(deletable, nonDeletableProperties));
    obj.self.append(obj.getKeyElement());
    obj.self.append(obj.getValueElement(nonModifiableProperties));
    if (arguments[1] != null) {
        obj.element = arguments[1];
    }
    return obj;
}

//**************************************************
// Event listeners
//**************************************************

/**
 * TODO: add unit tests
 */
function getMoveNodesFunction(objects, tBody=null, tObject=null) {
    if (objects.length > 1 && tBody != null) {
        throw new Error("Cannot update a description table when multiple nodes have been selected to be moved.");
    }
    const moveNodes = function(event) {
        event.stopPropagation();
        detachListener();
        const coords = clickLatLon(event);
        move(objects, coords, {offsetX: gOffsetX, offsetY: gOffsetY});
        if (tObject != null) {
            if (objects.length !== 1) {
                throw new Error("Can only update the tObject of a description table when moving a single object!");
            }
            tObject.data.longitude = objects[0].longitude;
            tObject.data.latitude = objects[0].latitude;
        }
        if (tBody != null) {
            Array.from(tBody.getElementsByTagName("input")).forEach(input => {
                if (input.dataset.coordinate === "latitude") {
                    input.value = coords.y/gDrawScaleFactor + gOffsetY;
                } else if (input.dataset.coordinate === "longitude") {
                    input.value = coords.x/gDrawScaleFactor + gOffsetX;
                }
            });
        }
    };
    return moveNodes
}

function detachListener() {
    const element = document.getElementById("svgContainer");
    element.setAttribute("style", "cursor: default");
    element.onclick = null;
}

// Ignore drags, those should be handled by svg-panzoom.
function detectDrag(event) {
    return (gDownX !== event.clientX || gDownY !== event.clientY) ? true : false;
}

//**************************************************
// Initialization
//**************************************************

function attachMouseListeners() {
    document.getElementById("svgContainerWrapper").addEventListener("click", function(event) {
        handleSelection(event);
    });
    document.getElementById("svgContainerWrapper").addEventListener("mousedown", function(event) {
        gDownX = event.clientX;
    });
    document.getElementById("svgContainerWrapper").addEventListener("mouseup", function(event) {
        gDownY = event.clientY;
    });
    document.getElementById("scaleButton").addEventListener("click", function() {
        const userScale = prompt("Scale line thickness by this multiple:", gScaleLevel);
        if (isNumberString(userScale)) {
            scaleTo(parseFloat(userScale));
        }
    });
}

function attachKeyListener() {
    document.body.addEventListener("keydown", function(event) {
        if (event.target.tagName.toLowerCase() !== "input") {
            switch (event.key) {
                case "m":
                    destroyTables(["descriptionTables"]);
                    attachMoveListener(gSelection.getKeys());
                    break;
                case "-":
                    panZoom.zoomOut();
                    break;
                case "=":
                    panZoom.zoomIn();
                    break;
                case "Escape":
                    const svgContainer = document.getElementById("svgContainer");
                    if (svgContainer.onclick != null) {
                        alert("Operation cancelled");
                        detachListener();
                    }
                    break;
            }
        }
    });
}

function createInterface() {
    createViewport(writeFeeder.tree, document.getElementById("svgContainer"));
    gTree = createTree(writeFeeder.tree);
    const objects = Object.values(gTree.tree);
    insertCoordinates(objects, gOffsetX, gOffsetY, (1000/gDrawScaleFactor) * .005);
    gSelection = createSelection();
    gViewport = document.getElementsByClassName('svg-pan-zoom_viewport')[0];
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

function initializeJQuery() {
    if (window.jQuery != null) {
        applyJQueryStyles();
    } else {
        disableJQueryFunctionality();
    }
}

(function initialize() {
    createInterface();
    attachHandlers();
    initializeJQuery();
    attachMouseListeners();
    attachKeyListener();
    document.getElementById("searchInput").addEventListener("change", getSearchResults);
    document.getElementById('loadingMessage').style.display = 'none'
})();

    //buildFeeder();
    //const t0 = performance.now();

    /* 
    const t1 = performance.now();
    const time = t1 - t0;
    console.log(`Tree rendering time was ${time} ms`);
    */
    
    /*
    setTimeout(function() {
        const deleteSvgData = createDeletableSvgData(gTree.tree);
        deleteSvgData.deleteFrom(viewport);
    }, 2000);
    */

//ADD PROMPT TO SAVE CHANGES BEFORE EXIT
{% if showFileMenu %}
    // Browsers don't show custom 'beforeunload' messages anymore due to spamming users, so don't bother setting it
    window.onbeforeunload = function(event) {
        return "";
    }
{% endif %}
</script>
<!--<script type='text/javascript' src='/static/distDataValidation.js'></script>-->
{% if spec %}{{ spec | safe }}{% endif %}