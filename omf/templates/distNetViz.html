<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<style >
            /* Define global css variables */
            :root {
                --header-height: 25px;
                --header-padding-top: 10px;
                --header-padding-bottom: 10px;
            }
			* { 
                font-family: Helvetica, Arial, Sans-Serif;
            }
			div.divButton {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				cursor: pointer;
				cursor: hand;
				position:fixed;
				width:30px;
				height:30px;
				text-align:center;
				font-size:30px;
				line-height:30px;
				color:white;
			}
			body {margin:0px;}

            /* SVG */

            /* This is the element that acts as a hook for svg-pan-zoom.js to attach a viewport, which it creates itself */
			svg#svgContainer {
                /* width must be 100%, meaning 100% of the document */
				width: 100%; 
                /* height must be manually set to a hard value */
				height: calc(100vh - var(--header-height) - var(--header-padding-bottom) - var(--header-padding-top) - 5px);
                /* overflow: hidden is set by svg-pan-zoom.js itself. No need to change that here. */
			}
			#saveButton {
				float:right;
			}

            div#loadingMessage {
                width: 100%;
                height: 100%;
				/*background-color: rgba(0,0,0,0.4); */
                background-color: white;
                position: fixed;
                top: 0px;
            }

			/* Load Spinner */

			.loader {
				margin: 60px auto;
				font-size: 10px;
				position: relative;
				text-indent: -9999em;
				border-top: 1.1em solid rgba(255, 255, 255, 0.2);
				border-right: 1.1em solid rgba(255, 255, 255, 0.2);
				border-bottom: 1.1em solid rgba(255, 255, 255, 0.2);
				border-left: 1.1em solid #ffffff;
				-webkit-transform: translateZ(0);
				-ms-transform: translateZ(0);
				transform: translateZ(0);
				-webkit-animation: load8 1.1s infinite linear;
				animation: load8 1.1s infinite linear;
			}
			.loader,
			.loader:after {
				border-radius: 50%;
				width: 10em;
				height: 10em;
			}
			@-webkit-keyframes load8 {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}
			@keyframes load8 {
				0% {
					-webkit-transform: rotate(0deg);
					transform: rotate(0deg);
				}
				100% {
					-webkit-transform: rotate(360deg);
					transform: rotate(360deg);
				}
			}

			/* HEADER and MENU LINKS */

			a {
				text-decoration: none;
				color: white;
			}
			div#header {
				width:100%;
				height: var(--header-height);
				padding-top: var(--header-padding-top);
				padding-bottom: var(--header-padding-bottom);
				background:black;
                /*position: absolute;*/
				/*min-width:1000px;*/
			}
			div#headInnerBlock{ width:1000px; height:40px; font-size:medium; color:white; margin:4px auto 0 auto; }
			div#menuLeft{ height:40px; float:left; font-size:medium; color:white; margin-left:5px;}
			div#menuRight{ 
				/*height:40px;
				font-size:medium;
				color:white;*/
				float:right;
				display:flex;
				/*justify-content: space-between;
				width: 162px*/
			}
			div#arrow { font-size:8pt; position:absolute; margin-top:2px; margin-left:4px; display:inline; }
			ul.menu {
				position:absolute;
				top: 100%;
				left: 0;
				z-index: 1000;
				min-width: 100px;
				padding: 5px 0px 5px 0px;
				margin: 0px;
				list-style: none;
				display: none;
				text-align:left;
				background-color:#F8F8F8;
				padding:0;
				/*border: 1px solid #CCC;*/
				-webkit-border-radius: 5px;
				-moz-border-radius: 5px;
				border-radius: 5px 0px 5px 5px;
				-webkit-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				-moz-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
				-webkit-background-clip: padding-box;
			}
			ul.menu.right { right:0; left:auto; padding:5px 0px 5px 0px; overflow-y:auto; overflow-x:hidden; max-height:550px; }
			ul.menu.left { right:auto; left:auto; padding:0 0 0 0; }
			ul.menu.center { right:auto; left:-45%; }
			ul.menu li { 
                padding: 4px; 
                }
			ul.menu li:hover { background:green; color:white; }
			ul.menu li:hover a { color:white; }
			ul.menu a { 
                display:block;
                color:black;
                /*padding:4px;*/
                text-decoration: none 
                }
			ul.menu a:hover {color:white;}
			ul.menu { display:block; color:black; padding:4px; }
			ul.menu ul.menu:hover, ul.menu:visited:hover { color:white; }
			div.buttonGroup { display:inline-block; position:relative; }
			button.pill {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				color:white;
				font-size:medium;
				width: auto;
				height:35px;
				margin: 0px;
				margin-top:-5px;
				padding:0.3em;
				border-radius: 5px 5px 0 0;
				background-color:#E0E0E0;
				display:inline-block;
				border:none;background:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;
				white-space: nowrap;
				display:inline-block;
			}
			button.pill:hover{background:transparent;}

			/* MODAL DIALOGS */

            #loadModalTable {
                width: 890px;
            }
            /*#milsoftInput {
                width: 100%;
            }*/
            #progressModalCancel {
                background-color: crimson;
            }
            #progressModal {
                z-index: 1;
            }
			.modal {
                position: fixed;
                top: 0px;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
				background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
			}
	 		.modalContent {
                padding: 20px;
                border-radius: 10px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: space-evenly;
				background-color: #fefefe;
                /*height: 380px;*/
                overflow: hidden;
			}
            .modalInput {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
                width: 100%;
            }
            .modalButton {
                font-size: medium;
                background-color: seagreen;
                -webkit-border-radius: 5px;
                -moz-border-radius: 5px;
                border-radius: 5px;
                border: none;
                color: white;
                cursor: pointer;
                padding: 4px 6px 4px;
            }
            #cancelButton {
                background-color: crimson;
            }
            .modalContent td:nth-of-type(2) {
                text-align: right;
            }
            .modalTableHeader {
                font-weight: bold;
                text-align: left;
            }
            .modalTableRow {
                width: 50%;
            }
            .scrollableList {
                overflow: auto;
                height: 240px;
                list-style-type: none;
                margin: 0px 0px 0px 20px;
                padding: 0;
            }
            .feederItem {
                padding: 5px 5px 5px 5px;
                margin: 10px 0px 10px 0px;
            }
            .feederItem:hover {
                color: white;
                background-color: green;
            }
            
            /* Tree tables */

            .buttonRow {
                /*text-align: center;*/
            }
            .buttonRow button {
                margin-right: 5px;
            }
            /*
            .treeTable {
                background-color: white; 
            }
            .treeTable tr {
            }
            .treeTable tr:last-child {
                border: 0px;
            }
            */
            thead td {
                
            }
            .deleteButton {
                background-color: #CC0000;
                /*padding: 1px 7px 1px 7px;*/
            }
            .editButton {
                font-size: small;
                /*width: 100%;*/
            }

			/* descriptionTable */

			.descriptionTable {
				position: fixed;
				top: 55px;
				right: 5px;
				border:1px solid black;
				border-collapse: collapse;
                display: block;
                overflow-x: hidden;
				max-height: 80%;
			}
            .descriptionTable tr {
                border-bottom: 1px solid black;
            }
            .descriptionTable tr:last-child {
                border: 0px;
            }
            .descriptionTable p {
                margin: 0px;
            }
            .tableTitle {
                background-color: black;
                color: white;
            }
			tbody {
				/*border: 1px solid black;*/
                border-collapse: collapse;
			}
			td {
				background:white;
				padding: 5px;
				border-collapse: collapse;
			}
			th {
				font-weight: normal;
				/*background:black;*/
				/*color:white;*/
				padding: 5px;
			}
			/*
            #editButtonRow button {
				font-size: small;
				color: white;
				background: seagreen;
				padding: 5px;
				border-radius: 5px;
				width: 100%;
			}
            */
            /*
			#editButtonRow button:hover {
				outline:0;
				outline: none; 
				background:mediumseagreen;
			}
            */
		</style>
		<script type='text/javascript' src='/static/svg-pan-zoom.js'></script>
		{% if jasmine %}{{ jasmine | safe }}{% endif %}
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Largest.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Norfork.js'></script> -->
	</head>
	<!--<body onkeypress='hotkeys()' style='width:100%;height:100%'>-->
	<body style='width:100%;height:100%'>
        <div id="loadingMessage">
            <p style="font-size:60pt; text-align:center; width:100%;">Feeder Loading...</p>
        </div>
		<!-- Controls -->
		<div style='background:dimgrey; top:55px; left:5px' class='divButton' onclick='window.panZoom.zoomIn()' title='Zoom In'>+</div>
		<div style='background:dimgrey; top:95px; left:5px' class='divButton' onclick='window.panZoom.zoomOut()' title='Zoom Out'>-</div>
		<div style='background:dimgrey; top:135px; left:5px' class='divButton' onclick='window.panZoom.reset()' title='Reset Zoom'>R</div>
		<div style='background:dimgrey; top:175px; left:5px;' class='divButton' onclick='scaleTo(parseFloat(prompt("Scale line thickness by this multiple:", scaleLevel)))' title='Scale To'>S</div>
		<!-- <div style='background:navy; top:215px; left:5px' id='saveLink' class='divButton' onclick='saveSvg()' title='Save File' download>S</div> -->
		<!-- Menu Bar -->
		<div id='header'>
			<div id="menuRight">
				<div id="helpDiv">
					<div class="buttonGroup">
						<button class='pill' type = 'submit'>
							<a id='helpButton' href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit' target='_blank'>Help</a>
						</button>
					</div>
                </div>
                <div id="editDiv">
					<div class="buttonGroup">
                        <button id="addOps" class='pill' onclick='dropPill(this, "Edit")'>Edit &#x25BE;</button>
                        <ul class='menu right' style="display: none">
							<li><a href='javascript:toggleElementDisplay("findModal");'>Find...</a></li>
                        </ul>
                    </div>
                </div>
				<div id="addDiv">
					<div class="buttonGroup">
						<button id="addOps" class='pill' onclick='dropPill(this, "Add")'>Add &#x25BE;</button>
						<ul id='newObjectMenu' class='menu right' style="display: none">
					</div>
				</div>
				<div id="fileDiv">
					<div class='buttonGroup'>
                    {% if is_admin or not public %}
						<button id="fileOps" class='pill' onclick='dropPill(this, "File")'>File &#x25BE;</button>
						<ul class='menu right' style="display: none">
							<li><a href='javascript:saveFeeder();'>Save</a></li>
							<li><a href='javascript:downloadTextFile();'>View Raw Data</a></li>
							<li><a href='javascript:renameFeeder();'>Rename</a></li>
                            <li><a href='javascript:toggleElementDisplay("loadModal");'>Load from Model...</a></li>
							<li><a href='javascript:toggleElementDisplay("blankFeederModal");'>New Blank Feeder...</a></li>
							<li><a href='javascript:toggleElementDisplay("milsoftModal");'>Windmil Conversion...</a></li>
							<li><a href='javascript:toggleElementDisplay("gridlabModal");'>GridLAB-D Conversion...</a></li>
							<li><a href='javascript:toggleElementDisplay("cymeModal");'>CYMDIST Conversion...</a></li>
						</ul>
                    {% endif %}
					</div>
				</div>
			</div>
        </div>
        <!-- Svg container -->
        <!--<div id="svgContainerWrapper" style="height: auto; background-color: blue;">-->
        <div id="svgContainerWrapper" style="height: auto;">
            <!--<svg id='svgContainer' xmlns='http://www.w3.org/2000/svg' onclick='svgClick(event)' onmousedown='mouseDown(event)' onmouseup='mouseUp(event)'>-->
            <svg id='svgContainer' xmlns='http://www.w3.org/2000/svg'>
                <style type="text/css">
                    <![CDATA[
                    .house {fill:blue;}
                    .triplex_meter {fill:orange;}
                    .underground_line {stroke:gray;}
                    .transformer {stroke:orange;}
                    .regulator {stroke:red;}
                    line {stroke:black;}
                    line.parentChild {stroke:LightGrey;}
                    circle {stroke:white; fill:gray;}
                    line.selected, circle.selected {stroke:lime;}
                    ]]>
                </style>
            </svg>
        </div>
        <!-- Modals -->
		<div id='findModal' class="modal" style="display: none">
			<div class='modalContent' id='findModalContent' style='width:300px'>
				<table class='importOptions' style='padding:4px; word-wrap:break-word'>
					<tr>
						<td>Term</td>
						<td><input id='searchTerm' type='text'></td>
						<td id='searchHitCount' style='font-size:8pt; text-align:center'></td>
					</tr>
					<tr>
						<td><button style='width:75px' onclick='findPrevious()'>Previous</button></td>
						<td><button style='width:75px' onclick='findNext()'>Next</button></td>
						<td><button style='width:75px' onclick='toggleElementDisplay("findModal")'>Cancel</button></td>
					</tr>
				</table>
			</div>
        </div>
        <div id="loadModal" class="modal" style="display: none">
            <div class="modalContent">
                <table id="loadModalTable">
                    <tbody>
                        <tr>
                            <th class="modalTableHeader modalTableRow">Public Feeders</th>
                            <th class="modalTableHeader modalTableRow">My Feeders</th>
                        </tr>	
                        <tr>
                            <td class="modalTableRow"> 
                                <ul id="publicFeederList" class="scrollableList"></ul>
                            </td>
                            <td class="modalTableRow"> 
                                <ul id="userFeederList" class="scrollableList"></ul>
                            </td>
                        </tr>
                    </tbody>
                </table>
                <button onclick="toggleElementDisplay('loadModal')" class="modalButton">Cancel</button>
            </div>
        </div>
        <div id="blankFeederModal" class="modal" style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm('blankFeederInput', 'blankFeederForm'); return false;"
                action="/newBlankFeeder/{{thisOwner}}" method="POST" id="blankFeederForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <input type='hidden' name='referrer' value='distribution'/>
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Blank Feeder</th>
                            </tr>
                            <tr>
                                <td><label for="blankFeederInput">Name</label></td>
                                <td>
                                    <!-- TODO: add better validation than just the 'required' attribute-->
                                    <input type='text' required id="blankFeederInput" name='feederNameNew' class="modalInput"/>
                                </td>
                            </tr>
                            <tr>
                                <td><button type="button" onclick="toggleElementDisplay('blankFeederModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Create</button></td>
                            </tr>
                        </tbody>
                    </table>
                </form>
            </div>
        </div>
        <div id='milsoftModal' class='modal' style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm('milsoftInput', 'milsoftForm'); return false;"
                action="/milsoftImport/{{thisOwner}}" id="milsoftForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <input type='hidden' name='referrer' value='distribution'/>
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Milsoft Conversion</th>
                            </tr>
                            <tr>
                                <td><label for="milsoftInput">Name</label></td>
                                <td>
                                    <!-- TODO: add better validation than just the 'required' attribute-->
                                    <input type='text' required id="milsoftInput" name='feederNameM' class="modalInput"/>
                                </td>
                            </tr>
                            <tr>
                                <td>Data File (.std)</td>
                                <td><input type='file' required id="stdFile" name='stdFile' accept='.std' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td>Equipment File (.seq)</td>
                                <td><input type='file' required id="seqFile" name='seqFile' accept='.seq' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td><button type="button" onclick="toggleElementDisplay('milsoftModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Import</button></td>
                            </tr>
                        </tbody>
                    </table> 
                </form>
            </div>
        </div>
        <div id='gridlabModal' class='modal' style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm('gridlabInput', 'gridlabForm'); return false;"
                action="/gridlabdImport/{{thisOwner}}" id="gridlabForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <input type='hidden' name='referrer' value='distribution'/>
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">GridLab-D Conversion</th>
                            </tr>
                            <tr>
                                <td><label for="gridlabInput">Name</label></td>
                                <td>
                                    <!-- TODO: add better validation than just the 'required' attribute-->
                                    <input type='text' required id="gridlabInput" name='feederNameG' class="modalInput"/>
                                </td>
                            </tr>
                            <tr>
                                <td>Data File (.glm)</td>
                                <td><input type='file' required id="csvFile" name='glmFile' accept='.glm' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td><button type="button" onclick="toggleElementDisplay('gridlabModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Import</button></td>
                            </tr>
                        </tbody>
                    </table>
                </form>
            </div>
        </div>
        <div id='cymeModal' class='modal' style="display: none">
            <div class='modalContent'>
                <form onsubmit="submitForm('cymeInput', 'cymeForm'); return false;"
                action="/cymeImport/{{thisOwner}}" id="cymeForm">
                    <input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
                    <input type='hidden' id='feederNum' name='feederNum' value='{{thisFeederNum}}'/>
                    <input type='hidden' id='modelName' name='modelName' value='{{thisModelName}}'/>
                    <input type='hidden' name='referrer' value='distribution'/>
                    <table>
                        <tbody>
                            <tr>
                                <th class="modalTableHeader modalTableRow">Cyme Conversion</th>
                            </tr>
                            <tr>
                                <td><label for="cymeInput">Name</label></td>
                                <td>
                                    <!-- TODO: add better validation than just the 'required' attribute-->
                                    <input type='text' required id="cymeInput" name='feederNameC' class="modalInput"/>
                                </td>
                            </tr>
                            <tr>
                                <td>Network File (.mdb)</td>
                                <td><input type='file' required id="mdbNetFile" name='mdbNetFile' accept='.mdb' class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td><button type="button" onclick="toggleElementDisplay('cymeModal')" class="modalButton">Cancel</button></td>
                                <td><button type="submit" class="modalButton">Import</button></td>
                            </tr>
                        </tbody>
                    </table>
                </form>
            </div>
        </div>
        <div id="progressModal" class="modal" style="display: none">
            <div class="modalContent">
                <img src="/static/spinner.gif">
                <h2>text...</h2>
                <button class="modalButton" id="progressModalCancel">Cancel</button>
            </div>
        </div>
        <!-- Modals-->
        <div id="tableInsert"></div>
	</body>
</html>
<script id='componentsInsert'>const components = {% if components %}{{ components | safe }}{% else %}null{% endif %}; 
</script>
<script id='feederInsert'>const readFeeder = {% if thisFeederData %}{{ thisFeederData | safe }}{% else %}null{% endif %}; 
</script>
<script id='panZoomInsert'>
</script>
<script type='text/javascript'>
//"use strict";
let thisFeederName = "{% if thisFeederName %}{{ thisFeederName | safe }}{% else %}null{% endif %}";
const thisFeederNum = {% if thisFeederNum %}{{ thisFeederNum | safe }}{% else %}null{% endif %}; 
const thisModelName = "{% if thisModelName %}{{ thisModelName | safe }}{% else %}null{% endif %}"; 
const thisOwner = "{% if thisOwner %}{{ thisOwner | safe }}{% else %}null{% endif %}"; 
const publicFeeders = {% if publicFeeders %}{{ publicFeeders | safe }}{% else %}null{% endif %};
const userFeeders = {% if userFeeders %}{{ userFeeders | safe }}{% else %}null{% endif %}; 
const writeFeeder = deepCopy(readFeeder);
/* The globalTree can only be created after the entire file has been parsed */
let gTreeWrapper; 
let gViewport; 

// Globals to keep track of mouse coordinates
let downX, downY, upX, upY;
//let newNodeGenObj = {}; // What does this do?

//**************************************************
// Deprecated globals
//**************************************************

// Global to keep track of last element, for use in movebus function
//let lastElementSelected = {};

// Global to keep track of previous selection target
let previousTarget = {};

// Global to keep track of multiple alt-selections
let selection = []; 

//**************************************************
// Deprecated globals
//**************************************************

// Keeping track of search location
let searchCursor;
// Scale that all SVG objects are drawn at
let scaleLevel = 1.0; 

function saveSvg() { // eslint-disable-line
	// Create an SVG that can be saved.
	alert('We are redirecting you to a static version of the SVG that you can save as a .svg file.')
	var svg = document.getElementById('svgContainer').outerHTML
	var win = window.open()
	win.document.write(svg)
}

function downloadTextFile() { // eslint-disable-line
	// WARNING! Performance is very bad because the JSON is enormous! This can hang your browser!
	alert('We are opening a window with JSON in it that you can save as a .json file.')
	var modJson = JSON.stringify(writeFeeder);
	var win = window.open();
	win.document.write(modJson);
}

function createViewport(tree, svgContainer) {
	// Make a map objectName -> key. And while we're at it, find the size we need for the full chart.
	const nameToKey = {};
	let maxLon = 100;
	let maxLat = 100;
	for (let key in tree) {
        nameToKey[tree[key]['name']] = key;
        const lon = tree[key].longitude;
        const lat = tree[key].latitude;
        //if (lon) {
        //    /* Pretend we have really big coordinate values */
        //    tree[key].longitude = lon * 12000;
        //}
        //if (lat) {
        //    /* Pretend we have really big coordinate values */
        //    tree[key].latitude = lat * 12000;
        //}
		if (tree[key]['longitude'] > maxLon) {
            maxLon = tree[key]['longitude']
        }
        if (tree[key]['latitude'] > maxLat) {
            maxLat = tree[key]['latitude']
        }
	}
	maxLon = Math.round(maxLon + 20.0)
    maxLat = Math.round(maxLat + 20.0)

    //const svgOb = document.getElementById('svgContainer')

	//svgOb.setAttribute('width', maxLon)
	//svgOb.setAttribute('height', maxLat)
    //svgOb.setAttribute('viewBox','-10.0 -10.0 ' + maxLon + ' ' + maxLat)
    svgContainer.setAttribute('viewBox',`0 0 ${maxLon} ${maxLat}`);
    //console.log("maxLon: " + maxLon);
    //console.log("maxLat: " + maxLat);

	// Attach the pan/zoom behavior.
	window.panZoom = svgPanZoom('#svgContainer', {
        /* These are equal to the default values */
		//zoomEnabled: true,
		//controlIconsEnabled: false,
        //center: true,
		//fit: true,
        //contain: true,
        zoomScaleSensitivity: 0.2,
        minZoom: 0.25,
		maxZoom: 100
	});
}

function mouseDown(event) { // eslint-disable-line
	downX = event.pageX
	downY = event.pageY
}
function mouseUp(event) { // eslint-disable-line
	upX = event.pageX
	upY = event.pageY
}

function svgClick(event) { // eslint-disable-line
	// Listener on the SVG object that handles user clicks.
	if (downX !== upX || downY !== upY) {
		// Ignore drags, those should be handled by svg-panzoom.
		return
	}
	if (!event.altKey) {
		// Not holding alt and clicking the canvas, so clear the selection.
		clearGlobalSelectionArray();
		tableDestroy();
    }
	//if (event.target.id !== 'svgContainer' && !Array.from(document.getElementsByClassName("selected")).includes(document.getElementById(event.target.id) && /*!selection.includes(document.getElementById(event.target.id)) && writeFeeder.tree[event.target.id] !== undefined)*/) {
    if (event.target.id !== 'svgContainer') {
        const element = event.target;
        if (element.classList.contains("parentChild")) {
            // We don't do anything with thin parent-child lines, but we could!
            return;
        }
        if (!element.classList.contains("selected")) {
            element.classList.add("selected");
        }
		// Clicking on an item selects it.
		//lastElementSelected = (event.target);
        //event.target.classList.add('selected');

        tableDestroy();
        /* This alone is creating nodes, I don't even have to attach the table to the document
        */
        const table = createTable([event.target.id], gTreeWrapper);
        document.getElementById("tableInsert").appendChild(table);
        
		//tableCreate(writeFeeder.tree[event.target.id]);
		//selection.push(event.target);
	}
	// Alt for multiple selection.
	if (document.getElementsByClassName("selection").length >= 2) {
	//if (selection.length >= 2) {
		tableDestroy()
		multiSelectionTable()
	}
	previousTarget = event.target
}

//function hotkeys() {
//	// Handle hotkey presses.
//	let x;
//	if (window.event) {
//		// IE8 and earlier
//		x = event.keyCode
//	} else if (event.which) {
//		// IE9/Firefox/Chrome/Opera/Safari
//		x = event.which
//	}
//	var keychar = String.fromCharCode(x);
//	if (event.target.type !== 'text') {
//		// Dispatch the key:
//		if (keychar == '-') {
//			window.panZoom.zoomOut()
//		} else if (keychar == '=') {
//			window.panZoom.zoomIn()
//		} else if (keychar =='m') {
//			moveNode()
//		}
//	}
//}

/** Toggle the table row content between view-mode and edit-mode. 
 * Potentially useful when I want to update how the table saves
 */
function toggleRowContent(tr) {
	if (tr.children[0].tagName.toLowerCase() !== "td") {
		throw new TypeError("Invalid table-cell modification. This function should only modify <tr> elements " + 
		" that contain <td> elements, not <th> elements.");
	}
	if (tr.children.length === 3) {
		tr.removeChild(tr.children[0]);
		const valTd = tr.children[1];
		const val = valTd.children[0].getAttribute("value");
		valTd.innerHTML = val; 
	} else {
		const buttonTd = document.createElement("td");
		const button = document.createElement("button");
        button.setAttribute("onclick", "tableDel(this)");
        button.classList = "modalButton deleteButton";
        //button.innerHTML = "&#215"; 
        button.innerHTML = "&#9587;";
		buttonTd.appendChild(button); 
		const keyTd = tr.children[0]; 
		const valTd = tr.children[1];
		const valInput = document.createElement("input");
		valInput.setAttribute("data-feederval", "feederval");
		valInput.setAttribute("value", valTd.textContent);
		keyTd.parentElement.insertBefore(buttonTd, keyTd); 
		valTd.replaceChild(valInput, valTd.childNodes[0]);
	} 
}

/** Hide the object table. */
function tableDestroy() {
    const tableInsert = document.getElementById("tableInsert");
    Array.from(tableInsert.children).forEach(childNode => {
        tableInsert.removeChild(childNode);
    });
	//const table = document.getElementById("descriptionTable");
	//table.style.display = "none";
	//const tbody = table.children[0];
	//const deleteTargets = Array.from(tbody.children).filter(tr => tr.children[0].tagName.toLowerCase() === "td");
	//deleteTargets.forEach(node => {
	//	tbody.removeChild(node);
	//})
}

function scaleTo(x) {
	// Scale the thickness of all lines and size of all circles. This helps user see details.
	scaleLevel = x
	if (!x) {
		return
	}
	const circles = document.getElementsByTagName('circle')
	const lines = document.getElementsByTagName('line')
	// Scale Circles
	for (let i = 0; i < circles.length; i++) {
		circles[i].setAttribute('r', 2*x)
		circles[i].setAttribute('stroke-width', 0.5*x)
	}
	// Scale Lines
	for (let i = 0; i < lines.length; i++) {
		if (lines[i].getAttribute('class').indexOf('p2') !== -1) {
			lines[i].setAttribute('stroke-width', 2*x)
		}
		else if (lines[i].getAttribute('class').indexOf('p3') !== -1) {
			lines[i].setAttribute('stroke-width', 3*x)
		}
		else if (lines[i].getAttribute('class').indexOf('parentChild') !== -1) {
			lines[i].setAttribute('stroke-width', 0.5*x)
		}
		else {
			lines[i].setAttribute('stroke-width', x)
		}
	}
}

function dropPill(thisButton, name) { // eslint-disable-line
	// This function is used to make the dropdown menus work.
	thisButton.style.color= 'black'
	thisButton.style.background= '#F8F8F8'
	thisButton.style.textAlign = 'left'
	thisButton.nextSibling.nextSibling.style.display = 'inline-block'
	thisButton.innerHTML = name + ' &#x25B4;'
	function clickCloseEvent() {
		thisButton.nextSibling.nextSibling.style.display = 'none'
		thisButton.innerHTML = name + ' &#x25BE;'
		this.removeEventListener('click', arguments.callee, true)
		thisButton.style.color= 'white'
		thisButton.style.background= 'transparent'
		if (window.event.toElement==thisButton) {event.stopPropagation()}
	}
	document.body.addEventListener('click', clickCloseEvent, true)
}

/*function clickCloseEvent(labelName, buttonName) { // eslint-disable-line
	// This event allows users to close the dropdown menus.
	var thisButton = document.getElementById(buttonName);
	//thisButton.nextSibling.nextSibling.style.display = 'none'
	thisButton.nextElementSibling.style.display = "none";
	thisButton.innerHTML = labelName + ' &#x25BE;';
	//this.removeEventListener('click', arguments.callee, true);
	//if (window.event.toElement==thisButton) {event.stopPropagation()}
}*/

function multiSelectionTable() {
	// Display the table when a user has selected multiple objects.
	//const tabScroll = document.getElementById('tableScroller')
	//const tbl = document.createElement('table')
	//const headRow = document.createElement('tr')
	//headRow.innerHTML = '<th>Selected Elements</th>'
	//tbl.appendChild(headRow)
	const table = document.getElementById("descriptionTable");
	table.style.display = "block";
	const tbody = table.children[0];
	tbody.children[0].children[0].style.display = "none";
	//tbody.children[0].children[1].style.display = "none";
	tbody.children[0].children[1].style.display = "table-cell";
	tbody.children[1].style.display = "none";
	tbody.children[2].style.display = "none";
	// Put the object in.
	for (let i = 0; i < document.getElementsByClassName("selected").length; i++) {
	//for (let i = 0; i < selection.length; i++) {
		const row = document.createElement('tr');
		row.innerHTML = '<td>' + writeFeeder.tree[selection[i].id].name + '</td>';
		tbody.appendChild(row)
	}
	//tabScroll.appendChild(tbl)
}

function clickLatLon(event) {
	//Returns real Lat/Long of a click event, used in the moveBus function
	//const sizes = window.panZoom.getSizes();
    //const zoom = sizes.realZoom;
	const pan = window.panZoom.getPan();
    const zoom = panZoom.getSizes().realZoom;
	const svg = document.getElementById('svgContainer');
	let pt = svg.createSVGPoint();
	pt.x = event.clientX;
	pt.y = event.clientY;
	pt = pt.matrixTransform(svg.getScreenCTM().inverse());
	let x = pt.x;
	let y = pt.y;
	//x = (x - pan.x) / zoom;
	//y = (y - pan.y) / zoom;
	//return [x,y];
	// maybe this should be a class? We'll see...
	const coords = {
		x: (x - pan.x) / zoom,
		y: (y - pan.y) / zoom
	};
	return coords;
}

function clearGlobalSelectionArray() {
	//selection.forEach(element => {
	//	element.classList.remove("selected");
	//})
	//selection = [];
	Array.from(document.getElementsByClassName("selected")).forEach(element => element.classList.remove("selected"));
}

//**************************************************
// Populate menu functions
//**************************************************

/**
 * Fill menu of "Add" button and add its handler functions.
 */
function fillObjectMenu(components) {
	const menu = document.getElementById('newObjectMenu');
	for (let componentName in components) {
		const li = document.createElement("li");
		li.textContent = componentName;
		li.addEventListener("click", function() {
			//Using componentName here is a closure right?
			addSvgObjects(addFeederObject(componentName, document.getElementsByClassName("selected")));
		});
		menu.appendChild(li);
	}
}

/** TODO: add unit-tests
 * @param ul {Element} - An html element where the list will be attached
 * @param feeders {array} - An array of objects, where each object has properties "model" and "name", or null. 
 * @param owner {string} - Either "public" or the owner of the current writeFeeder.
 */
function attachFeederList(ul, feeders, owner) {
    if (feeders === null || feeders === undefined) {
        return
    } 
    for (let writeFeeder of feeders) {
        if (writeFeeder.name !== thisFeederName) {
            const li = document.createElement("li");
            li.classList.add("feederItem");
            li.innerHTML = `<strong>${writeFeeder.name}</strong> from <br>"${writeFeeder.model}"`;
            li.addEventListener("click", function() {
                //overwriteFeeder(writeFeeder.name, writeFeeder.model, owner);
                loadFeeder(writeFeeder.name, writeFeeder.model, owner);
            });
            ul.append(li);
        }
    }
}

/** If an element isn't displayed, set it's inline display value to the default browser value.
 * If the element is displayed, then hide it.
 */
function toggleElementDisplay(id) {
//function toggleDisplayAttribute(element) {
    const element = document.getElementById(id);
    if (element.style.display === "none") {
        element.removeAttribute("style");
    } else {
        element.style.display = "none";
    }
}
//**************************************************
// Description and selection table functions 
//**************************************************


//ADD PROMPT TO SAVE CHANGES BEFORE EXIT
{% if is_admin or not public %}
	window.onbeforeunload = function(e) {
		let confirmationMessage = 'It looks like you have been editing something. ';
		confirmationMessage += 'If you leave before saving, your changes will be lost.';
		//if (unsavedChanges) return confirmationMessage;
	};
{% endif %}

//**************************************************
// File menu functions v2
//**************************************************

/** This is done for testing reasons.
 */
function reloadWrapper() {
    /* Force the client to always request new files from the server without using the browser cache. 
    */
    window.location.reload(true);
}

function ProgressModal(message, cancelMessage, showButton) {
    this.self = document.getElementById("progressModal");
    this.button = this.self.getElementsByTagName("button")[0];
    this.header = this.self.getElementsByTagName("h2")[0];
    this.message = message;
    this.cancelMessage = cancelMessage;
    this.showButton = showButton;
}

ProgressModal.prototype.show = function() {
    this.header.textContent = this.message;
    this.self.removeAttribute("style");
    if (this.showButton) {
        this.button.removeAttribute("style");
    } else {
        this.button.style.display = "none";
    }
}

ProgressModal.prototype.hide = function() {
    this.self.style.display = "none";
}

//**************************************************
// TreeWrapper interface
//**************************************************

const treeWrapperPrototype = {

    /* "Public" interface methods */

    /** 
     * Return a TreeWrapper that represents which tree objects need to be redrawn as a result of inserting 
     * this TreeObject.
     * 
     * If the TreeObject.key does not exist in this TreeWrapper, the new TreeObject.key and new TreeObject.data are added to the
     * TreeWrapper. If the TreeObject.key does exist in this TreeWrapper, the data at the existing key is overwritten.
     * This is a public interface method, which means it should be used in event handlers and other places to do stuff.
     * While this method will work for ANY TreeWrapper, it is intended to be used with the "gTreeWrapper" only.
     * The gTreeWrapper encapsulates all the data of the model, which is what we want to work with.
     * @param {TreeObject} treeObject - contains a key and some data that will be used to add or overwite
     * data inside of this TreeWrapper.
     * @return {TreeWrapper} tWrapper - contains all of the tree objects that need to be redrawn as a result of 
     * modifying the data.
     */
     insert(treeObject) {
        this.tree[treeObject.key] = treeObject.data;
        this.names[treeObject.data.name] = treeObject.key;
        const tWrapper = createTreeWrapper();
        tWrapper.add(treeObject.key, this);
        tWrapper.merge(this.getSubtreeToRedraw(treeObject.key));
        return tWrapper;
    },

    /** 
     * Delete the tree object with the passed key argument from this TreeWrapper.
     * @param {string} key - the key used to identify the tree object to delete.
     * @return {TreeWrapper} tWrapper - contains 1 tree object that was affected by the delete operation.
     */
    delete(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            console.log(`Unable to perform delete operation. This TreeWrapper does not contain a tree object with key: "${key}".`);
            return tWrapper;
        }
        const childKeys = Object.keys(this.getChildrenOf(key).tree);
        if (childKeys.length > 0) {
            throw new Error(`Cannot delete object with key "${key}" because it has existing children. Please delete the children first.`);
            //console.log(`Cannot delete tree object with key "${key}" from the tree because it has existing children`);
            return tWrapper;
        }
        const lineKeys = Object.keys(this.getConnectedLinesOf(key).tree);
        if (lineKeys.length > 0) {
            throw new Error(`Cannot delete object with key "${key}" because it has connected lines. Please delete the connected lines first.`);
            //console.log(`Cannot delete tree object with key "${key}" from the tree because it has connected lines`);
            return tWrapper;
        }
        tWrapper.add(key, this);
        delete this.names[this.tree[key].name];
        delete this.tree[key];
        return tWrapper;
    },

    /** 
     * Delete the tree object with the passed key argument from this TreeWrapper. Also recursively delete any connected
     * lines and children. 
     * @param {string} key - the key of the tree object which should be deleted, along with any associated tree objects.
     * @return {TreeWrapper} - contains all of the tree objects that need to be removed from the svg
     * as a result of the recursive delete operation.
     */
    recursiveDelete(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to perform a recursive delete operation. The tree object with key "${key}" does not exist
            //in this TreeWrapper`);
            return tWrapper;
        }
        tWrapper.add(key, this);
        tWrapper.merge(this.getSubtreeToDelete(key, []));
        for (let key in tWrapper.tree) {
            delete this.names[this.tree[key].name];
            delete this.tree[key];
        }
        return tWrapper;
    },

    /* "Private" helper methods */

    /** 
     * Add an object from the tWrapper argument into this TreeWrapper.
     * @param {string} key - the key of the object to search for in the tWrapper argument.
     * @param {TreeWrapper} tWrapper - the TreeWrapper from which we want to get data to insert into this TreeWrapper.
     */
    add(key, tWrapper) {
        if (!tWrapper.contains(key)) {
            console.log(`Unable to add the key to this TreeWrapper. The tree object with the key: "${key}" does
            not exist in the tWrapper argument.`)
            return;
        }
        this.tree[key] = tWrapper.tree[key];
        const name = this.tree[key].name;
        if (name == null) {
            return;
        }
        this.names[name] = key;
    },

    /** 
     * Return a TreeWrapper that contains direct children of the tree object with the passed key argument.
     * @param {string} parentKey - the key of the tree object that is presumably a parent to some other tree objects.
     * @return {TreeWrapper} childrenTreeWrapper - contains only children tree objects of the parentKey tree object.
     */
    getChildrenOf(parentKey) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(parentKey)) {
            //console.log(`Unable to get the children of the tree object with key: "${parentKey}". The key does not exist in this
            //TreeWrapper.`);
            return tWrapper;
        }
        if (!isParentChildNode(this.tree[parentKey]) && !isParentlessNode(this.tree[parentKey])) {
            return tWrapper;
        }
        let parentName = this.tree[parentKey].name;
        if (parentName == null) {
            /* Children reference their parent with the parent's name. If a node doesn't have a name, then it must not
            have children.
            */
            //console.log(`Unable to get the children of the tree object with key: "${parentKey}". The tree object
            //does not have a name.`);
            return tWrapper;
        } 
        // TODO: Build an object in TreeWrapper that allows instant lookup of children for any TreeWrapper.tree object
        Object.keys(this.tree).forEach(key => {
            parentName = this.tree[key].parent;
            if (parentName != null && parentName === this.tree[parentKey].name) {
                tWrapper.add(key, this);
            }
        });
        return tWrapper;
    },

    /** Return a TreeWrapper that contains lines connected to the tree object with the passed key argument.
     *
     * @param {string} nodeKey - the key of the tree object that presumably has lines connected to it.
     * @return {TreeWrapper} subWrapper - contains only line tree objects that connect to the nodeKey tree object.
     */
    getConnectedLinesOf(nodeKey) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(nodeKey)) {
            //console.log(`Unable to find lines that connect to this node with key: "${nodeKey}". The key does not exist in this
            //TreeWrapper.`);
            return tWrapper;
        } else if (!isParentChildNode(this.tree[nodeKey]) && !isParentlessNode(this.tree[nodeKey])) {
            // This tree object is not a node, therefore no lines can connect to it
            return tWrapper;
        }

        const linesTreeWrapper = createTreeWrapper();
        // TODO: Build an object in TreeWrapper that allows instant lookup of connected lines for any TreeWrapper.tree object
        Object.keys(this.tree).forEach(key => {
            if (this.tree[key].to === this.tree[nodeKey].name || this.tree[key].from === this.tree[nodeKey].name) {
                linesTreeWrapper.add(key, this);
            }
        });
        return linesTreeWrapper;
    },

    /** Merge the treeWrapper argument into this TreeWrapper.
     * 
     * If no keys argument is passed, the entire treeWrapper argument is merged into this TreeWrapper.
     * If a keys argument is passed, only those tree objects with matching keys inside of the treeWrapper argument are merged
     * into this TreeWrapper.
     * @param {TreeWrapper} treeWrapper - contains tree objects that will be merged into this TreeWrapper
     * @param {Array} keys - an optional argument that limits which tree objects are merged into this TreeWrapper
     */
    merge(treeWrapper, keys) {
        if (keys === undefined) {
            Object.keys(treeWrapper.tree).forEach(key => {
                this.add(key, treeWrapper);
            });
        } else if (Array.isArray(keys)) {
            keys.forEach(key => {
                this.add(key, treeWrapper);
            });
        } else {
            throw new Error("If the keys argument is passed, it must be an array");
        }
    },

    /** Return a TreeWrapper that contains all tree objects that will be deleted as a result of deleting the
     * tree object with the passed key argument.
     * 
     * @param {string} key - the key of the tree object for which to find its deletable subtree.
     * @param {Array} visited - contains keys of tree objects that have already been visited so the method dosen't
     * recurse infinitely in case of a cycle.
     * @return {TreeWrapper}
     */
    getSubtreeToDelete(key, visited) {
        if (!Array.isArray(visited)) {
            throw new Error("Visited argument must be an array");
        }
        visited.push(key);
        const tWrapper = createTreeWrapper();
        const children = this.getChildrenOf(key);
        tWrapper.merge(children);
        tWrapper.merge(this.getConnectedLinesOf(key));
        if (Object.keys(children.tree).length > 0) {
            for (let childKey in children.tree) {
                if (!visited.includes(childKey)) {
                    tWrapper.merge(this.getSubtreeToDelete(childKey, visited));
                }
            }
        }
        return tWrapper;
    },

    /**
     * Return a TreeWrapper that contains only the parent tree object of the child tree object.
     * 
     * @param {string} childKey - the key of the child tree object.
     * @return {TreeWrapper} subWrapper - contains only the parent tree object of the child tree object.
     */
    getParentOf(childKey) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(childKey)) {
            //console.log(`Unable to get the parent of the tree object with key: "${childKey}". The key does not exist in this
            //TreeWrapper.`);
            return tWrapper;
        }  
        const parentName = this.tree[childKey].parent;
        if (parentName == null) {
            // This tree object doesn't have a parent, which is fine.
            return tWrapper
        }
        const parentKey = this.names[parentName];
        if (parentKey == null) {
            /* If parentKey is undefind, then either 1) the child node has a parent that doesn't exist in this graph or 
            2) the names object of a TreeWrapper was built incorrectly */
            //console.log(`Unable to get the parent of the child tree object with key: "${childKey}". The parent does not 
            //exist in this TreeWrapper.`); //or the 'names' property is being built wrong.
            return tWrapper;
        }
        tWrapper.add(parentKey, this);
        return tWrapper;
    },

    /** Return a TreeWrapper that contains only tree objects that are on the other ends of lines that connect
     * to the tree object with the passed key argument.
     * 
     * @param {string} key - the tree object for which to search for its paired nodes. Nodes have a paired relationship
     * if they are connected by a line.
     * @return {TreeWrapper} - contains only tree objects that are paired nodes of the tree object for which
     * we searched.
     */
    getPairedNodesOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key)) {
            //console.log(`Unable to get the paired nodes of the tree object with the key: "${key}". The key does not exist
            //in this TreeWrapper`);
            return tWrapper;
        }
        const linesTreeWrapper = this.getConnectedLinesOf(key);
        for (let lineKey in linesTreeWrapper.tree) {
            const fromKey = this.names[this.tree[lineKey].from];
            const toKey = this.names[this.tree[lineKey].to];
            if (key === fromKey) {
                // The 'from' node points to this tree object, so we want the other tree object
                tWrapper.add(toKey, this);
            } else if (key === toKey) {
                // The 'to' node points to this tree object, so we want the other tree object
                tWrapper.add(fromKey, this);
            } else {
                throw new Error(`There was a problem finding a "from" or "to" node for line with key: "${lineKey}"`);
            }
        }
        return tWrapper;
    },

    /** 
     * Return a TreeWrapper that contains nodes on either end of the line that is represented by the
     * tree object with the passed key argument.
     * @param {string} key - the key of the tree object that is a line. 
     * @return {TreeWrapper} subWrapper - contains only 2 tree objects that are on either end of the line,
     * or 0 tree objects if the tree object isn't a line!
     */
    getNodeEndsOf(key) {
        const tWrapper = createTreeWrapper();
        if (!this.contains(key) || !isLine(this.tree[key])) {
            //TODO add console message and maybe split these up
            return tWrapper;
        }
        const fromKey = this.names[this.tree[key].from];
        const toKey = this.names[this.tree[key].to];
        const subWrapper = createTreeWrapper();
        if (fromKey == null) {
            if (toKey == null) {
                console.log(`Tree object with key: "${key}" has nonexistent "from" and "to" nodes.`);
                return subWrapper;
            } else {
                console.log(`Tree object line with key: "${key}" has nonexistent "from" node.`);
                subWrapper.add(toKey, this);
                return subWrapper;
            }
        } else if (toKey == null) {
            console.log(`Tree object line with key: "${key}" has nonexistent "to" node.`);
            subWrapper.add(fromKey, this);
            return subWrapper;
        }
        subWrapper.add(fromKey, this);
        subWrapper.add(toKey, this);
        return subWrapper;
    },

    /**
     * 
     */
    getSubtreeToRedraw(key) {
        const tWrapper = createTreeWrapper();
        tWrapper.merge(this.getParentOf(key));
        tWrapper.merge(this.getChildrenOf(key));
        tWrapper.merge(this.getConnectedLinesOf(key));
        tWrapper.merge(this.getPairedNodesOf(key));
        tWrapper.merge(this.getNodeEndsOf(key));
        return tWrapper;
    },

    /** 
     * Return true if the tree of this TreeWrapper has the 'key' argument, otherwise return false;
     */
    contains(key) {
        if (this.tree[key] == null) {
            // Methods that use this method have more specific error messages that make this one redundant
            //console.log(`Unable to perform any operations with the 'key' argument.
            //No tree object with key: "${key}" exists in this TreeWrapper.`);
            return false;
        }
        const name = this.tree[key].name;
        if (name == null) {
            //console.log(`The tree object with the key: "${key}" does not have a 'name' property, therefore it isn't
            //contained in the 'names' property of this TreeWrapper.`);
        } else if (this.names[this.tree[key].name] == null) {
            console.log(`The 'names' property of this TreeWrapper is missing an entry for tree object with key: "${key}",
            name: "${this.tree[key].name}".`); 
        }
        return true;
    },

    ///** TODO: add unit tests
    // * 
    // */
    //getKeyWithName(name) {
    //    const key = this.names[name];
    //    if (key == null) {
    //        console.log(`The name "${name}" does not exist in this TreeWrapper.names`);
    //        return null;
    //    }
    //    return key;
    //},

    /** 
     * It would be nice if createTreeWrapper() could accept another treeWrapper. That way instead of rebuilding a new
     * names object for each treeWrapper I could (maybe) reuse the pre-existing names object in the TreeWrapper argument?
     * It's a micro-optimization I think.
     */
    buildNames() {
        const nameKeyMap = {};
        Object.keys(this.tree).forEach(key => {
            const name = this.tree[key].name;
            if (name != null) {
                keyIsStringAndValidNumber(key);
                nameKeyMap[name] = key;
            }
        });
        return nameKeyMap;
    }
};

/** Return a TreeWrapper object that has: a 'tree' property, a 'names' property, and
 * lots of methods.
 * 
 * The 'tree' property is a reference to the tree parameter. It is identical in memory to the tree argument.
 * The 'names' property is a map from names to keys in the 'tree' property. It is an object.
 * The 'names' property allows faster retrieval of to/from/parent nodes when building the svg data.
 * Without this name-key map, we would have to parse the tree to find every to/from/parent node. This would be slow.
 * @param {Object} tree - contains tree objects, which are simply keys paired with objects 
 * that contain data.
 * @return {TreeWrapper} treeWrapper - a wrapper around the tree argument.  
 */
function createTreeWrapper(tree = {}) {
    if (typeof(tree) !== "object" || Array.isArray(tree)) {
        throw new Error("tree argument must be a JavaScript object");
    }
    const treeWrapper = Object.create(treeWrapperPrototype);
    treeWrapper.tree = tree;
    treeWrapper.names = treeWrapper.buildNames();
    return treeWrapper;
}

//**************************************************
// TreeWrapper-to-SVG interface
//**************************************************

 const deletableSvgDataPrototype = {

    /* Public interface methods */

    /**
     * Use the ids inside of the deletableSvgData instance to remove elements from the document viewport.
     */
    deleteFrom(viewport) {
        this.ids.forEach(id => {
            let e = document.getElementById(id);
            if (e != null) {
                viewport.removeChild(document.getElementById(id));
            }
            // could log a console message if it would be helpful
        });
    }
}

/** 
 * TODO: should take a treeWrapper, add unit tests
 * 
 * @param {Object} tree - A tree of all tree objects that 1) were already deleted from the tree and 2) should also
 * be deleted from the svg.
 * @return {Object} DeletableSvgData - Has a method for deleting from a viewport.
 */
function createDeletableSvgData(tree) {
    const obj = Object.create(deletableSvgDataPrototype);
    obj.ids = []
    Object.keys(tree).forEach(key => {
        if (isParentChildNode(tree[key])) {
            obj.ids.push(key);
            const parentChildLineId = `${tree[key].parent}_${tree[key].name}`
            obj.ids.push(parentChildLineId);
        } else {
            obj.ids.push(key);
        }
        /*
        else if (isParentlessNode(tree[key])) {
            obj.ids.push(key);
        } else if (isLine(tree[key])) {
            obj.ids.push(key)
        } else if (isConfigurationNode(tree[key])) {

        } else { 
            //console.log(`Failed to delete type: "${tree[key].object}", name: "${tree[key].name}", key: ${key}"`);
            //throw new Error(`tree key: ${key}, with data: ${tree[key]} is not a parent-child node, a parentless node, or a line.`); 
        }
        */
    });
    return obj;
}

/** TOOD: add unit tests
 * 
 */
const addableSvgDataPrototype = {

    /* "Public" interface methods */

    /** 
     * TODO: add unit tests
     * Add the svgData to the viewport when the feeder is initially built. The lines must be drawn before
     * circles to be underneath the circles. 
     */
    addTo(viewport) {
        this.lines.forEach(line => {
            viewport.appendChild(line);
        });
        this.circles.forEach(circle => {
            viewport.appendChild(circle);
        });
    },

    /**
     *  TODO: add unit tests
     */
    redrawTo(viewport) {
        this.lines.forEach(line => {
            //viewport.removeChild(document.getElementById(line.id).parentNode.childNodes);
            document.getElementById(line.id).remove();
        });
        this.circles.forEach(circle => {
            //viewport.removeChild(document.getElementById(circle.id).parent);
            document.getElementById(circle.id).remove();
        });
        this.lines.forEach(line => {
            viewport.appendChild(line);
        });
        this.circles.forEach(circle => {
            viewport.appendChild(circle);
        });
        scaleTo(scaleLevel);
    },

    /* "Private" helper methods */

    /** 
     * TOOD: add unit tests
     */
    addLine(key) {
        const nodes = Object.values(this.treeWrapper.getNodeEndsOf(key).tree);
        if (nodes.length < 2) {
            console.log(`Could not find the nodes on either end of a line with key: "${key}". Line was not drawn`);
            /* TODO: Draw the line anyway with some kind of default values so the user can see there's a broken line?
            I could have a second viewport that is contained in a table with all the broken lines and circles! Neat!
            */
            return;
        }
        const tree = this.treeWrapper.tree;
        let line;
        if (tree[key].from === nodes[0].name) {
            line = createSvgLine(nodes[0], nodes[1], key, tree[key]);
        } else {
            line = createSvgLine(nodes[1], nodes[0], key, tree[key]);
        }
        this.lines.push(line);
    },

    /** 
     * TODO: add unit tests
     */
    addParentChildLine(key) {
        const parent = Object.values(this.treeWrapper.getParentOf(key).tree)[0];
        if (parent == null) {
            console.log(`Could not draw the parent-child line for child tree object with key: "${key}"`);
            return;
        }
        const parentChildLine = createSvgLine(parent, this.treeWrapper.tree[key]);
        this.lines.push(parentChildLine);
    },

    /**
     * TODO: add unit tests
     */
    addConfigurationNode(key) {
        const node = this.treeWrapper.tree[key];
        node.longitude = 0;
        node.latitude = 0;
        const circle = createSvgCircle(key, node);
        this.circles.push(circle);
    },

    /**
     * TODO: add unit tests
     */
    addParentChildNode(key, obj) {
        /* There are some weird config nodes that have "parent" but no "longitude" and "latitude" properties and the
        interface breaks if I don't do this.
        */
        if (obj.longitude == null || obj.latitude == null) {
            this.addConfigurationNode(key);
        } else {
            const circle = createSvgCircle(key, obj);
            this.circles.push(circle);
        }
        this.addParentChildLine(key);
    }
};

/** 
 * Return an AddableSvgData instance.
 * 
 * An AddableSvgData instance contains an array of circles and an array of lines that can be redrawn or added
 * to the svg. It also has methods for adding to the svg and redrawing to it.
 * 
 * @param {TreeWrapper} treeWrapper - contains all tree objects that should be added to the svg.
 * @return {AddableSvgData} - the svg data to add.
 */
function createAddableSvgData(treeWrapper) {
    if (Object.getPrototypeOf(treeWrapper) !== treeWrapperPrototype) {
        throw new Error("treeWrapper argument must be an instance of TreeWrapper");
    }
    const obj = Object.create(addableSvgDataPrototype);
    obj.treeWrapper = treeWrapper;
    obj.lines = [];
    obj.circles = [];
    const tree = treeWrapper.tree;
    Object.keys(tree).forEach(key => {
        if (isParentChildNode(tree[key])) {
            obj.addParentChildNode(key, tree[key]);
        } else if (isParentlessNode(tree[key])) {
            const circle = createSvgCircle(key, tree[key]);
            obj.circles.push(circle);
        } else if (isLine(tree[key])) {
            obj.addLine(key);
        } else if (isConfigurationNode(tree[key])) {
            obj.addConfigurationNode(key);
        } else { 
            console.log(`Failed to draw type: "${tree[key].object}", name: "${tree[key].name}", key: "${key}"`);
        }
    });
    return obj;
}

/* Utility methods */

function isParentlessNode(obj) {
    return obj.parent == null && obj.from == null && obj.to == null &&
    obj.latitude != null && obj.longitude != null;
}

function isParentChildNode(obj) {
    //return obj.parent != null && obj.latitude != null && obj.longitude != null;
    return obj.parent != null;
}

// add unit tests
function isLine(obj) {
    return obj.from != null && obj.to != null;
}

// add unit tests
function isConfigurationNode(obj) {
    //return obj.longitude == null && obj.latitude == null && obj.from == null && obj.to == null && obj.parent == null;
    return obj.longitude == null && obj.latitude == null && obj.from == null && obj.to == null;
}

/** 
 * TODO: add unit tests
 * @return {Object} SvgCircle - A fully configured svg circle.
 */
function createSvgCircle(key, {longitude, latitude, object}, {r = 2, strokeWidth = 0.5} = {}) {
    keyIsStringAndValidNumber(key);
    if (longitude == null || latitude == null || object == null) {
        //console.log(`For circle with tree key: "${key}", longitude was: "${longitude}",
        //latitude was: "${latitude}", object was: "${object}"`)
    }
	const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
	circle.setAttribute('id', key);
	circle.setAttribute('cx', longitude);
	circle.setAttribute('cy', latitude);
	circle.setAttribute('class', object);
	circle.setAttribute('r', r);
    circle.setAttribute('stroke-width', strokeWidth);
    return circle;
}
/** 
 * TODO: add unit tests
 * @return {Object} SvgLine - A fully configured svg line.
 */
function createSvgLine(sourceNode, targetNode, key, thisObject) {
    const svgLine = document.createElementNS('http://www.w3.org/2000/svg', 'line'); 
    if (sourceNode.longitude == null || sourceNode.latitude == null || targetNode.longitude == null ||
    targetNode.latitude == null) {
        console.log(`For line with tree key: "${key}", sourceNode.name was: "${sourceNode.name}",
        sourceNode.longitude was: "${sourceNode.longitude}", sourceNode.latitude was: "${sourceNode.latitude}",
        targetNode.name was: "${targetNode.name}", targetNode.longitude was: "${targetNode.longitude}",
        targetNode.latitude was: "${targetNode.latitude}"`)
        //throw new Error(`For line with tree key: "${key}", sourceNode.longitude was: "${sourceNode.longitude}",
        //sourceNode.latitude was: "${sourceNode.latitude}", targetNode.longitude was: "${targetNode.longitude}",
        //targetNode.latitudw was: "${targetNode.latitude}"`)
    }
    svgLine.setAttribute("x1", sourceNode.longitude); 
    svgLine.setAttribute("y1", sourceNode.latitude); 
    svgLine.setAttribute("x2", targetNode.longitude);
    svgLine.setAttribute("y2", targetNode.latitude);
    if (key === undefined && thisObject === undefined) {
        // key and thisObject weren't included, so this line doesn't represent a real object in the tree, so it's a parent-child line.
        svgLine.setAttribute("id", `${sourceNode.name}_${targetNode.name}`);
        svgLine.setAttribute("class", "parentChild");
        svgLine.setAttribute("stroke-width", 0.25);
        return svgLine;
    } else if (key && thisObject) {
        keyIsStringAndValidNumber(key);
        svgLine.setAttribute("id", key);
        const phaseCount = countPhases(thisObject.phases).toString();
        const domClass = `${thisObject.object} p${phaseCount}`;
        svgLine.setAttribute("class", domClass);
        svgLine.setAttribute("stroke-width", phaseCount);
        return svgLine;
    }
    throw new Error("key and thisObject arguments must be passed together or not at all");
}

//**************************************************
// SVG interface
//**************************************************


/** What kind of event am I listening for? Just clicks? What about the drag box I thought about?
 * svg-pan-zoom handles drag events. So if the user held alt THEN dragged, then I could make a drag box.
 * 
 */
function svgContainerHandler(event) {
    //event.target.id
    //console.log(event.altKey);
}
//**************************************************
// TreeObject interface
//**************************************************

const treeObjectPrototype = {

    /* "Public" interface methods.*/

    /** 
     * TODO: add unit tests
     */
    //update(map) {
    //    this.data = deepCopy(map);
    //},

    /* "Private" helper methods */
};

/**
 * Return a key value which has not been used in tree.
 * @return {string} key
 */
function getNewTreeKey(tree) { 
	let nextKey = Object.keys(tree).length;
	while(tree.hasOwnProperty(nextKey.toString())) {
		nextKey += 1;
	}
	return nextKey.toString();
}

// Fix this function. Some lines have CLOSED instead of ABCN or something.
function countPhases(p) {
	// Return the number of phases a line has.
	//return p.length
	let total = 0
	if (p.search('A') > -1) {total++}
	if (p.search('B') > -1) {total++}
	if (p.search('C') > -1) {total++}
	return total;
}

/** Return a TreeObject.
 * 
 * A TreeObject (which is not to be confused with a more general "tree object") is either:
 * 1) a copy of a component that is in the process of being added to the tree, OR
 * 2) a copy of an existing object in the tree.
 * 
 * @param {(string|Object)} input - either a key OR a map of properties to create this TreeObject.
 * @param {TreeWrapper} tree - the treeWrapper from which to create this TreeObject.
 * return {TreeObject} - Either a new component that does not exist in the tree, or a copy of an existing tree object 
 * inside of the treeWrapper argument.
 */
function createTreeObject(input, treeWrapper) {
    if (Object.getPrototypeOf(treeWrapper) !== treeWrapperPrototype) {
        throw new Error("treeWrapper argument must be an instance of TreeWrapper");
    }
    //const treeObject = Object.create(treeObjectPrototype);
    const treeObject = {};
    if (typeof(input) === "string") {
        keyIsStringAndValidNumber(input);
        const obj = treeWrapper.tree[input];
        if (obj != null) {
            treeObject.key = input;
            treeObject.data = deepCopy(obj);
            return treeObject;
        }
        throw new Error(`The passed key argument: "${input}" to create the TreeObject does not exist in the treeWrapper.tree.`);
    } else if (typeof input === "object" && !Array.isArray(input)) {
        treeObject.key = getNewTreeKey(treeWrapper.tree);
        treeObject.data = deepCopy(input);
        //treeObject.update(input);
        return treeObject;
    } 
    throw new Error("Input argument must be a string or an object.");
}

/** 
 * Return an object that is a copy of the argument object.
 * JSON.stringify will not copy a property of an object with an undefined value.
 * @param {Object} oldObject - the object to copy.
 * @return {Object} - a copy of the object argument.
 */
function deepCopy(oldObject) {
    if (Object.getPrototypeOf(oldObject) !== Object.prototype) {
        throw new Error("This function cannot be used to copy objects created with a constructor function.");
    }
    const properties = Object.getOwnPropertyNames(oldObject);
    const keys = Object.keys(oldObject);
    for (let key of keys) {
        if (typeof(oldObject[key]) === "function") {
            throw new Error("This function cannot be used to copy objects with methods.");
        } else if (oldObject[key] === undefined) {
            throw new Error("JSON.stringify silently ignores properties with undefined values, so this function cannot handle undefined values.");
        }
    }
    return JSON.parse(JSON.stringify(oldObject));
}

/**  
 * TODO: add unit tests
 */
function keyIsStringAndValidNumber(key) {
    if (typeof(key) !== "string") {
        throw new Error("key argument must be a string.");
    }
    if (isNaN(parseFloat(key))) {
        throw new Error("key argument must be a string that can be parsed to a valid number");
    }
}

//**************************************************
// Table interface 
//**************************************************

/* These are names of properties in most objects in writeFeeder.tree that cannot be deleted from objects. 
They are a mix of properties that can be found in objects with a parent, objects without a parent,
and objects that represent lines. See my notes for reasoning behind designating these properties as non-deleteable.
This global array is a hard-coded data-dependency, but it's necessary at this point because the raw data does not define
whether or not a property is key to identifying an object in the svg graph. Maybe these hard-coded dependencies could be moved
so some other configuration file, like the components?
*/
const nonDeletableProperties = ["name", "object", "from", "to", "latitude", "longitude", "parent", "configuration"];
/* If these properties were to be modified for a given writeFeeder.tree object, it would require significantly modifying the 
other objects.  These properties ARE technically modifiable, but allowing the user to change them would require more work 
than I think is worth it. It is easier just to create a new node.
We can remove or add properteis to this array as the needs of the interface change.
*/
const nonModifiableProperties = ["name", "object", "from", "to", "parent"];

const titleProperties = ["object"];

/** Return a fully formed html table that can be attached to the DOM.
 * 
 */
function createTable(ids, tWrapper) {
    if (!Array.isArray(ids)) {
        throw new Error("ids argument must be an array");
    }
    if (ids.length === 1) {
        return createDescriptionTable(ids[0], tWrapper);
    } 
}

/**
 * TODO: add unit tests
 * 
 * The form element is only used to take advantage of the "required" form validation functionality that is native to the
 * browser.
 */
function createDescriptionTable(id, tWrapper) {
    const form = document.createElement("form");
    const table = document.createElement("table");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody");
    const buttonRow = document.createElement("tr");
    const buttonCell = document.createElement("td");
    form.append(table);
    table.append(tHead);
    table.append(tBody);
    tBody.append(buttonRow);
    buttonRow.append(buttonCell);
    table.classList.add("descriptionTable");
    buttonRow.classList.add("buttonRow");
    buttonCell.setAttribute("colspan", "3");

    // TODO: Don't allow longitude and latitude to be editted for lines!
    const tObject = createTreeObject(id, tWrapper);
    if (!isLine(tObject.data)) {
        buttonCell.append(createButton({action: "move", tObject: tObject, tWrapper: tWrapper, tableBody: tBody}).self);
    } 
    buttonCell.append(createButton({action: "delete", tObject: tObject, tWrapper: tWrapper, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "add", tObject: tObject, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "save"}).self);

    form.addEventListener("submit", function(event) {
        event.preventDefault();
        const svg = createAddableSvgData(tWrapper.insert(tObject));
        svg.redrawTo(gViewport);
        alert("Object saved");
        // TODO: turn all key inputs into plain text upon clicking save (would look nice)
    });

    Object.keys(tObject.data).forEach(key => {
        let row;
        if (titleProperties.includes(key)) {
            row = createRow({key: key, map: tObject.data});
            Array.from(row.self.children).forEach(td => {
                td.classList.add("tableTitle");
            });
            tHead.append(row.self);
        } else {
            row = createRow({key: key, deletable: true, map: tObject.data});
            tBody.appendChild(row.self);
        }
    });
    return form;
}

const buttonPrototype = {

    /* Private helper methods */

    /**
     * TODO: add unit tests
     * Add a click listener to the svgContainerWrapper which is the direct parent of the svgContainer. The
     * svgContainerWrapper will intercept a click before it reaches the svgContainer and invoke moveNode().
     */
    addMoveListener() {
        const element = document.getElementById("svgContainerWrapper");
        element.setAttribute("style", "cursor: crosshair");
        const that = this;
        element.addEventListener("click", moveNode, true);
        function moveNode(event) {
            event.stopPropagation();
            document.getElementById("svgContainerWrapper").removeEventListener("click", moveNode, true);
            const coords = clickLatLon(event);
            that.tObject.data.longitude = coords.x;
            that.tObject.data.latitude = coords.y;
            const subWrapper = that.tWrapper.insert(that.tObject);
            createAddableSvgData(subWrapper).redrawTo(gViewport);
            element.setAttribute("style", "cursor: default");
            // Update the table with the new coordinates
            Array.from(that.tableBody.getElementsByTagName("input")).forEach(input => {
                if (input.dataset.coordinate === "latitude") {
                    input.value = coords.y;
                } else if (input.dataset.coordinate === "longitude") {
                    input.value = coords.x;
                }
            });
        }
    },

    /**
     * Delete the TreeObject of this button from the TreeWrapper of this button
     */
    deleteObject() {
        let subWrapper;
        try {
            subWrapper = this.tWrapper.delete(this.tObject.key);
            createDeletableSvgData(subWrapper.tree).deleteFrom(gViewport);
        } catch (e) {
            if (confirm(e + " Alternatively, do you wish to delete this node and all of its immediately connected objects?")) {
                subWrapper = this.tWrapper.recursiveDelete(this.tObject.key);
                createDeletableSvgData(subWrapper.tree).deleteFrom(gViewport);
            }
        }
    },
}

/**
 * TODO: add unit tests
 */
function createButton({action, tableBody=null, tObject=null, tWrapper=null}) {
    validateButtonArguments(arguments[0]);
    const button = Object.create(buttonPrototype);
    button.self = document.createElement("button");
    button.self.textContent = action;
    button.self.classList.add("modalButton", "tableButton");
    button.tObject = tObject;
    button.tWrapper = tWrapper;
    button.tableBody = tableBody;
    button.self.type = "button";
    switch (action) {
        case "move":
            button.self.addEventListener("click", function() {
                button.addMoveListener();
            });
            break;
        case "delete":
            button.self.classList.add("deleteButton");
            button.self.addEventListener("click", function() {
                button.deleteObject();                
                document.getElementById("tableInsert").removeChild(tableBody.parentElement.parentElement);
            });
            break;
        case "add":
            button.self.addEventListener("click", function() {
                const row = createRow({key: "", deletable: true, map: tObject.data});
                tableBody.append(row.self);
            });
            break;
        case "save":
            button.self.type = "submit";
            break;
        default:
            throw new Error("The action argument must be a string that matches an existing action for this button.");
    }
    return button;
}

/**
 * TODO: add unit tests
 */
function validateButtonArguments(args) {
    if (args.action === "move") {
        if (args.tObject == null || args.tWrapper == null || args.tableBody == null) {
            throw new Error(`A button with a "${args.action}" action must have non-null tObject, tWrapper, and tableBody arguments`);
        }
    } else if (args.action === "delete") {
        if (args.tObject == null || args.tWrapper == null || args.tableBody == null) {
            throw new Error(`A button with a "delete" action must have non-null tObject, tWrapper, and tableBody arguments`);
        }
    } else if (args.action === "add") {
        if (args.tObject == null || args.tableBody == null) {
            throw new Error(`A button with an "add" action must have non-null tObject and tableBody arguments`);
        }
    } else if (args.action !== "save") {
        throw new Error(`The action argument must match an existing action`);
    }
}

const rowPrototype = {

    /* Private helper methods */

    /**
     * Return false if the key already exists in the map, otherwise return true.
     * @param {string} key - the incoming key that the user wants to write into the map belonging to this Row.
     */
    validateNewKey(key) {
        if (this.map[key] !== undefined) {
            return false;
        }
        return true;
    },
    /**
     * Update a key in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new key that should be written to the map, if it is valid.
     */
    updateMapKey(input) {
        const newKey = input.value.trim();;
        if (this.validateNewKey(newKey)) {
            this.map[newKey] = this.map[this.key] != null ? this.map[this.key] : "";
            delete this.map[this.key];
            this.key = newKey;
        } else {
            alert(`The key "${newKey}" already exists in this object. Please enter a unique key.`);
            input.value = this.key;
        } 
    },
    /**
     * Return an HTMLTableCellElement.
     * @return {HTMLTableCellElement}
     */
    getKeyElement() {
        const td = document.createElement("td");
        if (this.key === "") {
            const input = document.createElement("input");
            input.classList.add("modalInput");
            td.appendChild(input);
            const that = this;

            input.required = true;

            input.addEventListener("change", function() {
                that.updateMapKey(this);
                //this.required = true;
            });
        } else if (this.key != null) {
            td.textContent = this.key;
        } 
        return td;
    },

    /** 
     * Return true if the value is valid for the Row (based on the key of that Row), otherwise return false.
     * @param {string} value - a value for a corresponding key that should be validated based on the key.
     * @return {boolean}
     */
    validateNewValue(value) {
        if (this.key === "longitude" || this.key === "latitude") {
            return !isNaN(parseFloat(value));
        }
        return true;
    },

    /** 
     * Update a value in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new value that should be written to the map, if the value is valid.
     */
    updateMapValue(input) {
        const newValue = input.value.trim();
        if (this.validateNewValue(newValue)) {
            this.map[this.key] = newValue;
        } else {
            alert(`The value "${newValue}" is invalid for for the key "${this.key}" in the table.`);
            input.value = this.map[this.key];
        }
    },
    /** 
     * Return an HTMLTableRowElement.
     * @param {string} value - the value to display within this HTMLTableRowElement.
     * @param {Array} nonModifiableProperties - a hard-coded array of properties that the user shouldn't be able to modify.
     * @return {HTMLTableRowElement}
     */
    getValueElement(value, nonModifiableProperties) {
        const td = document.createElement("td");
        if (value == null) {
            return td;
        } else if (nonModifiableProperties.includes(this.key)) {
            td.textContent = value;
        } else {
            const input = document.createElement("input");
            if (this.key === "longitude") {
                input.dataset.coordinate = "longitude";
            } else if (this.key === "latitude") {
                input.dataset.coordinate = "latitude";
            }
            input.classList.add("modalInput");
            td.appendChild(input);
            const that = this;
            input.addEventListener("change", function() {
                that.updateMapValue(this);
            });
            input.value = value;
        } 
        return td;
    },
    /** 
     * TODO: add unit tests
     * Return an HTMLTableRowElement.
     * @param {boolean} deletable - whether or not the returned <td> should have a delete button element child.
     * @param {Array} nonDeletableProperties - a hard-coded array of properties that the user should not be able
     * to delete from a TreeObject.
     * @return {HTMLTableRowElement}
     */
    getDeleteElement(deletable, nonDeletableProperties) {
        const td = document.createElement("td");
        if (deletable === true && !nonDeletableProperties.includes(this.key)) {
            const btn = document.createElement("button");
            btn.innerHTML = "&#9587;"
            btn.setAttribute("class", "modalButton deleteButton"); 
            td.appendChild(btn);
            const that = this;
            btn.addEventListener("click", function() {
                that.delete();
            });
        } 
        return td;
    },

    /**
     *  Delete the row from the table and the map.
     */
    delete() {
        delete this.map[this.key];
        this.self.parentElement.removeChild(this.self);
    },

    /**
     * TODO: add unit tests
     */
    updateInput() {
        //need a direct reference to the input of the row for convenience.
    }
}

/** 
 * Return a Row that can be appended to a table.
 * 
 * @param {string} key - the key of a property in the map object.
 * @param {boolean} deletable - whether or not the row should have a delete button.
 * @param {Object} map - an object that contains the data being manipulated by all of the rows. 
 * @return {Row} - A wrapper object around the HTMLTableRowElement.
 */ 
function createRow({key=null, deletable=false, map=null} = {}) {
    if (map == null && key != null) {
        throw new Error("A key argument cannot be passed if a map argument is not passed");
    }
    if (map != null && map[key] === undefined && key !== "") {
        throw new Error("A row should be instantiated with a key field that exists in the map argument");
    }
    const obj = Object.create(rowPrototype);
    obj.key = key;
    obj.map = map;
    obj.self = document.createElement("tr");
    obj.self.append(obj.getDeleteElement(deletable, nonDeletableProperties));
    obj.self.append(obj.getKeyElement());
    const value = map == null ? null : key === "" ? "" : map[key];
    obj.self.append(obj.getValueElement(value, nonModifiableProperties));
    return obj;
}

//**************************************************
// Initialization
//**************************************************


//setTimeout(main,100)
(() => {
    //buildFeeder();
    //const t0 = performance.now();

    document.getElementById('loadingMessage').style.display = 'none'
    createViewport(writeFeeder.tree, document.getElementById("svgContainer"));
    gViewport = document.getElementsByClassName('svg-pan-zoom_viewport')[0];
    gTreeWrapper = createTreeWrapper(writeFeeder.tree);
    const addSvgData = createAddableSvgData(gTreeWrapper);
    addSvgData.addTo(gViewport);

    document.getElementById("svgContainer").addEventListener("click", function(event) {
        svgClick(event);
    });

    /*
    attachFeederList(document.getElementById("publicFeederList"), publicFeeders, "public");
    attachFeederList(document.getElementById("userFeederList"), userFeeders, thisOwner);
    fillObjectMenu(components);
    */
    
    /* 
    const t1 = performance.now();
    const time = t1 - t0;
    console.log(`Tree rendering time was ${time} ms`);
    */
    
    /*
    setTimeout(function() {
        const deleteSvgData = createDeletableSvgData(gTreeWrapper.tree);
        deleteSvgData.deleteFrom(viewport);
    }, 2000);
    */
})();
</script>
<!--<script type='text/javascript' src='/static/distDataValidation.js'></script>-->
{% if spec %}{{ spec | safe }}{% endif %}