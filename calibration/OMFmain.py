# About the inputs:
import sys, re, os
sys.path.append('..')
import milToGridlab
import Milsoft_GridLAB_D_Feeder_Generation
import calibrateFeeder
import processSCADA #TODO: write this module
import feeder
import AddTapeObjects
#import writeFeederConfig #TODO: future work (after June 1 deadline)
import four_node_commercial # feeder dictionary just for testing
import four_node_residential # feeder dictionary just for testing

# MilSoft model ( milsoft = [stdPath, seqPath])
# Case Flag
# Feeder Info (region, ratings, etc) TBD
# SCADA Data
# feeder configuration file (user may input feeder configuration file as created by a previous calibration attempt on this feeder)
# feeder calibration file (user may input calibration file as created by a previous calibration attempt on this feeder)
# user_flag_to_calibrate (user may set to 0 to indicate they don't want to calibrate, just want general popualted model)

def createFeederDirectory(feederID):
	# check that this feederID is unique
	# create folder with all the fixin's for this model to be populated and/or calibrated and ran in GLD
	# TODO: directory needs to include subdirectory 'winners' for storing the best .glms from each calibration round
	# TODO: anything with suffix 'glm' might be deleted during calibration since we cleanup unecessary file between rounds. Put schedules, other .glms, etc into a subdirectory if we don't want them deleted. 
	# TODO: If using .csv files for recorder output (as opposed to mysql), add subdirectory 'csv_output' ( or go into makeGLM.py and change the file path -- that's where it's defined. Also would have to change it in gleanMetrics.py where each file is opened.)
	#directory = 'C:\\Users\\d3y051\\Documents\\NRECA_feeder_calibration_2-2013\\Calibration\\github\\omf\\calibration\\Feeder_Test'
	#directory = 'C:\\Users\\d3y051\\Desktop\\calibration\\calibration\\Feeder_Test'
	currentDirectory = os.getcwd()
	workingDirectory = os.path.join(currentDirectory,'workingDir')
	if not os.path.isdir(workingDirectory):
		os.mkdir(workingDirectory)
		os.mkdir(os.path.join(workingDirectory, 'csv_output'))
		os.mkdir(os.path.join(workingDirectory, 'winners'))
	return workingDirectory
	
def OMFmain(milsoft, feeder_info, scada, case_flag, feeder_config, calibration_config, model_name='Feeder', user_flag_to_calibrate=1):

	if milsoft is None:
		print ("Please input a model to convert!")
		# error
		return
	else:
		internal_flag_to_calibrate = 0
		if feeder_config is None:
			if feeder_info is None:
				pass  # We'll use defaults.
			else:
				# use whatever feeder_info is to write a new feeder_config file that will populate Configuration.py appropriatly.
				#feeder_config = writeFeederConfig(feeder_info)  #TODO: This function is in the future. 
				pass
		else:
			pass
			# We should check that this file is a valid feeder_config file for use inside Configuration.py. This is important if it's coming from the user incase they made change to the file that aren't compatible with our format. 
		if calibration_config is None:
			if scada is None:
				pass  # Well, we can't do any calibration but we can still pump out a populated model by using defaults.
			else:
				internal_flag_to_calibrate = 1
				days, SCADA = processSCADA.getValues(scada)
		else:
			pass
			# We'll check that this file is a valid calibration_config file for use inside Configuration.py. This is important if it's coming from the user incase they made change to the file that aren't compatible with our format.
			# This might be where we can find out if this is the final calibration file or if we're starting mid-calibration. To do this maybe:
			#  a. We could have another input to the script that is a flag indicating "yes, this is calibrated" or "no, this isn't finished yet".
			#  b. We could just run the script using this calbiration_config file and let the script determine whether it's calibrated -- this might take too long though. 
			#  c. There could be a flag within the calibration_config file that was set when it was previously determined to be the "best".
		
		# Create base .glm dictionary from milsoft model 
	
		# stdPath, seqPath = milsoft[0], milsoft[1]
		# outGlm = milToGridlab.convert(stdPath,seqPath)
		# directory = createFeederDirectory(milsoft)
		
		# testing with pre-made dictionary
		outGLM = milsoft
		directory = createFeederDirectory(None)
		
		# write base .glm to file (save as .txt so that it isn't run when batch file executed)
		basefile = open(directory+'/'+model_name+'_base_glm.txt','w')
		basefile.write('\\\\ Base feeder model generated by milToGridlab.py.\n')
		basefile.write(feeder.sortedWrite(outGLM))
		basefile.close()
		
		if internal_flag_to_calibrate == 1 and user_flag_to_calibrate == 1:  # The user must want to calibrate (user_flag_to_calibrate = 1) and we must have SCADA input (internal_flag_to_calibrate = 1).
			# Send base .glm dictionary to calibration function
			final_calib_file, final_dict, last_key = calibrateFeeder.calibrateFeeder(outGLM, days, SCADA, case_flag,feeder_config, calibration_config, directory)
		else:
			# Populate the feeder. 
			print ("Either the user selected not to calibrate this feeder, the SCADA was not input, or this feeder has already been calibrated.")
			final_dict, last_key = Milsoft_GridLAB_D_Feeder_Generation.GLD_Feeder(outGLM,case_flag,directory,calibration_config,feeder_config)
		#AddTapeObjects
		#filename = 'test_feeder'
		if final_dict is not None:
			#AddTapeObjects.add_recorders(final_dict,None,last_key,None,1,0,filename,None,0,0)
			dict_with_recorders, last_key = AddTapeObjects.add_recorders(final_dict,case_flag,0,1,model_name,last_key)
		
			#TODO: Turn final_dict into a .glm and return it to the user. 
			glmstring = feeder.sortedWrite(dict_with_recorders)
			
			if final_calib_file is not None:
				#calib = re.sub('.txt$','',final_calib_file)
				m = re.match(r'^Calib_ID(\d*)_Config_ID(\d*)',final_calib_file)
				if m is not None:
					calib = m.group()
				else:
					calib = 'unrecognized'
			else:
				calib = 'using_default_configuration'
				
			inFile = open(directory+'/'+model_name+'_'+calib+'_final.glm', 'w')
			inFile.write(glmstring)
			inFile.close()
			print ("Final *.glm file is " + directory + '/' + model_name + '_' + calib + '_final.glm')
			print ("Calibration file is " + directory + '/' + final_calib_file)
		else:
			pass
		
def main():
	# test run with pre-made dictionary simuating output from milToGridlab.py. All other parameters are None. Note that SCADA input just needs to be not None for this test-- the values are imput directily into processSCADA.py rather than actually being taken from a file right now.
	with open('../uploads/ACEC-FRIENDSHIP.std','r') as stdFile, open('../uploads/ACEC.seq','r') as seqFile:
		milsoft,x,y = milToGridlab.convert(stdFile.read(), seqFile.read())
	
	model_name = 'testing_model_IEEE13'
	feeder_info = None # place holder for future feeder information input from the user. 
	scada = 'make_believe_scada_file.xlsx' # place holder for file with scada that will be processed for certain values. 
	case_flag = -1 # base case, do not put None
	feeder_config = None # only used in the case that the user already has a feeder configuration .py file that works (i.e. they've calibrated feeder  or at least part of it)
	calibration_config = None # same as for feeder_config
	
	OMFmain(milsoft, feeder_info, scada, case_flag, feeder_config, calibration_config, model_name, 1)

if __name__ ==  '__main__':
	main()