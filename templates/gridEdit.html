<head>
  <script type='text/javascript' src='../static/libs/d3.v2.min.js'></script>
  <script type='text/javascript' src='../static/omf.js'></script>
  <link rel='stylesheet' href='../static/omf.css'>
  <style>
  * {border:0px;margin:0px;padding:0px;}
  div#toolbar { 
    padding: 10px;
    height: 25px;
    border-width: 0px 0px 1px 0px;
    border-color:black;
    border-style:solid;
    text-align: center;
    vertical-align: center;
    background-color:black; /* for browsers that can't do gradients */
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#B0B0B0', endColorstr='#696969 '); /* for IE */
    background: -webkit-gradient(linear, left top, left bottom, from(#B0B0B0), to(#696969)); /* for webkit browsers */
    background: -moz-linear-gradient(top,  #B0B0B0,  #696969); /* for firefox 3.6+ */ }
  #selected {border:1px solid black; border-bottom:0px;position:absolute;top:90pt;left:4pt;width:20%;}
  #selected th {background:black; color:white;}
  #selected td {padding:5px; border-bottom:1px solid black; background:white; color:black}
  .leftToolbar {float:left;margin-right:5px;}
  .rightToolbar {float:right; margin-left:5px;}
  input {min-width: 100px}
  /* Start graph elements. */
  circle.node {fill:gray; stroke: #fff;stroke-width: 1.5px;}
  line.link {stroke: #999;stroke-opacity: .6;}
  .nodetext {pointer-events: none; font: 10px; }
  circle.selected {stroke:black; stroke-width: 2px; stroke-opacity: 1.0; }
  circle.highlighted {stroke: #555; stroke-width: 1.5px; stroke-opacity: .8; }
  circle.house {fill:#3366FF;}
  circle.ZIPload, circle.waterheater {fill:#66CCFF;}
  circle.triplex_meter {fill:#FF6600;}
  circle.triplex_node {fill:#660000;}
  circle.gridNode {fill:#CC0000;}
  </style>
</head>
<body>
<div id='title'>
  <div id='logoBox'><a href='/'>▦</a></div>
  <!--Title:-->Grid Editor: {{model_id}}
</div>
<div id='toolbar'>
  <div class='buttonGroup leftToolbar'>
    <button id='butter' class='pill' onclick='dropPill(this, "Add")'>Add ▾</button>
    <ul class='menu'>
      <li><a href='javascript:newObject({_type:"node",_phases:"",_nominal_voltage:0})'>Node</a></li>
      <li><a href='javascript:newObject({_type:"load",_nominal_voltage:0,_phases:"",_constant_power_A:"",_load_class:""})'>Load</a></li>
      <li><a href='javascript:newObject({_type:"transformer",_phases:"",_nominal_voltage:0})'>Transformer</a></li>
    </ul>
  </div>
  <div class='buttonGroup leftToolbar'>
    <button class='pill' onclick='dropPill(this, "Zoom")'>Zoom ▾</button>
    <ul class='menu'>
      <li><a href='javascript:zoomToFit()'>Zoom to Fit</a></li>
    </ul>
  </div>
  <div class='buttonGroup rightToolbar'>
    <button class='pill' onclick='dropPill(this, "Grid")'>Grid ▾</button>
    <ul class='menu right'>
      <li><a href='javascript:saveModel()'>Save</a></li>
      <li><a href='javascript:history.back()'>Cancel</a></li>
    </ul>
  </div>
</div>
<table id='selected'>
  <thead>
    <tr>
      <th colspan='2'>Selected Component</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
<div id='chart' style='background:white'></div>
<script>
feeder = '{{model_id}}'

var w = document.width,
    // HACK: subtract off the toolbar and titlebar heights.
    h = document.height - 112,
    tree;

var name2nodeIndex = {}

var zoomer = d3.behavior.zoom()

var vis = d3.select('#chart')
	.append('svg:svg')
	.attr('width', w)
	.attr('height', h)
	.attr('pointer-events', 'all')
	.append('svg:g')
	.call(zoomer.on('zoom', zoomRedraw))
	.append('svg:g');

// Need this so we have something to zoom on when we aren't over a node:
vis.append('svg:rect')
	.attr('width', w)
	.attr('height', h)
	.attr('fill', 'white');

var force = d3.layout.force()
  .charge(-120)
  .linkDistance(30)
  .size([w, h]);

force.on('tick', function() {
  vis.selectAll('line.link')
    .attr('x1', function(d) { return d.source.x; })
    .attr('y1', function(d) { return d.source.y; })
    .attr('x2', function(d) { return d.target.x; })
    .attr('y2', function(d) { return d.target.y; });

  vis.selectAll('circle.node')
    .attr('cx', function(d) { return d.x; })
    .attr('cy', function(d) { return d.y; });
});

var nodes = force.nodes()
var links = force.links()

function draw() {
  // Go through the first time and set up the nodes with indices:
  for (x in tree) {
    if (tree[x].name != undefined && tree[x].from == undefined) {
      nodeName = tree[x].name
      nodeObject = tree[x].object
      // Hack to make sure electrical nodes are classed differently than graph nodes for coloring purposes:
      if (nodeObject == 'node') nodeObject = 'gridNode'
      nodeIndex = nodes.length
      nodes.push({name:nodeName,treeIndex:parseInt(x),objectType:nodeObject})
      name2nodeIndex[nodeName] = nodeIndex
    }
  }
  // Go through a second time and set up the links:
  for (x in tree) {
    if (tree[x].name != undefined) {
      if (tree[x].from != undefined && tree[x].to != undefined) {
        links.push({source:name2nodeIndex[tree[x].from],target:name2nodeIndex[tree[x].to]})
      } else if (tree[x].parent != undefined) {
        links.push({source:name2nodeIndex[tree[x].name],target:name2nodeIndex[tree[x].parent]})
      }
    }
  }
  // This makes a fancy fade-in.
  vis.style('opacity', 1e-6)
    .transition()
    .duration(1500)
    .style('opacity', 1);
  redraw()
}

function redraw() {
  var link = vis.selectAll('line.link')
    .data(links)
      .enter().append('svg:line')
        .attr('class', 'link')
        .style('stroke-width', function(d) { return Math.sqrt(d.value); })
        .attr('x1', function(d) { return d.source.x; })
        .attr('y1', function(d) { return d.source.y; })
        .attr('x2', function(d) { return d.target.x; })
        .attr('y2', function(d) { return d.target.y; });
  var node = vis.selectAll('circle.node')
    .data(nodes)
      .enter()
        .append('svg:circle')
        .attr('class', function(d) { return 'node ' + d.objectType })
        .attr('id', function(d) { return 'n' + d.treeIndex })
        .on('click', onNodeClick)
        .attr('cx', function(d) { return d.x; })
        .attr('cy', function(d) { return d.y; })
        .attr('r', 10)
        .call(force.drag);
  // TODO: un-comment this to have text labels on _some_ nodes.
  // node.append('svg:title')
  //     .text(function(d) { return d.name; });
  force.start();
};

function zoomRedraw() {
  // Some logging code, if you like:
  // console.log('here', d3.event.translate, d3.event.scale);
  vis.attr('transform',
    'translate(' + d3.event.translate + ')'
    + ' scale(' + d3.event.scale + ')');
}

function classify(d, c, on) {
  svg = d3.select('#chart')
  if(on) {
    // turn off the currently styled one
    svg.select('.' + c).classed(c, false);
    // then, style the new one
    svg.select("#n" + d.treeIndex).classed(c, true);
  }
  else {
    svg.select("#n" + d.treeIndex).classed(c, false);
  }
}

function onNodeClick(d, i) {
  table = gebi('selected')
  // Visually identify the selected node. Note that onNodeClick is a variable that persists as long as the function is in memory.
  classify(d,'selected',true)
  // clear the selected table
  tableClear(table)
  treeData = tree[d.treeIndex]
  for (prop in treeData) {
    row = table.insertRow(-1)
    row.insertCell(0).innerHTML = prop
    row.insertCell(1).innerHTML = treeData[prop]
  }
  row = table.insertRow(-1)
  cell = row.insertCell(0)
  cell.colSpan = 2
  cell.innerHTML = '<button type="button" onclick="editObject(' + i + ')">Edit</button>'
}

function tableClear(table) {
  try {
    while (table.rows.length>1) table.deleteRow(table.rows.length-1)
  }
  catch (err) {
    // Catch: we didn't have any rows.
  }
}

function editObject(index) {
  table = gebi('selected')
  //Make all the boxes editable.
  for (i = 1; i < table.rows.length - 1; i++) {
    cell = table.rows[i].cells[1]
    oldContent = cell.innerHTML
    cell.innerHTML = '<input type="text" name="null" data-old="' + oldContent + '" value="' + oldContent + '"/>'
  }
  //Put the save/cancel buttons in there with the right index.
  table.deleteRow(-1)
  bottomRow = table.insertRow(-1)
  bottomRow.insertCell(0).innerHTML = '<button type="button" onclick="saveEdits(' + index + ')">Save</button>'
  bottomRow.insertCell(1).innerHTML = '<button type="button" onclick="cancelEditing(' + index + ')">Cancel</button>'
}

function saveEdits(index) {
  table = gebi('selected')
  d = tree[nodes[index].treeIndex]
  for (i = 1; i < table.rows.length - 1; i++) {
    name = table.rows[i].cells[0].innerHTML
    cell = table.rows[i].cells[1]
    newValue = cell.childNodes[0].value
    // alert(name + ':' + newValue)
    d[name] = newValue
    cell.innerHTML = newValue
  }
  table.deleteRow(-1)
  row = table.insertRow(-1)
  cell = row.insertCell(0)
  cell.colSpan = 2
  cell.innerHTML = '<button type="button" onclick="editObject(' + index + ')">Edit</button>'
}

function cancelEditing(index) {
  table = gebi('selected')
  for (i = 1; i < table.rows.length - 1; i++) {
    cell = table.rows[i].cells[1]
    old = cell.childNodes[0].getAttribute('data-old')
    cell.innerHTML = old
  }
  table.deleteRow(-1)
  row = table.insertRow(-1)
  cell = row.insertCell(0)
  cell.colSpan = 2
  cell.innerHTML = '<button type="button" onclick="editObject(' + index + ')">Edit</button>'
}

function newObject(objectDict) {
  objectDict.index = nodes.length 
  objectDict.name = objectDict.type + nodes.length 
  nodes.push(objectDict)
  redraw()
}

function zoomToFit() {
  zoomer.translate([0, 0]).scale(1)
  vis.attr('transform', 'translate([0, 0]) scale(1)')
}

function saveModel() {
  sendDict = {tree:JSON.stringify(tree),feederName:feeder}
  post_to_url('/saveFeeder/', sendDict)
}

d3.json('/api/models/{{ model_id }}.json', function(json){tree=json;draw(json)})

</script>
</body>
