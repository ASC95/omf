<head>
  <script type='text/javascript' src='../static/d3.v2.js'></script>
  <script type='text/javascript' src='../static/omf.js'></script>
  <link rel='stylesheet' href='../static/omf.css'>
  <style>
  * {border:0px;margin:0px;padding:0px;}
  div#toolbar { 
    padding:10px;
    height:25px;
    border-width:0px 0px 1px 0px;
    border-color:black;
    border-style:solid;
    text-align:center;
    vertical-align:center;
    background-color:black; /* for browsers that can't do gradients */
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#B0B0B0', endColorstr='#696969 '); /* for IE */
    background: -webkit-gradient(linear, left top, left bottom, from(#B0B0B0), to(#696969)); /* for webkit browsers */
    background: -moz-linear-gradient(top,  #B0B0B0,  #696969); /* for firefox 3.6+ */ }
  div#title p {display:inline-block;}
  input#gridNameEdit {font-size:28pt; line-height: 28pt; text-shadow: 0px 3px 3px #4d4d4d; height: 50px; color:gray; padding:3px; margin-bottom:5px; width:85%;}
  button.smallButton {height:20px; width:20px; display:inline-block; float:right; padding:2px; margin-left:5px;}
  button.deleteButton {width:auto; float:right; background-color: #CC0000; color:white;}
  button.deleteButton:hover {background: #FF0000;}
  #selected {border:1px solid black; border-bottom:0px;position:absolute;top:90pt;left:4pt;width:20%;}
  #selHead tr td {background:black; color:white;}
  #selected td {padding:5px; border-bottom:1px solid black; background:white; color:black}
  .leftToolbar {float:left; margin-right:5px !important;}
  .rightToolbar {float:right; margin-left:5px;}
  input {min-width: 100px}
  /* Start graph elements. */
  .nodetext {pointer-events: none; font: 10px; }
  g.node {fill:gray; stroke: #fff;stroke-width: 1.5px;}
  line.link {stroke: #999;stroke-opacity: .6; stroke-width: 2px;}
  line.parentChild {stroke-dasharray:3,3;}
  line.selected {stroke:black; stroke-width: 4px; stroke-opacity: 1.0;}
  g.selected {stroke:black; stroke-width: 2px; stroke-opacity: 1.0; }
  g.multiselected {stroke:black; stroke-width: 2px; stroke-opacity: 1.0; stroke-dasharray:2,2;}
  g.house {fill:#3366FF;}
  g.load {fill:#3366FF;}
  g.ZIPload, g.waterheater {fill:#66CCFF;}
  g.triplex_meter {fill:#FF6600;}
  g.triplex_node {fill:#FFCC00;}
  g.gridNode {fill:#CC0000;}
  g.swingNode {fill:hotpink;}
  g text {fill:black; stroke:black; stroke-width:0px; stroke-opacity: 1; font-size:15; pointer-events: none;}
  circle.nodeIsPinned {fill:none; stroke:black; stroke-width:2.5px; pointer-events: none;}
  circle.nodeNotPinned {fill:none; stroke-width:0px; pointer-events: none;}
  </style>
</head>
<body onkeypress='hotkeys()'>
<div id='title'>
  <div id='logoBox'><a href='/'>▦</a></div>
  <p>Grid Editor: </p>
  <p id='gridName'>{{model_id}}</p>
</div>
<div id='toolbar'>
  <div class='buttonGroup leftToolbar'>
    <button class='pill' onclick='dropPill(this, "Add")'>Add ▾</button>
    <ul id='newObjectMenu' class='menu'>
    </ul>
  </div>
  <button class='leftToolbar pill' onclick='javascript:zoomToFit()'>Zoom to Fit</button>
  <div class='buttonGroup leftToolbar'>
    <button class='pill' onclick='dropPill(this, "Pinning")'>Pinning ▾</button>
    <ul class='menu'>
      <li><a href='javascript:pinAll()' id='pinUnpinAll'>Pin All</a></li>
      <li><a href='javascript:unPinAll()'>Unpin All</a></li>
      <li><a href='javascript:toggleSelectedPin()'>Toggle Selected Pin (p)</a></li>
    </ul>
  </div>
  <div class='buttonGroup leftToolbar'>
    <button class='pill' onclick='dropPill(this, "Folding")'>Folding ▾</button>
    <ul class='menu'>
      <li><a href='javascript:foldOneLevel()'>One Level Fold</a></li>
      <li><a href='javascript:unfoldOneLevel()'>One Level Unfold</a></li>
      <li><a href='javascript:unfoldAll()'>Unfold All</a></li>
      <li><a href='javascript:foldAtSelected()'>Fold at Selected (f)</a></li>
      <li><a href='javascript:unfoldAtSelected()'>Unfold at Selected (u)</a></li>
    </ul>
  </div>
  <div class='buttonGroup rightToolbar'>
    <button class='pill' onclick='dropPill(this, "Grid")'>Grid ▾</button>
    <ul class='menu right'>
      <li id='renameMenuItem'><a href='javascript:rename()'>Rename</a></li>
      <li id='saveMenuItem'><a href='javascript:saveModel()'>Save</a></li>
      <li><a href='javascript:history.back()'>Cancel</a></li>
    </ul>
  </div>
  <div class='buttonGroup rightToolbar'>
    <button class='pill' onclick='dropPill(this, "Layout")'>Layout ▾</button>
    <ul class='menu right'>
      <table style='padding:4px;word-wrap:'>
        <tr>
          <td>GraphNodes</td>
          <td id='nodesBox'></td>
        </tr>
        <tr>
          <td colspan=2 style='padding:0px 0px 10px 0px'>
            <div id='nodesPercShown' style='background:black;width:30%;height:3px;display:inline-block'></div><div id='nodesPercHidden' style='background:gray;width:70%;height:3px;display:inline-block'></div>
          </td>
        <tr>
        <tr>
          <td>Gravity</td>
          <td><input id='gravityBox' type='text'></td>
        </tr>
        <tr>
          <td>Theta</td>
          <td><input id='thetaBox' type='text'></td>
        </tr>
        <tr>
          <td>Friction</td>
          <td><input id='frictionBox' type='text'></td>
        </tr>
        <tr>
          <td></td>
          <td style='padding-top:10px'><button onclick='layoutMenuApply()'>Apply</button></td>
        </tr>
      </table>
    </ul>
  </div>
</div>
<table id='selected'>
  <thead id='selHead'>
  </thead>
  <tbody id='selBody'>
  </tbody>
  <tfoot id='selFoot'>
  </tfoot>
</table>
<div id='chart' style='background:white'></div>
<script>

// GLOBAL VARIABLES:

feeder = '{{model_id}}'
var w = document.width
// HACK: subtract off the toolbar and titlebar heights.
var h = document.height - 112
var tree
var components
var selectedName
var altSelectedName

var zoomer = d3.behavior.zoom()

var vis = d3.select('#chart')
	.append('svg:svg')
	.attr('width', w)
	.attr('height', h)
	.attr('pointer-events', 'all')
	.call(zoomer.on('zoom', zoomRedraw))
	.append('svg:g')

vis.append('svg:g').attr('id','bottomLayer')
var bottomLayer = d3.select('#bottomLayer')

var force = d3.layout.force()
  .linkDistance(30)
  .size([w, h])
  .charge(function(d){return -120*d.chargeMultiple})
  // .charge(-120)

var nodes = force.nodes()
var links = force.links()
var hiddenNodes = []
var hiddenLinks = []

// FUNCTIONS FOR DRAWING:

function draw() {
  // d3.js bookkeeping to set what happens on each time tick in the simulation:
  force.on('tick', function() {
    vis.selectAll('line.link')
      .attr('x1', function(d) { return d.source.x; })
      .attr('y1', function(d) { return d.source.y; })
      .attr('x2', function(d) { return d.target.x; })
      .attr('y2', function(d) { return d.target.y; });
    vis.selectAll('.node')
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  });
  var name2nodeIndex = {}
  if (0 == nodes.length) {
    // Go through the first time and set up the nodes with indices:
    for (x in tree) {
      if (tree[x].name != undefined && tree[x].from == undefined) {
        nodeName = tree[x].name
        nodeObject = tree[x].object

        // Hack to make sure electrical nodes are classed differently than graph nodes for coloring purposes:
        if (nodeObject == 'node') nodeObject = 'gridNode'
        if (undefined != tree[x].bustype && tree[x].bustype == 'SWING') nodeObject += ' swingNode'
        nodeIndex = nodes.length
        nodes.push({name:nodeName,treeIndex:parseInt(x),objectType:nodeObject,chargeMultiple:1})
        name2nodeIndex[nodeName] = nodeIndex
      }
    }
    // Go through a second time and set up the links:
    for (x in tree) {
      if (tree[x].name != undefined) {
        if (tree[x].from != undefined && tree[x].to != undefined) {
          name2nodeIndex[tree[x].name] = links.length
          links.push({source:name2nodeIndex[tree[x].from],target:name2nodeIndex[tree[x].to],treeIndex:parseInt(x),objectType:'fromTo'})
        } else if (tree[x].parent != undefined) {
          links.push({source:name2nodeIndex[tree[x].name],target:name2nodeIndex[tree[x].parent],objectType:'parentChild'})
        }
      }
    }    
  }
  // This makes a fancy fade-in.
  vis.style('opacity', 1e-6)
    .transition()
    .duration(1500)
    .style('opacity', 1);
  // Start the layout.
  force.start();
  // Run the layout in the background until performance is acceptable.
  // preLayout()
  // Start drawing.
  redraw()
}

function redraw() {
  link = bottomLayer.selectAll('line.link').data(links, function(d) {return d.source.treeIndex + '-' + d.target.treeIndex})

  link.enter().append('svg:line')
    .on('click', onCompClick)
    .attr('class', function(d) { return 'link ' + d.objectType })
    .attr('id', function(d) { return 'n' + d.treeIndex })
    .style('stroke-width', function(d) { return Math.sqrt(d.value); })

  link.exit().remove()

  node = vis.selectAll('.node').data(nodes, function(d) {return d.treeIndex}).enter()
    .append("g")
    .call(force.drag)
    .attr('class', function(d) {return 'node ' + d.objectType})
    .attr('id', function(d) {return 'n' + d.treeIndex})
    .on('click', onCompClick)

  // Put the main circle on there, sized according to its size.
  node.append('svg:circle')
    .attr('id', function(d) {return 'circ' + d.treeIndex})
    .attr('class', 'nodeCircle')
    .attr('cx', 0)
    .attr('cy', 0)
    .attr('r', function(d) {return d.chargeMultiple * 10})

  // Pinning indicator.
  node.append('svg:circle')
    .attr('class', function(d) {if(d.fixed) {return 'nodeIsPinned'} else {return 'nodeNotPinned'}})
    .attr('id', function(d) {return 'pin' + d.treeIndex})
    .attr('cx', 0)
    .attr('cy', 0)
    .attr('r', 3)

  // This gives tooltips=nodeName to every node:
  // node.append('svg:title')
  //   .text(function(d) { return d.name; });

  // Some (loud) text labels.
  // node.append('text')
  //   .attr('dx', 12)
  //   .attr('dy', 4)
  //   .text(function(d) { return d.name });

  // Get rid of deleted nodes.
  vis.selectAll('.node').data(nodes, function(d) {return d.treeIndex}).exit().remove()

  // Update sizes
  vis.selectAll('.nodeCircle').data(nodes, function(d) {return d.treeIndex}).attr('r', function(d) {return d.chargeMultiple * 10})

  force.start()
}

function zoomRedraw() {
  // Some logging code, if you like:
  // console.log('here', d3.event.translate, d3.event.scale);
  vis.attr('transform',
    'translate(' + d3.event.translate + ')'
    + ' scale(' + d3.event.scale + ')');
}

function preLayout() {
  function fiveTicks() {for (i=0; i<5; ++i) force.tick()}
  fiveTicksTime = 1000
  // while performance is bad keep rendering in the background:
  while (fiveTicksTime > 200) {
    fiveTicksTime = time(fiveTicks)
    console.log(fiveTicksTime)
  }
}

function classify(d, c, on) {
  svg = d3.select('#chart')
  if(on) {
    // turn off the currently styled one
    svg.select('.' + c).classed(c, false);
    // then, style the new one
    svg.select("#n" + d.treeIndex).classed(c, true);
  }
  else {
    svg.select("#n" + d.treeIndex).classed(c, false);
  }
}

function onCompClick(d, i) {
  // Abort if we try to select a parentChild relationship.
  if (d.objectType == 'parentChild') return false
  // Multiselection case handled first:
  if (d3.event.altKey) {
    altSelectedName = d.name
    classify(d,'multiselected',true)
    return false
  }
  // Set up the global variables
  selectedName = d.name
  console.log([d.treeIndex,d.name,d.objectType])
  // Visually identify the selected node.
  classify(d,'selected',true)
  // clear the selected table
  table = gebi('selected')
  tableClear(table)
  treeData = tree[d.treeIndex]
  for (prop in treeData) {
    if (prop == 'object') {
      row = gebi('selHead').insertRow(0)
    } else if (prop != 'from' && prop != 'to' && prop != 'parent') {
      row = gebi('selBody').insertRow(-1)
    } else {
      row = null
    }
    try {
      row.insertCell(0).innerHTML = prop
      row.insertCell(1).innerHTML = treeData[prop]
    } catch(err) {
      //Catch: row was null.
    }
  }
  row = table.insertRow(-1)
  cell = row.insertCell(0)
  cell.colSpan = 2
  cell.innerHTML = '<button type="button" onclick="editObject(' + d.treeIndex + ')">Edit</button>'
}

function zoomToFit() {
  // TODO: rework our algorithm so we can zoom to fill the screen with the graph, not just go back to zoom level zero.
  zoomer.translate([0, 0]).scale(1)
  vis.attr('transform', 'translate([0, 0]) scale(1)')
}

// UTILITY AND MISC FUNCTIONS

function getSelectedNode() {
  if (nodes.some(function(d) {return d.name == selectedName}) == false) {
    // We have no selection, or a link was selected.
    return false
  }
  return nodes.filter(function(d) {return d.name == selectedName})[0]
}

function hotkeys() {
  // IE8 and earlier
  if(window.event) {x = event.keyCode}
  // IE9/Firefox/Chrome/Opera/Safari
  else if(event.which) {x = event.which}
  keychar = String.fromCharCode(x);
  // Dispatch the key:
  if (keychar == 'p') {toggleSelectedPin()}
  else if (keychar == 'f') {foldAtSelected()}
  else if (keychar == 'u') {unfoldAtSelected()}
}

// EDITING COMPONENTS FUNCTIONS

function editObject(treeIndex) {
  table = gebi('selected')
  //Make all the boxes editable.
  for (i = 1; i < table.rows.length - 1; i++) {
    cell = table.rows[i].cells[1]
    oldContent = cell.innerHTML
    cell.innerHTML = '<input type="text" name="null" data-old="' + oldContent + '" value="' + oldContent + '"/>'
  }
  //Put the save/cancel buttons in there with the right index.
  table.deleteRow(-1)
  bottomRow = table.insertRow(-1)
  bottomRow.insertCell(0).innerHTML = '<button type="button" onclick="saveEdits(' + treeIndex + ')">Save</button>'
  bottomRow.insertCell(1).innerHTML = '<button type="button" onclick="cancelEditing(' + treeIndex + ')">Cancel</button>'
  //Put a delete button in.
  gebi('selHead').rows[0].cells[1].innerHTML += '<button class="deleteButton" onclick="deleteObject(' + treeIndex + ')">Delete</button>'
}

function saveEdits(treeIndex) {
  function isNameAlreadyUsed(testValue) {
    // Helper function to make sure we don't make non-unique names.
    for (leaf in tree) {
      for (attrKey in tree[leaf]) {
        if (attrKey == 'name' && tree[leaf][attrKey] == testValue) {
          return true
        }
      }
    }
    return false
  }
  table = gebi('selected')
  // check for node or link:
  treeObject = tree[treeIndex]
  for (i = 1; i < table.rows.length - 1; i++) {
    key = table.rows[i].cells[0].innerHTML
    cell = table.rows[i].cells[1]
    oldValue = cell.childNodes[0].getAttribute('data-old')
    newValue = cell.childNodes[0].value
    // Names are GUIDS and so are strongly constrained. Make sure we're okay with the name change:
    if (key=='name') {
      // 1. If the name is already the name of something else, skip the renaming.
      if (isNameAlreadyUsed(newValue)) {
        alert('no way jose!')
        cell.innerHTML = oldValue
      }
      else {
        treeObject[key] = newValue
        cell.innerHTML = newValue
        // 2. If the name is unique, go through EVERY attribute in the tree and replace the old name with the new one.
        for (leaf in tree) {
          for (attrKey in tree[leaf]) {
            if (oldValue == tree[leaf][attrKey]) {console.log(tree[leaf]); tree[leaf][attrKey] = newValue}
          }
        }
        // 3. Go through the nodes and replace the name there too. UGH!
        nodeIndex = findIndex(nodes, 'name', oldValue)
        if (nodeIndex != -1) {nodes[nodeIndex]['name'] = newValue}
      }
    }
    else {
      treeObject[key] = newValue
      cell.innerHTML = newValue
    }
  }
  table.deleteRow(-1)
  row = table.insertRow(-1)
  cell = row.insertCell(0)
  cell.colSpan = 2
  cell.innerHTML = '<button type="button" onclick="editObject(' + treeIndex + ')">Edit</button>'
  delButton = gebi('selHead').rows[0].cells[1].children[0]
  delButton.parentNode.removeChild(delButton)
}

function cancelEditing(treeIndex) {
  table = gebi('selected')
  for (i = 1; i < table.rows.length - 1; i++) {
    cell = table.rows[i].cells[1]
    old = cell.childNodes[0].getAttribute('data-old')
    cell.innerHTML = old
  }
  table.deleteRow(-1)
  row = table.insertRow(-1)
  cell = row.insertCell(0)
  cell.colSpan = 2
  cell.innerHTML = '<button type="button" onclick="editObject(' + treeIndex + ')">Edit</button>'
  delButton = gebi('selHead').rows[0].cells[1].children[0]
  delButton.parentNode.removeChild(delButton)
}

function deleteObject(treeIndex) {
  // Figure out whether we have a node or an link:
  var isNode = true
  for (prop in tree[treeIndex]) if (prop == 'from') isNode = false
  if (isNode) {
    // Check for connections and abort if we have them.
    nodeName = tree[treeIndex].name
    for (indexVar in tree) {
      if (tree[indexVar].from == nodeName || tree[indexVar].to == nodeName || tree[indexVar].parent == nodeName) {
        alert('We can only delete nodes that aren\'t connected')
        return false
      }
    }
    // No connection, so delete the node:
    var nodeIndex
    for (x=0;x<nodes.length;x++) {
      if (nodes[x].treeIndex == treeIndex) nodeIndex = x
    }
    nodes.splice(nodeIndex,1)
    // If we have a parent child situation, delete the link:
    if (tree[treeIndex].parent != undefined) {
      var linkIndex
      for (x=0;x<links.length;x++) {
        if (links[x].source.name == nodeName) linkIndex = x
      }
      links.splice(linkIndex,1)
    }
    // Delete tree object:
    delete tree[treeIndex]
    // Select nothing:
    tableClear(gebi('selected'))
    redraw()
  } else {
    // Delete link:
    var linkIndex
    for (x=0;x<links.length;x++) {
      if (links[x].treeIndex == treeIndex) linkIndex = x
    }
    links.splice(linkIndex,1)
    // Delete tree object:
    delete tree[treeIndex]
    // Select nothing:
    tableClear(gebi('selected'))
    redraw()
  }
}

function nextTreeKey() {
  keyList = Object.keys(tree)
  max = 0
  for (x in keyList) {intKey = parseInt(keyList[x]); if (intKey > max) max = intKey}
  return max + 1
}

function findIndex(arrOfObjects,field,val) {
  for (findIndexI=0;findIndexI<arrOfObjects.length;findIndexI++) {if (arrOfObjects[findIndexI][field] == val) return findIndexI}
  return -1
}

// ADDING COMPONENTS FUNCTIONS

function fillComponentMenu() {
  newObjectMenu = gebi('newObjectMenu')
  for (component in components) {
    if (undefined == components[component]['from'] && undefined == components[component]['parent']) {addingFunctionName = 'newNode'}
    else if (undefined == components[component]['from']) {addingFunctionName = 'newChild'}
    else {addingFunctionName = 'newLink'}
    newObjectMenu.innerHTML += ('<li><a href="javascript:' + addingFunctionName + '(\'' + component + '\')">' + component + '</a></li>')
  }
}

function newNode(componentName) {
  // Get the stuff we need.
  component = clone(components[componentName])
  treeNewIndex = nextTreeKey()
  // Put the component in the tree with a new name.
  tree[treeNewIndex] = component
  tree[treeNewIndex].name = componentName + String(treeNewIndex)
  // Add to the nodes.
  newType = component.object
  // Hack to make sure we color nodes correctly:
  if (newType == 'node') newType = 'gridNode'
  if (undefined != tree[treeNewIndex].bustype && tree[treeNewIndex].bustype == 'SWING') newType += ' swingNode'
  nodeToAdd = {name:component.name, objectType:newType, treeIndex:treeNewIndex, chargeMultiple:1}
  nodes.push(nodeToAdd)
  redraw()
}

function newLink(componentName) {
  // Fail if we have an incorrect selection.
  function alreadyLinked(nodeName1, nodeName2) {
    for (linkId in links) {
      sourceName = links[linkId].source.name
      targetName = links[linkId].target.name
      if ((nodeName1 == sourceName && nodeName2 == targetName) || (nodeName1 == targetName && nodeName2 == sourceName)) {return true} }
    return false }
  if (undefined == selectedName || undefined == altSelectedName || selectedName == altSelectedName || alreadyLinked(selectedName, altSelectedName)) {
    alert('I am sorry, but we cannot insert a link there.')
    return false }
  // Get the stuff we need.
  component = clone(components[componentName])
  treeNewIndex = nextTreeKey()
  // Make sure component's to and from are set.
  component['from'] = selectedName
  component['to'] = altSelectedName
  // Put the component in the tree with a new name.
  tree[treeNewIndex] = component
  tree[treeNewIndex].name = componentName + String(treeNewIndex)
  // TODO: make absolutely sure we're not clobbering a name. We should just come up with a unique naming convention.
  // Add to the links.
  linkToAdd = {source:nodes[findIndex(nodes,'name',selectedName)], target:nodes[findIndex(nodes,'name',altSelectedName)], treeIndex:treeNewIndex, objectType:'fromTo'}
  links.push(linkToAdd)
  redraw()
}

function newChild(componentName) {
  if (undefined == selectedName || findIndex(nodes,'name',selectedName) == -1) {
    alert('I am sorry, but we cannot insert a child element there.')
    return false }
  // Get the stuff we need.
  component = clone(components[componentName])
  treeNewIndex = nextTreeKey()
  // Make sure component's parent is set.
  component['parent'] = selectedName
  // Put the component in the tree with a new name.
  tree[treeNewIndex] = component
  newName = componentName + String(treeNewIndex)
  tree[treeNewIndex].name = newName
  // TODO: make absolutely sure we're not clobbering a name. We should just come up with a unique naming convention.
  // Add to the nodes.
  nodeToAdd = {name:component.name, objectType:component.object, treeIndex:treeNewIndex, chargeMultiple:1}
  nodes.push(nodeToAdd)
  // Add to the links.
  linkToAdd = {source:nodes[findIndex(nodes,'name',newName)], target:nodes[findIndex(nodes,'name',selectedName)], objectType:'parentChild'}
  links.push(linkToAdd)
  redraw()
}

// MODEL SAVING

function saveModel() {
  sendDict = {tree:JSON.stringify(tree),
              nodes:JSON.stringify(nodes),
              hiddenNodes:JSON.stringify(hiddenNodes),
              links:JSON.stringify(links),
              hiddenLinks:JSON.stringify(hiddenLinks),
              feederName:feeder,
              newName:gebi('gridName').innerHTML}
  post_to_url('/saveFeeder/', sendDict)
}

function rename() {
  gebi('renameMenuItem').style.display = 'none'
  gebi('saveMenuItem').style.display = 'none'
  gridNameP = gebi('gridName')
  currentName = gridNameP.innerHTML
  inputBox = '<input type="text" id="gridNameEdit" name="gridNameEdit" data-old="' + currentName + '" value="' + currentName + '"/>'
  acceptButton = '<button class="smallButton" id="acceptButton" onclick="acceptRename()">✔</button>'
  cancelButton = '<button class="smallButton" id="cancelButton" onclick="cancelRename()">✘</button>'
  gridNameP.innerHTML = inputBox + acceptButton + cancelButton
}

function cancelRename() {
  gebi('renameMenuItem').style.display = 'block'
  gebi('saveMenuItem').style.display = 'block'
  gridNameP = gebi('gridName')
  oldName = gebi('gridNameEdit').getAttribute('data-old')
  gridNameP.innerHTML = oldName
}

function acceptRename() {
  gebi('renameMenuItem').style.display = 'block'
  gebi('saveMenuItem').style.display = 'block'
  gridNameP = gebi('gridName')
  newName = gebi('gridNameEdit').value
  gridNameP.innerHTML = newName
}

// PINNING FUNCTIONS

function pinAll() {
  for (node in nodes) {
    gebi('pin' + nodes[node].treeIndex).setAttribute('class','nodeIsPinned')
    nodes[node].fixed = true
  }
  for (hNode in hiddenNodes) {
    gebi('pin' + hiddenNodes[hNode].treeIndex).setAttribute('class','nodeIsPinned')
    hiddenNodes[hNode].fixed = true
  }
  force.start()
}

function unPinAll() {
  for (node in nodes) {
    gebi('pin' + nodes[node].treeIndex).setAttribute('class','nodeNotPinned')
    nodes[node].fixed = false
  }
  for (hNode in hiddenNodes) {
    gebi('pin' + hiddenNodes[hNode].treeIndex).setAttribute('class','nodeNotPinned')
    hiddenNodes[hNode].fixed = false
  }
  force.start()
}

function toggleSelectedPin() {
  selNode = getSelectedNode()
  pinCircle = gebi('pin' + selNode.treeIndex)
  if (pinCircle.getAttribute('class') == 'nodeIsPinned') {
    pinCircle.setAttribute('class','nodeNotPinned')
    selNode.fixed = false
  } else {
    pinCircle.setAttribute('class','nodeIsPinned')
    selNode.fixed = true
  }
  force.start()
}

// LAYOUT MENU FUNCTIONS

function layoutMenuInit() {
  nodeCount = nodes.length + hiddenNodes.length
  gebi('nodesBox').innerHTML = nodeCount
  gebi('nodesPercShown').style.width = nodes.length*100/nodeCount + '%'
  gebi('nodesPercHidden').style.width = hiddenNodes.length*100/nodeCount + '%'
  gebi('gravityBox').value = force.gravity()
  gebi('thetaBox').value = force.theta()
  gebi('frictionBox').value = force.friction()
}

function layoutMenuApply() {
  force.gravity(gebi('gravityBox').value)
  force.theta(gebi('thetaBox').value)
  force.friction(gebi('frictionBox').value)
  force.start()
}

function updateHiddenPerc() {
  gebi('nodesPercShown').style.width = nodes.length*100/nodeCount + '%'
  gebi('nodesPercHidden').style.width = hiddenNodes.length*100/nodeCount + '%'
}

// FUNCTIONS FOR GRAPH FOLDING:

function hideNode(node) {
  // helper function to hide links:
  function hideLink(link) {
    hiddenLinks.push(links.splice(links.indexOf(link),1)[0])
  }
  // Pop the node of the nodes list and push it onto the hiddenNodes list:
  hiddenNodes.push(nodes.splice(nodes.indexOf(node),1)[0])
  // Pop/push any connected Links:
  toHideLinks = links.filter(function (lin) {return node.name == lin.source.name || node.name == lin.target.name})
  toHideLinks.map(hideLink)
  // Make the parents big!
  linkedNames = toHideLinks.map(function (x) {return x.source.name}).concat(toHideLinks.map(function (y) {return y.target.name}))
  toGrow = nodes.filter(function(thisNode) {return linkedNames.indexOf(thisNode.name) != -1})
  toGrow.map(function(d) {d.chargeMultiple = 1.5})
}

function showNode(node) {
  toInsert = hiddenNodes.splice(hiddenNodes.indexOf(node),1)[0]
  // Actually reveal.
  nodes.push(toInsert)
}

function showLink(link) {
  toInsert = hiddenLinks.splice(hiddenLinks.indexOf(link),1)[0]
  links.push(toInsert)
}

function foldOneLevel() {
  function isChild(node) {
    counter = 0;
    for (linkId in links) {
      if (node.name == links[linkId].source.name || node.name == links[linkId].target.name) {counter += 1}
    }
    if (1 == counter) {return true}
    else {return false}
  }
  // Find all the children:
  toHide = nodes.filter(isChild)
  // Hide them:
  toHide.map(hideNode)
  updateHiddenPerc()
  redraw()
}

function unfoldOneLevel() {
  // Find the hidden links that are connected to visible nodes:
  function attachedToVizNode(link) {
    return nodes.some(function(d) {return d.name == link.source.name || d.name == link.target.name})
  }
  linksToReveal = hiddenLinks.filter(attachedToVizNode)
  // Find the nodes that are attached to the revealed links:
  function attachedToRevealed(node) {
    return linksToReveal.some(function(d) {return node.name == d.source.name || node.name == d.target.name})
  }
  // Size the parents of revealed elements correctly.
  nodesToResize = nodes.filter(attachedToRevealed)
  nodesToResize.map(function(d) {d.chargeMultiple = 1})
  // Actually do the revealing.
  nodesToReveal = hiddenNodes.filter(attachedToRevealed)
  linksToReveal.map(showLink)
  nodesToReveal.map(showNode)
  updateHiddenPerc()
  redraw()
}

function unfoldAll() {
  while (hiddenLinks.length != 0) {
    links.push(hiddenLinks.pop())
  }
  while (hiddenNodes.length != 0) {
    nodes.push(hiddenNodes.pop())
  }
  nodes.map(function(d) {d.chargeMultiple = 1})
  updateHiddenPerc()
  redraw()
}

function unfoldAtSelected() {
  selNode = getSelectedNode()
  function attachedToSelected(link) {
    return selNode.name == link.source.name || selNode.name == link.target.name
  }
  linksToReveal = hiddenLinks.filter(attachedToSelected)
  // Find the nodes that are attached to the revealed links:
  function attachedToRevealed(node) {
    return linksToReveal.some(function(d) {return node.name == d.source.name || node.name == d.target.name})
  }
  nodesToReveal = hiddenNodes.filter(attachedToRevealed)
  // Size the parents of revealed elements correctly.
  nodesToResize = nodes.filter(attachedToRevealed)
  nodesToResize.map(function(d) {d.chargeMultiple = 1})
  // Actually do the revealing.
  linksToReveal.map(showLink)
  nodesToReveal.map(showNode)
  updateHiddenPerc()
  redraw()
}

function foldAtSelected() {
  selNode = getSelectedNode()
  function attachedToSelected(link) {
    return selNode.name == link.source.name || selNode.name == link.target.name
  }
  linksToHide = links.filter(attachedToSelected)
  // Find the nodes that are attached to the revealed links:
  function attachedToRevealed(node) {
    return linksToHide.some(function(d) {return node.name == d.source.name || node.name == d.target.name})
  }
  attachedNodes = nodes.filter(attachedToRevealed)
  nodesToHide = attachedNodes.filter(function(node) {return node.weight == 1 && node.name != selNode.name})
  // Size the parent correctly.
  if (nodesToHide.length > 0) {selNode.chargeMultiple = 1}
  // Actually do the hiding.
  nodesToHide.map(hideNode)
  updateHiddenPerc()
  redraw()
}

// INIT FUNCTION FOLLOWS:

d3.json('/getComponents/', function(json){components=json;fillComponentMenu()})
d3.json('/api/models/{{ model_id }}.json', function (json) {
  tree = json['tree']
  // Regenerate the layout from the saved layout. For some insane reason, just cloning the list doesn't work.
  nodepop = json['nodes']
  while (nodepop.length != 0) {nodes.push(nodepop.pop())}
  linkpop = json['links']
  while (linkpop.length != 0) {links.push(linkpop.pop())}  
  hiddenNodePop = json['hiddenNodes']
  while (hiddenNodePop.length != 0) {hiddenNodes.push(hiddenNodePop.pop())}
  hiddenLinkPop = json['hiddenLinks']
  while (hiddenLinkPop .length != 0) {hiddenLinks.push(hiddenLinkPop.pop())}  
  //Gotta go through and make the links connect to their actual source and target objects. BAD DESIGN, D3!  
  for (li=0;li<links.length;li++) {
    sourceName = links[li].source.name
    targetName = links[li].target.name
    links[li].source = nodes[findIndex(nodes,'name',sourceName)]
    links[li].target = nodes[findIndex(nodes,'name',targetName)]
  }
  for (li2=0;li2<hiddenLinks.length;li2++) {
    sourceName = hiddenLinks[li2].source.name
    targetName = hiddenLinks[li2].target.name
    realSource = nodes[findIndex(nodes,'name',sourceName)]
    realSourceHidden = hiddenNodes[findIndex(hiddenNodes,'name',sourceName)]
    realTarget = nodes[findIndex(nodes,'name',targetName)]
    realTargetHidden = hiddenNodes[findIndex(hiddenNodes,'name',targetName)]
    if (undefined == realSource) {hiddenLinks[li2].source = realSourceHidden} else {hiddenLinks[li2].source = realSource}
    if (undefined == realTarget) {hiddenLinks[li2].target = realTargetHidden} else {hiddenLinks[li2].target = realTarget} 
  }
  draw()
  layoutMenuInit()
})

</script>
</body>
