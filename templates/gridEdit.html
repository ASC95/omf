<head>
  <script type='text/javascript' src='/static/d3.v2.js'></script>
  <script type='text/javascript' src='/static/omf.js'></script>
  <link rel='stylesheet' href='/static/omf.css'>
  <link rel='shortcut icon' href='{{ url_for("static", filename="favicon.ico") }}'>
  <style>
  body {overflow:hidden; height:100%; background:white;}
  div#title p {display:inline-block;}
  /*hacks to get D3 responsive sizing*/
  div#title {position: absolute; top:0;}
  div#toolbar {position: absolute; top:65px;}
  /*other styles*/  
  input#gridNameEdit {font-size:28pt; line-height: 28pt; text-shadow: 0px 3px 3px #4d4d4d; height: 50px; color:gray; padding:3px; margin-bottom:5px; width:85%;}
  button.smallButton {height:20px; width:20px; display:inline-block; float:right; padding:2px; margin-left:5px;}
  button.deleteButton {width:auto; float:right; background-color: #CC0000; color:white;}
  button.deleteButton:hover {background: #FF0000;}
  #selectedScroller {position:absolute; top:90pt; left:4pt; max-height:60%; width:350px; overflow-y: auto;}
  #selected {border:1px solid black; border-bottom:0px; width:100%; word-break:break-all;}
  .noSelection {border:none !important;}
  #selHead tr td {background:black; color:white;}
  #selected td {padding:5px; border-bottom:1px solid black; background:white; color:black}
  .leftToolbar {float:left; margin-left:5px !important;}
  .rightToolbar {float:right; margin-right:5px;}
  input {min-width: 100px}
  /* Start graph elements. */
  .nodetext {pointer-events: none; font: 10px; }
  g.node {fill:gray; stroke: #fff;stroke-width: 1.5px;}
  line.link {stroke: #999;stroke-opacity: .6; stroke-width: 6px;}
  line.parentChild {stroke-dasharray:3,3;}
  line.selected {stroke:black; stroke-width: 8px; stroke-opacity: 1.0;}
  g.selected {stroke:black; stroke-width: 4px; stroke-opacity: 1.0; }
  g.multiselected {stroke:black; stroke-width: 4px; stroke-opacity: 1.0; stroke-dasharray:2,2;}
  g.house {fill:#3366FF;}
  g.load {fill:#3366FF;}
  g.ZIPload, g.waterheater {fill:#66CCFF;}
  g.triplex_meter {fill:#FF6600;}
  g.triplex_node {fill:#FFCC00;}
  g.gridNode {fill:#CC0000;}
  g.swingNode {fill:hotpink;}
  g text {fill:black; stroke:black; stroke-width:0px; stroke-opacity: 1; font-size:15; pointer-events: none;}
  circle.nodeIsPinned {fill:none; stroke:black; stroke-width:2.5px; pointer-events: none;}
  circle.nodeNotPinned {fill:none; stroke-width:0px; pointer-events: none;}
  </style>
</head>
<body onkeypress='hotkeys()'>
<div id='title'>
  <div id='logoBox'><a href='/'>▦</a></div>
  <p>Grid Editor: </p>
  <p id='gridName'>{{feederName}}</p>
</div>
<div id='toolbar'>
  <div class='buttonGroup leftToolbar'>
    <button class='pill' onclick='dropPill(this, "Add")'>Add ▾</button>
    <ul id='newObjectMenu' class='menu'>
    </ul>
  </div>
  <div class='buttonGroup leftToolbar'>
    <button class='pill' onclick='dropPill(this, "Edit")'>Edit ▾</button>
    <ul class='menu'>
      <li><a href='javascript:staticLoadsToHouses()' id='staticToHouses'>Static Loads to Houses</a></li>
    </ul>
  </div>
  <button class='leftToolbar pill' onclick='javascript:zoomReset()'>Zoom Reset</button>
  <div class='buttonGroup leftToolbar'>
    <button class='pill' onclick='dropPill(this, "Pinning")'>Pinning ▾</button>
    <ul class='menu'>
      <li><a href='javascript:pinAll()' id='pinUnpinAll'>Pin All</a></li>
      <li><a href='javascript:unPinAll()'>Unpin All</a></li>
      <li><a href='javascript:toggleSelectedPin()'>Toggle Selected Pin (p)</a></li>
    </ul>
  </div>
  <div class='buttonGroup leftToolbar'>
    <button class='pill' onclick='dropPill(this, "Folding")'>Folding ▾</button>
    <ul class='menu'>
      <li><a href='javascript:foldOneLevel()'>One Level Fold</a></li>
      <li><a href='javascript:unfoldOneLevel()'>One Level Unfold</a></li>
      <li><a href='javascript:unfoldAll()'>Unfold All</a></li>
      <li><a href='javascript:foldAtSelected()'>Fold at Selected (f)</a></li>
      <li><a href='javascript:unfoldAtSelected()'>Unfold at Selected (u)</a></li>
    </ul>
  </div>
  <div class='buttonGroup leftToolbar'>
    <button class='pill' onclick='dropPillAndStay(this, "Find")'>Find ▾</button>
    <ul class='menu'>
      <table style='padding:4px;word-wrap:break-word'>
        <tr>
          <td>Term</td>
          <td><input id='searchTerm' type='text'></td>
        </tr>
        <tr>
          <td></td>
          <td id='searchHitCount' style='font-size:8pt;text-align:center'></td>
        </tr>
        <tr>
          <td style='padding-top:10px'><button onclick='findPrevious()'>Previous</button></td>
          <td style='padding-top:10px'><button onclick='findNext()'>Next</button></td>
        </tr>
      </table>
    </ul>
  </div>
  <div class='buttonGroup rightToolbar'>
    <button class='pill' onclick='dropPill(this, "Grid")'>Grid ▾</button>
    <ul class='menu right'>
      <li id='renameMenuItem'><a href='javascript:rename()'>Rename</a></li>
      <li id='saveMenuItem'><a href='javascript:saveModel()'>Save</a></li>
      <li><a href='javascript:history.back()'>Cancel</a></li>
    </ul>
  </div>
  <div class='buttonGroup rightToolbar'>
    <button class='pill' onclick='dropPillAndStay(this, "Layout")'>Layout ▾</button>
    <ul class='menu right'>
      <table style='padding:4px;word-wrap:break-word'>
        <tr>
          <td>GraphNodes</td>
          <td id='nodesBox'></td>
        </tr>
        <tr>
          <td colspan=2 style='padding:0px 0px 10px 0px'>
            <div id='nodesPercShown' style='background:black;width:30%;height:3px;display:inline-block'></div><div id='nodesPercHidden' style='background:gray;width:70%;height:3px;display:inline-block'></div>
          </td>
        <tr>
        <tr>
          <td>Gravity</td>
          <td><input id='gravityBox' type='text'></td>
        </tr>
        <tr>
          <td>Theta</td>
          <td><input id='thetaBox' type='text'></td>
        </tr>
        <tr>
          <td>Friction</td>
          <td><input id='frictionBox' type='text'></td>
        </tr>
        <tr>
          <td>Link Strength</td>
          <td><input id='linkStrengthBox' type='text'></td>
        </tr>
        <tr>
          <td></td>
          <td style='padding-top:10px'><button onclick='layoutMenuApply()'>Apply</button></td>
        </tr>
      </table>
    </ul>
  </div>
</div>
<div id='selectedScroller'>
  <table id='selected' class='noSelection'>
    <thead id='selHead'>
    </thead>
    <tbody id='selBody'>
    </tbody>
    <tfoot id='selFoot'>
    </tfoot>
  </table>
</div>
<script>

// GLOBAL VARIABLES:

feeder = '{{ feederName }}'
var w = 1000
var h = 1000
var tree
var components

var zoomer = d3.behavior.zoom()

var vis = d3.select('body')
  .append('svg:svg')
  .attr('id','graphSvg')
  .on('click', onSvgBlankCanvasClick)
  .attr('viewBox', '0 0 ' + w + ' ' + h )
  .attr('preserveAspectRatio', 'xMinYMin')
  .attr('pointer-events', 'all')
  .call(zoomer.on('zoom', zoomRedraw))
  .append('svg:g')

vis.append('svg:g').attr('id','linkLayer')

var force = d3.layout.force()
  .linkDistance(30)
  .size([w, h])
  .charge(function(d){return -120*d.chargeMultiple})
  // .charge(-120)

var nodes = force.nodes()
var links = force.links()
var hiddenNodes = []
var hiddenLinks = []

// FUNCTIONS FOR DRAWING:

function draw() {
  // d3.js bookkeeping to set what happens on each time tick in the simulation:
  force.on('tick', function() {
    vis.selectAll('line.link')
      .attr('x1', function(d) { return d.source.x; })
      .attr('y1', function(d) { return d.source.y; })
      .attr('x2', function(d) { return d.target.x; })
      .attr('y2', function(d) { return d.target.y; });
    vis.selectAll('.node')
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  });
  var name2nodeIndex = {}
  if (0 == nodes.length) {
    // Go through the first time and set up the nodes with indices:
    for (x in tree) {
      if (tree[x].name != undefined && tree[x].from == undefined) {
        nodeName = tree[x].name
        nodeObject = tree[x].object

        // Hack to make sure electrical nodes are classed differently than graph nodes for coloring purposes:
        if (nodeObject == 'node') nodeObject = 'gridNode'
        if (undefined != tree[x].bustype && tree[x].bustype == 'SWING') nodeObject += ' swingNode'
        nodeIndex = nodes.length
        nodes.push({name:nodeName,treeIndex:parseInt(x),objectType:nodeObject,chargeMultiple:1})
        name2nodeIndex[nodeName] = nodeIndex
      }
    }
    // Go through a second time and set up the links:
    for (x in tree) {
      if (tree[x].name != undefined) {
        if (tree[x].from != undefined && tree[x].to != undefined) {
          name2nodeIndex[tree[x].name] = links.length
          links.push({source:name2nodeIndex[tree[x].from],target:name2nodeIndex[tree[x].to],treeIndex:parseInt(x),objectType:'fromTo'})
        } else if (tree[x].parent != undefined) {
          links.push({source:name2nodeIndex[tree[x].name],target:name2nodeIndex[tree[x].parent],objectType:'parentChild'})
        }
      }
    }    
  }
  // This makes a fancy fade-in.
  vis.style('opacity', 1e-6)
    .transition()
    .duration(1500)
    .style('opacity', 1);
  // Start the layout.
  force.start();
  // Run the layout in the background until performance is acceptable.
  // preLayout()
  // Start drawing.
  redraw()
}

function redraw() {
  link = d3.select('#linkLayer').selectAll('line.link').data(links, function(d) {return d.source.treeIndex + '-' + d.target.treeIndex})

  link.enter().append('svg:line')
    .on('click', onCompClick)
    .attr('class', function(d) { return 'link ' + d.objectType })
    .attr('id', function(d) { return 'n' + d.treeIndex })
    .style('stroke-width', function(d) { return Math.sqrt(d.value); })

  link.exit().remove()

  node = vis.selectAll('.node').data(nodes, function(d) {return d.treeIndex}).enter()
    .append("g")
    .call(force.drag)
    .attr('class', function(d) {return 'node ' + d.objectType})
    .attr('id', function(d) {return 'n' + d.treeIndex})
    .on('click', onCompClick)

  // Put the main circle on there, sized according to its size.
  node.append('svg:circle')
    .attr('id', function(d) {return 'circ' + d.treeIndex})
    .attr('class', 'nodeCircle')
    .attr('cx', 0)
    .attr('cy', 0)
    .attr('r', function(d) {return d.chargeMultiple * 10})

  // Pinning indicator.
  node.append('svg:circle')
    .attr('class', function(d) {if(d.fixed) {return 'nodeIsPinned'} else {return 'nodeNotPinned'}})
    .attr('id', function(d) {return 'pin' + d.treeIndex})
    .attr('cx', 0)
    .attr('cy', 0)
    .attr('r', 3)

  // This gives tooltips=nodeName to every node:
  // node.append('svg:title')
  //   .text(function(d) { return d.name; });

  // Some (loud) text labels.
  // node.append('text')
  //   .attr('dx', 12)
  //   .attr('dy', 4)
  //   .text(function(d) { return d.name });

  // Get rid of deleted nodes.
  vis.selectAll('.node').data(nodes, function(d) {return d.treeIndex}).exit().remove()

  // Update sizes
  vis.selectAll('.nodeCircle').data(nodes, function(d) {return d.treeIndex}).attr('r', function(d) {return d.chargeMultiple * 10})

  force.start()
}

function zoomRedraw() {
  // console.log('here', d3.event.translate, d3.event.scale);
  vis.attr('transform',
    'translate(' + d3.event.translate + ')'
    + ' scale(' + d3.event.scale + ')');
}

function preLayout() {
  function fiveTicks() {for (i=0; i<5; ++i) force.tick()}
  fiveTicksTime = 1000
  // while performance is bad keep rendering in the background:
  while (fiveTicksTime > 200) {
    fiveTicksTime = time(fiveTicks)
    console.log(fiveTicksTime)
  }
}

function zoom(x,y,s) {
  zoomer.translate([x,y]).scale(s);
  vis.transition().duration(1000).attr('transform','translate(' + x + ',' + y + ') scale(' + s + ')')
}

function zoomReset() {
  // TODO: rework our algorithm so we can zoom to fill the screen with the graph, not just go back to zoom level zero.
  zoom(0,0,1)
}

function zoomToSelection() {
  domTargets = document.getElementsByClassName('selected')
  if (domTargets.length != 1) {return false}
  if (domTargets[0].nodeName == 'line') {
    x = getSelectedLink()['source']['x']
    y = getSelectedLink()['source']['y']
  }
  else {
    x = getSelectedNode()['x']
    y = getSelectedNode()['y']
  }
  // Zooming to a node's coordinates puts the node in the upper-left corner of the svg, and the fudge factor was worked out from that.
  zoom(-1*x+graphSvg.clientWidth/2, -1*y+graphSvg.clientHeight/2, 1)
}

function getCenterCoordinates() {
  try {
    x = zoomer.translate()[0]
    y = zoomer.translate()[1]
    s = 1/zoomer.scale()
    xMod = graphSvg.clientWidth/2
    yMod = graphSvg.clientHeight/2
    return [s*(xMod-x), s*(yMod-y)]
  } catch(err) {
    // Probably haven't transformed yet.
    return [0,0]
  }
}

// SELECT AND SEARCH FUNCTIONS

function onCompClick(d, i) {
  function classify(d, c) {
    svg = d3.select('#graphSvg')
    // turn off the old styled one, then style the new one
    svg.select('.' + c).classed(c, false);
    svg.select("#n" + d.treeIndex).classed(c, true);
  }
  // Start showing the table.
  gebi('selected').className = ''
  // Abort if we try to select a parentChild relationship.
  if (d.objectType == 'parentChild') return false
  // Multiselection case handled first:
  if (d3.event != null && d3.event.altKey) {
    classify(d,'multiselected')
    return false
  }
  console.log([d.treeIndex,d.name,d.objectType])
  // Visually identify the selected node.
  classify(d,'selected')
  // clear the selected table
  table = gebi('selected')
  tableClear(table)
  treeData = tree[d.treeIndex]
  for (prop in treeData) {
    if (prop == 'object') {
      row = gebi('selHead').insertRow(0)
    } else if (prop != 'from' && prop != 'to' && prop != 'parent' && prop != 'file') { // Avoid editing machine-written properties!
      row = gebi('selBody').insertRow(-1)
    } else {
      row = null
    }
    try {
      row.insertCell(0).innerHTML = prop
      row.insertCell(1).innerHTML = treeData[prop]
    } catch(err) {
      //Catch: row was null.
    }
  }
  row = table.insertRow(-1)
  cell = row.insertCell(0)
  cell.colSpan = 2
  cell.innerHTML = '<button type="button" onclick="editObject(' + d.treeIndex + ')">Edit</button>'
}

function clearSelection() {
  try {
    svg.select('.selected').classed('selected',false)
    svg.select('.multiselected').classed('multiselected',false)    
  } catch(err) {
    // ignore the error we get because we use svg before we define it--it'll be generated very fast after page load.
  }
  tableClear(gebi('selected'))
  gebi('selected').className = 'noSelection'
}

function selectViaTreeIndex(treeIndex) {
  if (tree[treeIndex].hasOwnProperty('from')) {
    // That particular tree item is a link:
    linkI = findIndex(links,'treeIndex',treeIndex)
    onCompClick(links[linkI],linkI)
  } else if (tree[treeIndex].hasOwnProperty('object') && tree[treeIndex]['object'] != 'player'){
    // Or it's a node:
    nodeI = findIndex(nodes,'treeIndex',treeIndex)
    onCompClick(nodes[nodeI],nodeI)
  } else {
    // Degenerate case: object without visual representation.
  }
}

function onSvgBlankCanvasClick() {
  if (window.event.toElement.tagName == 'svg') {clearSelection()}
}

function getSelectedNode() {
  try {
    hits = document.getElementsByClassName('selected')
    nodeIndex = findIndex(nodes, 'treeIndex', hits[0]['id'].substr(1))
    return nodes[nodeIndex]
  } catch(err) {
    // We had no selection, or the selection wasn't in the links.
    return undefined
  }
}

function getAltSelectedNode() {
  try {
    hits = document.getElementsByClassName('multiselected')
    nodeIndex = findIndex(nodes, 'treeIndex', hits[0]['id'].substr(1))
    return nodes[nodeIndex]
  } catch(err) {
    // We had no selection, or the selection wasn't in the links.
    return undefined
  }
}

function getSelectedLink() {
  try {
    hits = document.getElementsByClassName('selected')
    linkIndex = findIndex(links, 'treeIndex', hits[0]['id'].substr(1))
    return links[linkIndex]
  } catch(err) {
    // We had no selection, or the selection wasn't in the links.
    return undefined
  }
}

function hotkeys() {
  // IE8 and earlier
  if(window.event) {x = event.keyCode}
  // IE9/Firefox/Chrome/Opera/Safari
  else if(event.which) {x = event.which}
  keychar = String.fromCharCode(x);
  // Dispatch the key:
  if (keychar == 'p') {toggleSelectedPin()}
  else if (keychar == 'f') {foldAtSelected()}
  else if (keychar == 'u') {unfoldAtSelected()}
}

function findElementsViaString(inString) {
  results = []
  for (key in tree) {
    subIndex = JSON.stringify(tree[key]).indexOf(inString)
    if (subIndex != -1 && tree[key].hasOwnProperty('object') && tree[key]['object'] != 'player') {
      results.push(key)
    }
  }
  return results
}

// Public variable to hold the current search state. Todo: put in a closure.
var searchCursor
var oldSearchTerm

function findNext() {
  term = gebi('searchTerm').value
  if (oldSearchTerm != term) {
    oldSearchTerm = term
    searchCursor = undefined
  }
  hits = findElementsViaString(term)
  gebi('searchHitCount').innerHTML = hits.length + ' Hits'
  if (hits.length == 0) {return false}
  if (searchCursor == undefined) {
    selectViaTreeIndex(hits[0])
    searchCursor = 0
  } else {
    searchCursor++
    if (searchCursor == hits.length) {searchCursor = 0}
    if (searchCursor == -1) {searchCursor = hits.length-2}
    selectViaTreeIndex(hits[searchCursor])
  }
  zoomToSelection()
}

function findPrevious() {
  if (searchCursor == undefined) {
    findNext()
  } else {
    searchCursor -= 2
    findNext()
  }
}

// EDITING AND REMOVING COMPONENTS FUNCTIONS

function editObject(treeIndex) {
  table = gebi('selected')
  //Make all the boxes editable.
  for (i = 1; i < table.rows.length - 1; i++) {
    cell = table.rows[i].cells[1]
    oldContent = cell.innerHTML
    cell.innerHTML = '<input type="text" name="null" data-old="' + oldContent + '" value="' + oldContent + '"/>'
  }
  //Put the save/cancel buttons in there with the right index.
  table.deleteRow(-1)
  bottomRow = table.insertRow(-1)
  bottomRow.insertCell(0).innerHTML = '<button type="button" onclick="saveEdits(' + treeIndex + ')">Save</button>'
  bottomRow.insertCell(1).innerHTML = '<button type="button" onclick="cancelEditing(' + treeIndex + ')">Cancel</button>'
  //Put a delete button in.
  gebi('selHead').rows[0].cells[1].innerHTML += '<button class="deleteButton" onclick="deleteObject(' + treeIndex + ')">Delete</button>'
}

function saveEdits(treeIndex) {
  function isNameAlreadyUsed(testValue) {
    // Helper function to make sure we don't make non-unique names.
    for (leaf in tree) {
      for (attrKey in tree[leaf]) {
        if (attrKey == 'name' && tree[leaf][attrKey] == testValue) {
          return true
        }
      }
    }
    return false
  }
  table = gebi('selected')
  // check for node or link:
  treeObject = tree[treeIndex]
  for (i = 1; i < table.rows.length - 1; i++) {
    key = table.rows[i].cells[0].innerHTML
    cell = table.rows[i].cells[1]
    oldValue = cell.childNodes[0].getAttribute('data-old')
    newValue = cell.childNodes[0].value
    // Names are GUIDS and so are strongly constrained. Make sure we're okay with the name change:
    if (key=='name') {
      // 1. If the name is already the name of something else, skip the renaming.
      if (isNameAlreadyUsed(newValue) && oldValue != newValue) {
        cell.innerHTML = oldValue
        alert('Please choose a unique name.')
      }
      else {
        treeObject[key] = newValue
        cell.innerHTML = newValue
        // 2. If the name is unique, go through EVERY attribute in the tree and replace the old name with the new one.
        for (leaf in tree) {
          for (attrKey in tree[leaf]) {
            if (oldValue == tree[leaf][attrKey]) {console.log(tree[leaf]); tree[leaf][attrKey] = newValue}
          }
        }
        // 3. Go through the nodes and replace the name there too. UGH!
        nodeIndex = findIndex(nodes, 'name', oldValue)
        if (nodeIndex != -1) {nodes[nodeIndex]['name'] = newValue}
      }
    }
    else {
      treeObject[key] = newValue
      cell.innerHTML = newValue
    }
  }
  table.deleteRow(-1)
  row = table.insertRow(-1)
  cell = row.insertCell(0)
  cell.colSpan = 2
  cell.innerHTML = '<button type="button" onclick="editObject(' + treeIndex + ')">Edit</button>'
  delButton = gebi('selHead').rows[0].cells[1].children[0]
  delButton.parentNode.removeChild(delButton)
}

function cancelEditing(treeIndex) {
  table = gebi('selected')
  for (i = 1; i < table.rows.length - 1; i++) {
    cell = table.rows[i].cells[1]
    old = cell.childNodes[0].getAttribute('data-old')
    cell.innerHTML = old
  }
  table.deleteRow(-1)
  row = table.insertRow(-1)
  cell = row.insertCell(0)
  cell.colSpan = 2
  cell.innerHTML = '<button type="button" onclick="editObject(' + treeIndex + ')">Edit</button>'
  delButton = gebi('selHead').rows[0].cells[1].children[0]
  delButton.parentNode.removeChild(delButton)
}

function deleteObject(treeIndex) {
  // Figure out whether we have a node or an link:
  var isNode = true
  for (prop in tree[treeIndex]) if (prop == 'from') isNode = false
  if (isNode) {
    // Check for connections and abort if we have them.
    nodeName = tree[treeIndex].name
    for (indexVar in tree) {
      if (tree[indexVar].from == nodeName || tree[indexVar].to == nodeName || tree[indexVar].parent == nodeName) {
        alert('We can only delete nodes that aren\'t connected')
        return false
      }
    }
    // No connection, so delete the node:
    var nodeIndex
    for (x=0;x<nodes.length;x++) {
      if (nodes[x].treeIndex == treeIndex) nodeIndex = x
    }
    nodes.splice(nodeIndex,1)
    // If we have a parent child situation, delete the link:
    if (tree[treeIndex].parent != undefined) {
      var linkIndex
      for (x=0;x<links.length;x++) {
        if (links[x].source.name == nodeName) linkIndex = x
      }
      links.splice(linkIndex,1)
    }
  } else {
    // Delete link:
    var linkIndex
    for (x=0;x<links.length;x++) {
      if (links[x].treeIndex == treeIndex) linkIndex = x
    }
    links.splice(linkIndex,1)
  }
  // Delete tree object:
  delete tree[treeIndex]
  clearSelection()
  redraw()  
}

function nextTreeKey() {
  keyList = Object.keys(tree)
  max = 0
  for (x in keyList) {intKey = parseInt(keyList[x]); if (intKey > max) max = intKey}
  return max + 1
}

function findIndex(inOb,field,val) {
  for (key in inOb) {if (inOb[key][field]==val) {return key}}
  // if we can't find an index:
  return ''
}

// ADDING COMPONENTS FUNCTIONS

function fillComponentMenu() {
  newObjectMenu = gebi('newObjectMenu')
  for (component in components) {
    if (undefined == components[component]['from'] && undefined == components[component]['parent']) {addingFunctionName = 'newNode'}
    else if (undefined == components[component]['from']) {addingFunctionName = 'newChildAtSelected'}
    else {addingFunctionName = 'newLink'}
    newObjectMenu.innerHTML += ('<li><a href="javascript:' + addingFunctionName + '(\'' + component + '\')">' + component + '</a></li>')
  }
}

function newNode(componentName) {
  // Get the stuff we need.
  component = clone(components[componentName])
  treeNewIndex = nextTreeKey()
  // Put the component in the tree with a new name.
  tree[treeNewIndex] = component
  tree[treeNewIndex].name = componentName + String(treeNewIndex)
  // Add to the nodes.
  newType = component.object
  // Hack to make sure we color nodes correctly:
  if (newType == 'node') newType = 'gridNode'
  if (undefined != tree[treeNewIndex].bustype && tree[treeNewIndex].bustype == 'SWING') newType += ' swingNode'
  coords = getCenterCoordinates()
  nodeToAdd = {name:component.name, objectType:newType, treeIndex:treeNewIndex, chargeMultiple:1, fixed:true, x:coords[0], y:coords[1], px:coords[0], py:coords[1]}
  nodes.push(nodeToAdd)
  redraw()
}

function newLink(componentName) {
  // Fail if we have an incorrect selection.
  function alreadyLinked(nodeName1, nodeName2) {
    for (linkId in links) {
      sourceName = links[linkId].source.name
      targetName = links[linkId].target.name
      if ((nodeName1 == sourceName && nodeName2 == targetName) || (nodeName1 == targetName && nodeName2 == sourceName)) {return true}
    }
    return false
  }
  try {
    selectedName = getSelectedNode()['name']
    altSelectedName = getAltSelectedNode()['name']
  } catch(err) {
    // Key error!
    selectedName = undefined
    altSelectedName = undefined
  }
  if (undefined == selectedName || undefined == altSelectedName || selectedName == altSelectedName || alreadyLinked(selectedName, altSelectedName)) {
    alert('I am sorry, but we cannot insert a link there.')
    return false
  }
  // Get the stuff we need.
  component = clone(components[componentName])
  treeNewIndex = nextTreeKey()
  // Make sure component's to and from are set.
  component['from'] = selectedName
  component['to'] = altSelectedName
  // Put the component in the tree with a new name.
  tree[treeNewIndex] = component
  tree[treeNewIndex].name = componentName + String(treeNewIndex)
  // TODO: make absolutely sure we're not clobbering a name. We should just come up with a unique naming convention.
  // Add to the links.
  linkToAdd = {source:nodes[findIndex(nodes,'name',selectedName)], target:nodes[findIndex(nodes,'name',altSelectedName)], treeIndex:treeNewIndex, objectType:'fromTo'}
  links.push(linkToAdd)
  redraw()
}

function newChildAtSelected(componentName) {
  if (undefined == getSelectedNode()) {
    alert('I am sorry, but we cannot insert a child element there.')
    return false
  }
  // Get the stuff we need.
  component = clone(components[componentName])
  newChildAtLocation(component, getSelectedNode()['treeIndex'])
  redraw()
}

function newChildAtLocation(component,treeIndex) {
  treeNewIndex = nextTreeKey()
  // Make sure component's parent is set.
  component['parent'] = tree[treeIndex]['name']
  // Put the component in the tree with a new name.
  tree[treeNewIndex] = component
  newName = component['object'] + String(treeNewIndex)
  tree[treeNewIndex].name = newName
  // TODO: make absolutely sure we're not clobbering a name. We should just come up with a unique naming convention.
  // Add to the nodes.
  nodeToAdd = {name:component.name, objectType:component.object, treeIndex:treeNewIndex, chargeMultiple:1}
  nodes.push(nodeToAdd)
  // Add to the links.
  linkToAdd = {source:nodes[findIndex(nodes,'name',newName)], target:nodes[findIndex(nodes,'name',tree[treeIndex]['name'])], objectType:'parentChild'}
  links.push(linkToAdd)
}

function staticLoadsToHouses() {
  function randomHouse() {
    function randomGaussian() {
      // Get a Gaussian from a uniform(0,1) via the Box-Muller transform.
      do {
        x1 = 2 * Math.random() - 1
        x2 = 2 * Math.random() - 1
        rad = x1 * x1 + x2 * x2
      } while (rad >= 1 || rad == 0)   
      c = Math.sqrt(-2 * Math.log(rad) / rad);
      return x1 * c
    }
    function randomChoice(inList) {return inList[Math.floor(Math.random() * inList.length)]}
    function randomInt(min,max) {return Math.floor(Math.random()*(max - min + 1) + min)}
    newHouse = {}
    newHouse['object'] = 'house'
    newHouse['air_temperature'] = '70'
    newHouse['cooling_COP'] = randomInt(25,40)/10.0 + ''
    newHouse['cooling_setpoint'] = 'cooling' + randomInt(1,8) + '*1'
    newHouse['cooling_system_type'] = randomChoice(['ELECTRIC', 'HEAT_PUMP', 'NONE'])
    // House sizing distribution from http://www.census.gov/housing/ahs/
    // between 1100 and 3000. Probably needs a normal distribution.
    area = 1800 + 500*randomGaussian()
    if (area < 500) {area = 500}
    area = area.toPrecision(2) * 1.0 + ''
    newHouse['floor_area'] = area
    newHouse['heating_COP'] = randomInt(20,35)/10.0 + ''
    newHouse['heating_setpoint'] = 'heating' + randomInt(1,8) + '*1'
    newHouse['heating_system_type'] = randomChoice(['RESISTANCE', 'HEAT_PUMP', 'GAS'])
    newHouse['mass_temperature'] = '70'
    skew = 1200*randomGaussian()
    skew = skew.toPrecision(3) * 1.0 + ''
    newHouse['schedule_skew'] = skew
    newHouse['thermal_integrity_level'] = randomChoice([1,2,2,2,3,3,3,4,4,4,4,4,4,5,5,5,5,5,5,5,6,6,6]) + ''
    treeNewIndex = nextTreeKey()
    newHouse['name'] = 'synhouse' + treeNewIndex
    return newHouse
  }
  function replaceAllHouses() {
    for (index in tree) {
      if (tree[index].hasOwnProperty('object') && tree[index].hasOwnProperty('parent') && tree[index]['object']=='triplex_node') {
        // console.log(tree[index])
        parentIndex = findIndex(tree, 'name', tree[index]['parent'])
        deleteObject(index)
        newHouse = randomHouse()
        newChildAtLocation(newHouse, parentIndex)
      }
    }
    redraw()
    removeProgressDialog()
  }
  showProgressDialog('Please wait. Houses are being generated.')
  // HACK: we do this extra timeout so the DOM gets execution priority and redraws the page.
  setTimeout(replaceAllHouses, 500);
}

// MODEL SAVING

function saveModel() {
  sendDict = {tree:JSON.stringify(tree),
              nodes:JSON.stringify(nodes),
              hiddenNodes:JSON.stringify(hiddenNodes),
              links:JSON.stringify(links),
              hiddenLinks:JSON.stringify(hiddenLinks),
              layoutVars:JSON.stringify({'gravity':force.gravity(),'theta':force.theta(),'friction':force.friction(),'linkStrength':force.linkStrength()()}),
              feederName:feeder,
              newName:gebi('gridName').innerHTML}
  post_to_url('/saveFeeder/', sendDict)
}

function rename() {
  gebi('renameMenuItem').style.display = 'none'
  gebi('saveMenuItem').style.display = 'none'
  gridNameP = gebi('gridName')
  currentName = gridNameP.innerHTML
  inputBox = '<input type="text" id="gridNameEdit" name="gridNameEdit" data-old="' + currentName + '" value="' + currentName + '"/>'
  acceptButton = '<button class="smallButton" id="acceptButton" onclick="acceptRename()">✔</button>'
  cancelButton = '<button class="smallButton" id="cancelButton" onclick="cancelRename()">✘</button>'
  gridNameP.innerHTML = inputBox + acceptButton + cancelButton
}

function cancelRename() {
  gebi('renameMenuItem').style.display = 'block'
  gebi('saveMenuItem').style.display = 'block'
  gridNameP = gebi('gridName')
  oldName = gebi('gridNameEdit').getAttribute('data-old')
  gridNameP.innerHTML = oldName
}

function acceptRename() {
  gebi('renameMenuItem').style.display = 'block'
  gebi('saveMenuItem').style.display = 'block'
  gridNameP = gebi('gridName')
  newName = gebi('gridNameEdit').value
  gridNameP.innerHTML = newName
}

// PINNING FUNCTIONS

function pinAll() {
  for (node in nodes) {
    gebi('pin' + nodes[node].treeIndex).setAttribute('class','nodeIsPinned')
    nodes[node].fixed = true
  }
  for (hNode in hiddenNodes) {
    gebi('pin' + hiddenNodes[hNode].treeIndex).setAttribute('class','nodeIsPinned')
    hiddenNodes[hNode].fixed = true
  }
  force.start()
}

function unPinAll() {
  for (node in nodes) {
    gebi('pin' + nodes[node].treeIndex).setAttribute('class','nodeNotPinned')
    nodes[node].fixed = false
  }
  for (hNode in hiddenNodes) {
    gebi('pin' + hiddenNodes[hNode].treeIndex).setAttribute('class','nodeNotPinned')
    hiddenNodes[hNode].fixed = false
  }
  force.start()
}

function toggleSelectedPin() {
  selNode = getSelectedNode()
  pinCircle = gebi('pin' + selNode.treeIndex)
  if (pinCircle.getAttribute('class') == 'nodeIsPinned') {
    pinCircle.setAttribute('class','nodeNotPinned')
    selNode.fixed = false
  } else {
    pinCircle.setAttribute('class','nodeIsPinned')
    selNode.fixed = true
  }
  force.start()
}

// LAYOUT MENU FUNCTIONS

function layoutMenuInit() {
  nodeCount = nodes.length + hiddenNodes.length
  gebi('nodesBox').innerHTML = nodeCount
  gebi('nodesPercShown').style.width = nodes.length*100/nodeCount + '%'
  gebi('nodesPercHidden').style.width = hiddenNodes.length*100/nodeCount + '%'
  gebi('gravityBox').value = force.gravity()
  gebi('thetaBox').value = force.theta()
  gebi('frictionBox').value = force.friction()
  //D3 is crazy, linkStrength is a functor but none of the other variables are. WTF?
  gebi('linkStrengthBox').value = force.linkStrength()()
}

function layoutMenuApply() {
  force.gravity(gebi('gravityBox').value)
  force.theta(gebi('thetaBox').value)
  force.friction(gebi('frictionBox').value)
  force.linkStrength(gebi('linkStrengthBox').value)
  force.start()
}

function updateHiddenPerc() {
  gebi('nodesPercShown').style.width = nodes.length*100/nodeCount + '%'
  gebi('nodesPercHidden').style.width = hiddenNodes.length*100/nodeCount + '%'
}

// FUNCTIONS FOR GRAPH FOLDING:

function hideNode(node) {
  // helper function to hide links:
  function hideLink(link) {
    hiddenLinks.push(links.splice(links.indexOf(link),1)[0])
  }
  // Pop the node of the nodes list and push it onto the hiddenNodes list:
  hiddenNodes.push(nodes.splice(nodes.indexOf(node),1)[0])
  // Pop/push any connected Links:
  toHideLinks = links.filter(function (lin) {return node.name == lin.source.name || node.name == lin.target.name})
  toHideLinks.map(hideLink)
  // Make the parents big!
  linkedNames = toHideLinks.map(function (x) {return x.source.name}).concat(toHideLinks.map(function (y) {return y.target.name}))
  toGrow = nodes.filter(function(thisNode) {return linkedNames.indexOf(thisNode.name) != -1})
  toGrow.map(function(d) {d.chargeMultiple = 1.5})
}

function showNode(node) {
  toInsert = hiddenNodes.splice(hiddenNodes.indexOf(node),1)[0]
  // Actually reveal.
  nodes.push(toInsert)
}

function showLink(link) {
  toInsert = hiddenLinks.splice(hiddenLinks.indexOf(link),1)[0]
  links.push(toInsert)
}

function foldOneLevel() {
  function isChild(node) {
    counter = 0;
    for (linkId in links) {
      if (node.name == links[linkId].source.name || node.name == links[linkId].target.name) {counter += 1}
    }
    if (1 == counter) {return true}
    else {return false}
  }
  // Find all the children:
  toHide = nodes.filter(isChild)
  // Hide them:
  toHide.map(hideNode)
  updateHiddenPerc()
  redraw()
}

function unfoldOneLevel() {
  // Find the hidden links that are connected to visible nodes:
  function attachedToVizNode(link) {
    return nodes.some(function(d) {return d.name == link.source.name || d.name == link.target.name})
  }
  linksToReveal = hiddenLinks.filter(attachedToVizNode)
  // Find the nodes that are attached to the revealed links:
  function attachedToRevealed(node) {
    return linksToReveal.some(function(d) {return node.name == d.source.name || node.name == d.target.name})
  }
  // Size the parents of revealed elements correctly.
  nodesToResize = nodes.filter(attachedToRevealed)
  nodesToResize.map(function(d) {d.chargeMultiple = 1})
  // Actually do the revealing.
  nodesToReveal = hiddenNodes.filter(attachedToRevealed)
  linksToReveal.map(showLink)
  nodesToReveal.map(showNode)
  updateHiddenPerc()
  redraw()
}

function unfoldAll() {
  while (hiddenLinks.length != 0) {
    links.push(hiddenLinks.pop())
  }
  while (hiddenNodes.length != 0) {
    nodes.push(hiddenNodes.pop())
  }
  nodes.map(function(d) {d.chargeMultiple = 1})
  updateHiddenPerc()
  redraw()
}

function unfoldAtSelected() {
  selNode = getSelectedNode()
  function attachedToSelected(link) {
    return selNode.name == link.source.name || selNode.name == link.target.name
  }
  linksToReveal = hiddenLinks.filter(attachedToSelected)
  // Find the nodes that are attached to the revealed links:
  function attachedToRevealed(node) {
    return linksToReveal.some(function(d) {return node.name == d.source.name || node.name == d.target.name})
  }
  nodesToReveal = hiddenNodes.filter(attachedToRevealed)
  // Size the parents of revealed elements correctly.
  nodesToResize = nodes.filter(attachedToRevealed)
  nodesToResize.map(function(d) {d.chargeMultiple = 1})
  // Actually do the revealing.
  linksToReveal.map(showLink)
  nodesToReveal.map(showNode)
  updateHiddenPerc()
  redraw()
}

function foldAtSelected() {
  selNode = getSelectedNode()
  function attachedToSelected(link) {
    return selNode.name == link.source.name || selNode.name == link.target.name
  }
  linksToHide = links.filter(attachedToSelected)
  // Find the nodes that are attached to the revealed links:
  function attachedToRevealed(node) {
    return linksToHide.some(function(d) {return node.name == d.source.name || node.name == d.target.name})
  }
  attachedNodes = nodes.filter(attachedToRevealed)
  nodesToHide = attachedNodes.filter(function(node) {return node.weight == 1 && node.name != selNode.name})
  // Size the parent correctly.
  if (nodesToHide.length > 0) {selNode.chargeMultiple = 1}
  // Actually do the hiding.
  nodesToHide.map(hideNode)
  updateHiddenPerc()
  redraw()
}

// INIT FUNCTIONS FOLLOW:
d3.json('/getComponents/', function(json){components=json;fillComponentMenu()})

var apiAddress = '/feederData/{{ path }}/{{ feederName }}.json'
d3.json(apiAddress, function (json) {
  tree = json['tree']
  // Regenerate the layout from the saved layout. For some insane reason, just cloning the list doesn't work.
  nodepop = json['nodes']
  while (nodepop.length != 0) {nodes.push(nodepop.pop())}
  linkpop = json['links']
  while (linkpop.length != 0) {links.push(linkpop.pop())}  
  hiddenNodePop = json['hiddenNodes']
  while (hiddenNodePop.length != 0) {hiddenNodes.push(hiddenNodePop.pop())}
  hiddenLinkPop = json['hiddenLinks']
  while (hiddenLinkPop .length != 0) {hiddenLinks.push(hiddenLinkPop.pop())}  
  //Gotta go through and make the links connect to their actual source and target objects. BAD DESIGN, D3!  
  for (li=0;li<links.length;li++) {
    sourceName = links[li].source.name
    targetName = links[li].target.name
    links[li].source = nodes[findIndex(nodes,'name',sourceName)]
    links[li].target = nodes[findIndex(nodes,'name',targetName)]
  }
  for (li2=0;li2<hiddenLinks.length;li2++) {
    sourceName = hiddenLinks[li2].source.name
    targetName = hiddenLinks[li2].target.name
    realSource = nodes[findIndex(nodes,'name',sourceName)]
    realSourceHidden = hiddenNodes[findIndex(hiddenNodes,'name',sourceName)]
    realTarget = nodes[findIndex(nodes,'name',targetName)]
    realTargetHidden = hiddenNodes[findIndex(hiddenNodes,'name',targetName)]
    if (undefined == realSource) {hiddenLinks[li2].source = realSourceHidden} else {hiddenLinks[li2].source = realSource}
    if (undefined == realTarget) {hiddenLinks[li2].target = realTargetHidden} else {hiddenLinks[li2].target = realTarget} 
  }
  // Regenerate the layout variables:
  if (undefined != json['layoutVars']) {
    force.gravity(json['layoutVars']['gravity'])
    force.theta(json['layoutVars']['theta'])
    force.friction(json['layoutVars']['friction'])
    force.linkStrength(json['layoutVars']['linkStrength'])
  }
  // And go at it:
  draw()
  layoutMenuInit()
})

</script>
</body>
