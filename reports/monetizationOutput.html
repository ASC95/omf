<p class="reportTitle">Cost Benefit Analysis</p>
<div id="monetizationReport" class="tightContent">
	<div class="studyContainer" style="position:relative;height:200px">
		<div id="monetizedPowerTimeSeries" style="position:absolute;top:0px;left:0px;width:500px;height:200px">
			<script>monCapCostGraph = new Highcharts.Chart({{ monPowParams }})</script>
		</div>
		<div id="monetizedEnergyBalance" style="position:absolute;top:0px;left:500px;width:500px;height:200px">
			<script>monEnergyCostGraph = new Highcharts.Chart({{ monEnergyParams }})</script>
		</div>
	</div>
	<div id="costGrowthContainer" class="studyContainer" style="height:200px">
		<script>costGrowth = new Highcharts.Chart({{ savingsGrowthParams }})</script>
	</div>
	<div id="additionalMetrics" class="studyContainer">
		<div style="width:1000px;padding:5px 5px 5px 5px">
				Co-op Energy Rate ($/kWh) <input id="distrEnergyRate" value=""/> Capacity Rate ($/kW) <input id="distrCapacityRate" value=""/><button style="width:100px" onclick="recalculateCostBenefit()">Recalculate</button>
		</div>
		<table style="width:980px;padding-bottom:10px">
			<thead>
				<tr><th>Study</th><th>Baseline</th><th>Capital Cost</th><th>O&amp;M Cost</th><th>Cap. Cost</th><th>En. Cost</th><th>Y1 Save</th><th>Annual Save</th><th>Payback (Y)</th></tr>
			</thead>
			<tbody id="additionalMetricsTable">
			</tbody>
		</table>
		<script>
			studyDict = {{ studyDict | safe }}
			inputData = {{ inputData | safe }}
			timeStamps = {{ timeStamps | safe }}
			
			// Put the input data in.
			gebi('distrEnergyRate').value = inputData.distrEnergyRate
			gebi('distrCapacityRate').value = inputData.distrCapacityRate

			// Init the table.
			firstTime = true
			for (study in studyDict) {
				if (undefined != study) {
				// Add table row:
				table = gebi('additionalMetricsTable')
				newRow = table.insertRow()
				if (firstTime) {checked = 'checked'; cap = '0'; om = '0'; firstTime = false} else {checked = ''; cap = inputData['equipAndInstallCost']; om = inputData['opAndMaintCost']}
				newRow.innerHTML = '<td class="studyName">' + study + '</td>' +
				'<td><input type="radio" name="baseline" class="baseline" ' + checked + '/></td>' +
				'<td><input class="capCost" value="' + cap + '"/></td>' +
				'<td><input class="omCost" value="' + om + '"/></td>' +
				'<td class="capacityCost">calcMe</td>' +
				'<td class="enerCost">calcMe</td>' +
				'<td class="y1save">calcMe</td>' +
				'<td class="annualSave">calcMe</td>' +
				'<td class="payback">calcMe</td>'
				}
			}

			function indexFind(arr, fun) {
				for (i=0;i<arr.length;i++) {
					if (fun(arr[i])) {return i}
				}
				return -1
			}

			function recalculateCostBenefit() {
				energyRate = parseFloat(gebi('distrEnergyRate').value)
				capRate = parseFloat(gebi('distrCapacityRate').value)
				// Update everything not depending on baseline diff.
				for (study in studyDict) {
					if (undefined != study) {
						// Update the capacity graph. TODO: fix values.					
						capStudyIndex = indexFind(monCapCostGraph['series'], function (x) {return x.name == study})
						monthlyPower = studyDict[study]['Power'].map(function(x){return round(x*capRate,4)})
						monCapCostGraph['series'][capStudyIndex].setData(monthlyPower)
						// Update the energy graph. TODO: fix values.
						enStudyIndex = indexFind(monEnergyCostGraph['series'], function (x) {return x.name == study})
						monthlyEnergy = studyDict[study]['Power'].map(function(x){return round(x*energyRate,4)})
						monEnergyCostGraph['series'][enStudyIndex].setData(monthlyEnergy)
						// update the table:

					}
				}
				// Update baseline diff.
				for (study in studyDict) {
					if (undefined != study) {
						// update the costBen graph. TODO: values.
						costGrowthIndex = indexFind(costGrowth['series'], function (x) {return x.name == study})
						costSeries = []
						for (i=0;i<30;i++) {costSeries.push(randomInt(1,10))}
						costGrowth['series'][costGrowthIndex].setData(costSeries)
					}
				}
			}

			function OLDRecalculateCostBenefit() {
				baseCost = 0
				energyRate = parseFloat(gebi('distrEnergyRate').value)
				capRate = parseFloat(gebi('distrCapacityRate').value)
				tableRows = gebi('additionalMetricsTable').childNodes
				totalRows = tableRows.length
				// Table update baseline:
				for (rowNum=0;rowNum<totalRows;rowNum++) {
					daRow = tableRows[rowNum]
					studyName = daRow.querySelector('.studyName').innerHTML
					isBaseline = daRow.querySelector('.baseline').checked
					capacityCost = round(capRate * studyDict[studyName]['capTotal'],4)
					daRow.querySelector('.capacityCost').innerHTML = capacityCost
					enerCost = round(energyRate * studyDict[studyName]['energyTotal'],4)
					daRow.querySelector('.enerCost').innerHTML = enerCost
					if (isBaseline) {
						daRow.querySelector('.y1save').innerHTML = '0'
						daRow.querySelector('.annualSave').innerHTML = '0'
						daRow.querySelector('.payback').innerHTML = '0'
						capCost = parseFloat(daRow.querySelector('.capCost').value)
						omCost = parseFloat(daRow.querySelector('.omCost').value)
						baseCost = capCost + omCost + enerCost + capacityCost
						annualBaseCost = (omCost + enerCost + capacityCost)/studyDict[studyName]['yearPercentage']
						costSeries = []
						for (i=0;i<30;i++) {costSeries.push(0)}
						for (i=0;i<costGrowth.series.length;i++) {
							if (costGrowth['series'][i].name==studyName) {costGrowth['series'][i].setData(costSeries)}
						}
					}
				}
				// Table update things that aren't the baseline:
				for (rowNum=0;rowNum<totalRows;rowNum++) {
					daRow = tableRows[rowNum]
					studyName = daRow.querySelector('.studyName').innerHTML
					isBaseline = daRow.querySelector('.baseline').checked
					if (!isBaseline) {
						capacityCost = parseFloat(daRow.querySelector('.capacityCost').innerHTML)
						enerCost = parseFloat(daRow.querySelector('.enerCost').innerHTML)
						capCost = parseFloat(daRow.querySelector('.capCost').value)
						omCost = parseFloat(daRow.querySelector('.omCost').value)
						thisRowCost = capacityCost + enerCost + capCost + omCost
						y1save = baseCost - thisRowCost
						daRow.querySelector('.y1save').innerHTML = y1save
						initialCost = capCost + (omCost + enerCost + capacityCost)/studyDict[studyName]['yearPercentage']
						annualCost = (omCost + enerCost + capacityCost)/studyDict[studyName]['yearPercentage']
						annualSave = (annualBaseCost-annualCost)
						daRow.querySelector('.annualSave').innerHTML = round(annualSave,4)
						daRow.querySelector('.payback').innerHTML = round(Math.abs(y1save/annualSave),2)
						costSeries = []
						for (i=0;i<30;i++) {costSeries.push(round(annualBaseCost-initialCost+i*(annualBaseCost-annualCost),4))}
						for (i=0;i<costGrowth.series.length;i++) {
							if (costGrowth['series'][i].name==studyName) {
								costGrowth['series'][i].setData(costSeries)
							}
						}
					}
				}
			}
			recalculateCostBenefit()
		</script>
	</div>
</div>