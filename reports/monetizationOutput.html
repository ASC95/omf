<p class="reportTitle">Cost Benefit Analysis</p>
<div id="monetizationReport" class="tightContent">
	<div class="studyContainer" style="position:relative;height:200px">
		<div id="monetizedPowerTimeSeries" style="position:absolute;top:0px;left:0px;width:500px;height:200px">
			<script>monCapCostGraph = new Highcharts.Chart({{ monPowParams }})</script>
		</div>
		<div id="monetizedEnergyBalance" style="position:absolute;top:0px;left:500px;width:500px;height:200px">
			<script>monEnergyCostGraph = new Highcharts.Chart({{ monEnergyParams }})</script>
		</div>
	</div>
	<div id="costGrowthContainer" class="studyContainer" style="height:200px">
		<script>costGrowth = new Highcharts.Chart({{ savingsGrowthParams }})</script>
	</div>
	<div id="additionalMetrics" class="studyContainer">
		<div style="width:1000px;padding:5px 5px 5px 5px">
				Co-op Energy Rate ($/kWh) <input id="distrEnergyRate" value=""/> Capacity Rate ($/kW) <input id="distrCapacityRate" value=""/><button style="width:100px" onclick="recalculateCostBenefit()">Recalculate</button>
		</div>
		<table style="width:980px;padding-bottom:10px">
			<thead>
				<tr><th>Study</th><th>Baseline</th><th>Capital Cost</th><th>O&amp;M Cost</th><th>Cap. Cost</th><th>En. Cost</th><th>Y1 Save</th><th>Annual Save</th><th>Payback (Y)</th></tr>
			</thead>
			<tbody id="additionalMetricsTable">
			</tbody>
		</table>
		<script>
			studyDict = {{ studyDict | safe }}
			inputData = {{ inputData | safe }}
			timeStamps = {{ timeStamps | safe }}

			// Put the input data in.
			gebi('distrEnergyRate').value = inputData.distrEnergyRate
			gebi('distrCapacityRate').value = inputData.distrCapacityRate

			// Init the table.
			firstTime = true
			for (study in studyDict) {
				if (undefined != study) {
				// Add table row:
				table = gebi('additionalMetricsTable')
				newRow = table.insertRow()
				newRow.id = 'row' + study
				if (firstTime) {checked = 'checked'; cap = '0'; om = '0'; firstTime = false} else {checked = ''; cap = inputData['equipAndInstallCost']; om = inputData['opAndMaintCost']}
				newRow.innerHTML = '<td class="studyName">' + study + '</td>' +
				'<td><input type="radio" name="baseline" class="baseline" ' + checked + '/></td>' +
				'<td><input class="capCost" value="' + cap + '"/></td>' +
				'<td><input class="omCost" value="' + om + '"/></td>' +
				'<td class="capacityCost">calcMe</td>' +
				'<td class="energyCost">calcMe</td>' +
				'<td class="y1save">calcMe</td>' +
				'<td class="annualSave">calcMe</td>' +
				'<td class="payback">calcMe</td>'
				}
			}

			function monthAgg(stamps, power, func) {
				// Aggregate a month's worth of power.
				combo = zip([stamps,power])
				grouped = partition(combo, function(x,y){return x[0].substring(5,7)==y[0].substring(5,7)})
				function dropStamp(pairArr) {return pairArr.map(function(x){return x[1]})}
				noStamps = grouped.map(dropStamp)
				applied = noStamps.map(func)
				return flatten1(applied)
			}

			function recalculateCostBenefit() {
				energyRate = parseFloat(gebi('distrEnergyRate').value)
				capRate = parseFloat(gebi('distrCapacityRate').value)
				// Update everything not depending on baseline diff.
				for (study in studyDict) {
					if (undefined != study) {
						// Update the capacity graph.
						capStudyIndex = indexFind(monCapCostGraph['series'], function (x) {return x.name == study})
						function maxAvg(arr) {max=arrMax(arr); len=arr.length; return arr.map(function(x){return max/len})}
						powerAgged = monthAgg(timeStamps, studyDict[study]['Power'], maxAvg)
						monthlyPower = powerAgged.map(function(x){return round(x*capRate/1000,4)})
						monCapCostGraph['series'][capStudyIndex].setData(monthlyPower)
						// Update the energy graph.
						enStudyIndex = indexFind(monEnergyCostGraph['series'], function (x) {return x.name == study})
						function avg(arr) {total=arrSum(arr); len=arr.length; return arr.map(function(x){return total/len})}
						energyAgged = monthAgg(timeStamps, studyDict[study]['Power'], avg)
						monthlyEnergy = energyAgged.map(function(x){return round(x*energyRate/1000,4)})
						monEnergyCostGraph['series'][enStudyIndex].setData(monthlyEnergy)
						// update the table:
						thisRow = gebi('row' + study)
						thisRow.querySelector('.capacityCost').innerHTML = round(arrSum(monthlyPower),4)
						thisRow.querySelector('.energyCost').innerHTML = round(arrSum(monthlyEnergy),4)
					}
				}
				// Calculate baseline.
				baseRow = gebi('additionalMetricsTable').querySelector('[checked]').parentElement.parentElement
				baseAnnual = parseFloat(baseRow.querySelector('.omCost').value) + parseFloat(baseRow.querySelector('.capacityCost').innerHTML)/inputData['yearPercentage'] + parseFloat(baseRow.querySelector('.energyCost').innerHTML)/inputData['yearPercentage']
				baseCost = baseAnnual + parseFloat(baseRow.querySelector('.capCost').value)
				baseRow.querySelector('.y1save').innerHTML = '0'
				baseRow.querySelector('.annualSave').innerHTML = '0'
				baseRow.querySelector('.payback').innerHTML = '0'
				// Update things that depend on the baseline diff.
				for (study in studyDict) {
					if (undefined != study) {
						// Update the table:
						thisRow = gebi('row' + study)
						annualCost = parseFloat(thisRow.querySelector('.omCost').value) + parseFloat(thisRow.querySelector('.capacityCost').innerHTML)/inputData['yearPercentage'] + parseFloat(thisRow.querySelector('.energyCost').innerHTML)/inputData['yearPercentage']
						y1cost = annualCost + parseFloat(thisRow.querySelector('.capCost').value)
						y1save = baseCost - y1cost
						thisRow.querySelector('.y1save').innerHTML = round(y1save,4)
						annualSave = baseAnnual - annualCost
						thisRow.querySelector('.annualSave').innerHTML = round(annualSave,4)
						thisRow.querySelector('.payback').innerHTML = round(Math.abs(y1save/annualSave),2)
						// update the costBen graph. TODO: values.
						costGrowthIndex = indexFind(costGrowth['series'], function (x) {return x.name == study})
						costSeries = []
						for (i=0;i<30;i++) {costSeries.push(round(baseCost-y1cost+i*(baseAnnual-annualCost),4))}
						costGrowth['series'][costGrowthIndex].setData(costSeries)
					}
				}
			}
			recalculateCostBenefit()
		</script>
	</div>
</div>