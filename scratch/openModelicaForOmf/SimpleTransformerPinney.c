/* Simulation code for SimpleTransformerPinney generated by the OpenModelica Compiler 1.9.0 (r17628). */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation_info_xml.h"
#include "simulation_runtime.h"
#include "omc_error.h"
#include "model_help.h"

#include <assert.h>
#include <string.h>

#include "SimpleTransformerPinney_functions.h"

#include "SimpleTransformerPinney_model.h"
#include "SimpleTransformerPinney_functions.c"
/* dummy VARINFO and FILEINFO */
const FILE_INFO dummyFILE_INFO = omc_dummyFileInfo;
const VAR_INFO dummyVAR_INFO = omc_dummyVarInfo;
#ifdef __cplusplus
extern "C" {
#endif
#ifdef _OMC_MEASURE_TIME
int measure_time_flag = 1;
#else
int measure_time_flag = 0;
#endif


#if defined(HPCOM)
  #if !defined(_OPENMP)
    #error "HPCOM requires OpenMP or the results are wrong"
  #endif
  #include <omp.h>
  #include <perform_simulation.c>
#elif defined(_OPENMP)
  #include <omp.h>
  #include <omp_perform_simulation.c>
#else
  #include <perform_simulation.c>
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif


#define threadData data->threadData
void setupDataStruc(DATA *data)
{
  ASSERT(data, "Error while initialize Data");
  data->modelData.modelName = "SimpleTransformerPinney";
  data->modelData.modelFilePrefix = "SimpleTransformerPinney";
  data->modelData.modelDir = "";
  data->modelData.modelGUID = "{f405775e-7518-4567-b95a-fea5fb4671dd}";
  #ifdef OPENMODELICA_XML_FROM_FILE_AT_RUNTIME
  data->modelData.initXMLData = NULL;
  data->modelData.modelDataXml.infoXMLData = NULL;
  #else
  #include "SimpleTransformerPinney_init.c"
  #include "SimpleTransformerPinney_info.c"
  #endif
  
  data->modelData.nStates = 2;
  data->modelData.nVariablesReal = 2*2+19;
  data->modelData.nDiscreteReal = 0;
  data->modelData.nVariablesInteger = 0;
  data->modelData.nVariablesBoolean = 0;
  data->modelData.nVariablesString = 0;
  data->modelData.nParametersReal = 39;
  data->modelData.nParametersInteger = 0;
  data->modelData.nParametersBoolean = 3;
  data->modelData.nParametersString = 0;
  data->modelData.nInputVars = 0;
  data->modelData.nOutputVars = 4;
  data->modelData.nJacobians = 5;
  
  data->modelData.nAliasReal = 34;
  data->modelData.nAliasInteger = 0;
  data->modelData.nAliasBoolean = 0;
  data->modelData.nAliasString = 0;
  
  data->modelData.nZeroCrossings = 1;
  data->modelData.nSamples = 0;
  data->modelData.nRelations = 1;
  data->modelData.nMathEvents = 0;
  data->modelData.nInitEquations = 2;
  data->modelData.nInitAlgorithms = 0;
  data->modelData.nInitResiduals = 2;    /* data->modelData.nInitEquations + data->modelData.nInitAlgorithms */
  data->modelData.nExtObjs = 0;
  data->modelData.modelDataXml.fileName = "SimpleTransformerPinney_info.xml";
  data->modelData.modelDataXml.nFunctions = 0;
  data->modelData.modelDataXml.nProfileBlocks = 0;
  data->modelData.modelDataXml.nEquations = 94;
  data->modelData.nMixedSystems = 0;
  data->modelData.nLinearSystems = 2;
  data->modelData.nNonLinearSystems = 0;
  data->modelData.nStateSets = 0;
  data->modelData.nInlineVars = 0;
  
  data->modelData.nDelayExpressions = 0;
  
}


/* Has to be performed after _init.xml file has been read */
void callExternalObjectConstructors(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  /* data->simulationInfo.extObjs = NULL; */
  INFO(LOG_DEBUG, "call external Object Constructors");
  INFO(LOG_DEBUG, "call external Object Constructors finished");
}

void callExternalObjectDestructors(DATA *data)
{
  if(data->simulationInfo.extObjs)
  {
    free(data->simulationInfo.extObjs);
    data->simulationInfo.extObjs = 0;
  }
}


/* funtion initialize non-linear systems */
void initialNonLinearSystem(NONLINEAR_SYSTEM_DATA* nonLinearSystemData)
{
}

/* initial linear systems */
void setLinearMatrixA33(void *inData, void *systemData)
{
  DATA* data = (DATA*) inData;
  LINEAR_SYSTEM_DATA* linearSystemData = (LINEAR_SYSTEM_DATA*) systemData;
  linearSystemData->setAElement(0, 0, -0.03958979209410897, 0, linearSystemData);
  linearSystemData->setAElement(0, 1, -0.08037324626140714, 1, linearSystemData);
  linearSystemData->setAElement(1, 0, -0.07957747154594767, 2, linearSystemData);
  linearSystemData->setAElement(1, 1, -0.15995071780735481, 3, linearSystemData);
}
void setLinearVectorb33(void *inData, void *systemData)
{
  DATA* data = (DATA*) inData;
  LINEAR_SYSTEM_DATA* linearSystemData = (LINEAR_SYSTEM_DATA*) systemData;
  linearSystemData->b[0] =  (-$PbasicTransformer$Pdv);
  linearSystemData->b[1] =  (-$Pv1B);

}
/* inline linear systems */
/* parameter linear systems */
/* model linear systems */
void setLinearMatrixA55(void *inData, void *systemData)
{
  DATA* data = (DATA*) inData;
  LINEAR_SYSTEM_DATA* linearSystemData = (LINEAR_SYSTEM_DATA*) systemData;
  linearSystemData->setAElement(0, 0, -0.03958979209410897, 0, linearSystemData);
  linearSystemData->setAElement(0, 1, -0.08037324626140714, 1, linearSystemData);
  linearSystemData->setAElement(1, 0, -0.07957747154594767, 2, linearSystemData);
  linearSystemData->setAElement(1, 1, -0.15995071780735481, 3, linearSystemData);
}
void setLinearVectorb55(void *inData, void *systemData)
{
  DATA* data = (DATA*) inData;
  LINEAR_SYSTEM_DATA* linearSystemData = (LINEAR_SYSTEM_DATA*) systemData;
  linearSystemData->b[0] =  (-$PbasicTransformer$Pdv);
  linearSystemData->b[1] =  (-$Pv1B);

}
/* jacobians linear systems */

/* funtion initialize linear systems */
void initialLinearSystem(LINEAR_SYSTEM_DATA* linearSystemData)
{
  /* initial linear systems */
  linearSystemData[0].equationIndex = 33;
  linearSystemData[0].size = 2;
  linearSystemData[0].nnz = 4;
  linearSystemData[0].setA = setLinearMatrixA33;
  linearSystemData[0].setb = setLinearVectorb33;
  /* inline linear systems */
  /* parameter linear systems */
  /* model linear systems */
  linearSystemData[1].equationIndex = 55;
  linearSystemData[1].size = 2;
  linearSystemData[1].nnz = 4;
  linearSystemData[1].setA = setLinearMatrixA55;
  linearSystemData[1].setb = setLinearVectorb55;
  /* jacobians linear systems */
}

/* funtion initialize state sets */
void initializeStateSets(STATE_SET_DATA* statesetData, DATA *data)
{
}

int input_function(DATA *data)
{
  return 0;
}

int output_function(DATA *data)
{
  data->simulationInfo.outputVars[0] = $Pi2B;
  data->simulationInfo.outputVars[1] = $Pv2B;
  data->simulationInfo.outputVars[2] = $Pi1B;
  data->simulationInfo.outputVars[3] = $Pv1B;
  return 0;
}

/* Initializes the raw time events of the simulation using the now
   calcualted parameters. */
void function_initSample(DATA *data)
{
  long i=0;

}

int function_storeDelayed(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int updateBoundStartValues(DATA *data)
{

  
  INFO(LOG_INIT, "updating start-values");
  INDENT(LOG_INIT);
  RELEASE(LOG_INIT);
  
  return 0;
}

const char *initialResidualDescription[] =
{
  "basicTransformer.i1", 
  "basicTransformer.i2", 
};

int initial_residual(DATA *data, double *initialResiduals)
{
  int i = 0;
  state mem_state;
  
  mem_state = get_memory_state();
  INFO(LOG_RES_INIT, "updating initial residuals");
  INDENT(LOG_RES_INIT);
  initialResiduals[i++] = $PbasicTransformer$Pi1;
  INFO3(LOG_RES_INIT, "[%d]: %s = %g", i, initialResidualDescription[i-1], initialResiduals[i-1]);
  initialResiduals[i++] = $PbasicTransformer$Pi2;
  INFO3(LOG_RES_INIT, "[%d]: %s = %g", i, initialResidualDescription[i-1], initialResiduals[i-1]);
  RELEASE(LOG_RES_INIT);
  restore_memory_state(mem_state);
  
  return 0;
}

/*
 equation index: 1
 type: SIMPLE_ASSIGN
 resistor12._T = resistor12.T_ref
 */
static void eqFunction_1(DATA *data)
{
  $Presistor12$PT = $Presistor12$PT_ref;
}
/*
 equation index: 2
 type: SIMPLE_ASSIGN
 load1._T = load1.T_ref
 */
static void eqFunction_2(DATA *data)
{
  $Pload1$PT = $Pload1$PT_ref;
}
/*
 equation index: 3
 type: SIMPLE_ASSIGN
 resistor11._T = resistor11.T_ref
 */
static void eqFunction_3(DATA *data)
{
  $Presistor11$PT = $Presistor11$PT_ref;
}
/*
 equation index: 4
 type: SIMPLE_ASSIGN
 resistor11._R = R1
 */
static void eqFunction_4(DATA *data)
{
  $Presistor11$PR = $PR1;
}
/*
 equation index: 5
 type: SIMPLE_ASSIGN
 sineVoltage1._signalSource._startTime = sineVoltage1.startTime
 */
static void eqFunction_5(DATA *data)
{
  $PsineVoltage1$PsignalSource$PstartTime = $PsineVoltage1$PstartTime;
}
/*
 equation index: 6
 type: SIMPLE_ASSIGN
 sineVoltage1._freqHz = f
 */
static void eqFunction_6(DATA *data)
{
  $PsineVoltage1$PfreqHz = $Pf;
}
/*
 equation index: 7
 type: SIMPLE_ASSIGN
 sineVoltage1._signalSource._freqHz = sineVoltage1.freqHz
 */
static void eqFunction_7(DATA *data)
{
  $PsineVoltage1$PsignalSource$PfreqHz = $PsineVoltage1$PfreqHz;
}
/*
 equation index: 8
 type: SIMPLE_ASSIGN
 sineVoltage1._phase = phi0
 */
static void eqFunction_8(DATA *data)
{
  $PsineVoltage1$Pphase = $Pphi0;
}
/*
 equation index: 9
 type: SIMPLE_ASSIGN
 sineVoltage1._signalSource._phase = sineVoltage1.phase
 */
static void eqFunction_9(DATA *data)
{
  $PsineVoltage1$PsignalSource$Pphase = $PsineVoltage1$Pphase;
}
/*
 equation index: 10
 type: SIMPLE_ASSIGN
 sineVoltage1._V = Vpeak
 */
static void eqFunction_10(DATA *data)
{
  $PsineVoltage1$PV = $PVpeak;
}
/*
 equation index: 11
 type: SIMPLE_ASSIGN
 sineVoltage1._signalSource._amplitude = sineVoltage1.V
 */
static void eqFunction_11(DATA *data)
{
  $PsineVoltage1$PsignalSource$Pamplitude = $PsineVoltage1$PV;
}
/*
 equation index: 12
 type: SIMPLE_ASSIGN
 sineVoltage1._offset = Vdc
 */
static void eqFunction_12(DATA *data)
{
  $PsineVoltage1$Poffset = $PVdc;
}
/*
 equation index: 13
 type: SIMPLE_ASSIGN
 sineVoltage1._signalSource._offset = sineVoltage1.offset
 */
static void eqFunction_13(DATA *data)
{
  $PsineVoltage1$PsignalSource$Poffset = $PsineVoltage1$Poffset;
}
/*
 equation index: 14
 type: SIMPLE_ASSIGN
 RL = n ^ -2.0
 */
static void eqFunction_14(DATA *data)
{
  $PRL = real_int_pow($Pn, -2);
}
/*
 equation index: 15
 type: SIMPLE_ASSIGN
 load1._R = RL
 */
static void eqFunction_15(DATA *data)
{
  $Pload1$PR = $PRL;
}
/*
 equation index: 16
 type: SIMPLE_ASSIGN
 R2 = DIVISION(0.01, n ^ 2.0, #SHARED_LITERAL_2(String)#)
 */
static void eqFunction_16(DATA *data)
{
  modelica_real tmp0;
  modelica_real tmp1;
  tmp0 = $Pn;
  tmp1 = DIVISION(0.01, (tmp0 * tmp0), _OMC_LIT2);
  $PR2 = tmp1;
}
/*
 equation index: 17
 type: SIMPLE_ASSIGN
 resistor12._R = R2
 */
static void eqFunction_17(DATA *data)
{
  $Presistor12$PR = $PR2;
}
/*
 equation index: 18
 type: SIMPLE_ASSIGN
 resistor11._R_actual = resistor11.R * (1.0 + resistor11.alpha * (resistor11.T - resistor11.T_ref))
 */
static void eqFunction_18(DATA *data)
{
  $Presistor11$PR_actual = ($Presistor11$PR * (1.0 + ($Presistor11$Palpha * ($Presistor11$PT - $Presistor11$PT_ref))));
}
/*
 equation index: 19
 type: SIMPLE_ASSIGN
 resistor12._R_actual = resistor12.R * (1.0 + resistor12.alpha * (resistor12.T - resistor12.T_ref))
 */
static void eqFunction_19(DATA *data)
{
  $Presistor12$PR_actual = ($Presistor12$PR * (1.0 + ($Presistor12$Palpha * ($Presistor12$PT - $Presistor12$PT_ref))));
}
/*
 equation index: 20
 type: SIMPLE_ASSIGN
 load1._R_actual = load1.R * (1.0 + load1.alpha * (load1.T - load1.T_ref))
 */
static void eqFunction_20(DATA *data)
{
  $Pload1$PR_actual = ($Pload1$PR * (1.0 + ($Pload1$Palpha * ($Pload1$PT - $Pload1$PT_ref))));
}
/*
 equation index: 21
 type: SIMPLE_ASSIGN
 sineVoltage1._v = sineVoltage1.signalSource.offset + (if time < sineVoltage1.signalSource.startTime then 0.0 else sineVoltage1.signalSource.amplitude * sin(6.283185307179586 * sineVoltage1.signalSource.freqHz * (time - sineVoltage1.signalSource.startTime) + sineVoltage1.signalSource.phase))
 */
static void eqFunction_21(DATA *data)
{
  modelica_boolean tmp2;
  modelica_real tmp3;
  modelica_boolean tmp4;
  modelica_real tmp5;
  RELATIONHYSTERESIS(tmp2, time, $PsineVoltage1$PsignalSource$PstartTime, 0, Less);
  tmp4 = (modelica_boolean)tmp2;
  if(tmp4)
  {
    tmp5 = 0.0;
  }
  else
  {
    tmp3 = sin(((6.283185307179586 * ($PsineVoltage1$PsignalSource$PfreqHz * (time - $PsineVoltage1$PsignalSource$PstartTime))) + $PsineVoltage1$PsignalSource$Pphase));
    tmp5 = ($PsineVoltage1$PsignalSource$Pamplitude * tmp3);
  }
  $PsineVoltage1$Pv = ($PsineVoltage1$PsignalSource$Poffset + tmp5);
}
/*
 equation index: 22
 type: SIMPLE_ASSIGN
 basicTransformer._i2 = 0.0
 */
static void eqFunction_22(DATA *data)
{
  $PbasicTransformer$Pi2 = 0.0;
}
/*
 equation index: 23
 type: SIMPLE_ASSIGN
 resistor12._v = (-resistor12.R_actual) * basicTransformer.i2
 */
static void eqFunction_23(DATA *data)
{
  $Presistor12$Pv = ((-$Presistor12$PR_actual) * $PbasicTransformer$Pi2);
}
/*
 equation index: 24
 type: SIMPLE_ASSIGN
 resistor12._LossPower = (-resistor12.v) * basicTransformer.i2
 */
static void eqFunction_24(DATA *data)
{
  $Presistor12$PLossPower = ((-$Presistor12$Pv) * $PbasicTransformer$Pi2);
}
/*
 equation index: 25
 type: SIMPLE_ASSIGN
 load1._v = (-load1.R_actual) * basicTransformer.i2
 */
static void eqFunction_25(DATA *data)
{
  $Pload1$Pv = ((-$Pload1$PR_actual) * $PbasicTransformer$Pi2);
}
/*
 equation index: 26
 type: SIMPLE_ASSIGN
 v2B = resistor12.v + load1.v
 */
static void eqFunction_26(DATA *data)
{
  $Pv2B = ($Presistor12$Pv + $Pload1$Pv);
}
/*
 equation index: 27
 type: SIMPLE_ASSIGN
 load1._LossPower = (-load1.v) * basicTransformer.i2
 */
static void eqFunction_27(DATA *data)
{
  $Pload1$PLossPower = ((-$Pload1$Pv) * $PbasicTransformer$Pi2);
}
/*
 equation index: 28
 type: SIMPLE_ASSIGN
 i2B = -basicTransformer.i2
 */
static void eqFunction_28(DATA *data)
{
  $Pi2B = (-$PbasicTransformer$Pi2);
}
/*
 equation index: 29
 type: SIMPLE_ASSIGN
 basicTransformer._i1 = 0.0
 */
static void eqFunction_29(DATA *data)
{
  $PbasicTransformer$Pi1 = 0.0;
}
/*
 equation index: 30
 type: SIMPLE_ASSIGN
 resistor11._v = resistor11.R_actual * basicTransformer.i1
 */
static void eqFunction_30(DATA *data)
{
  $Presistor11$Pv = ($Presistor11$PR_actual * $PbasicTransformer$Pi1);
}
/*
 equation index: 31
 type: SIMPLE_ASSIGN
 v1B = sineVoltage1.v - resistor11.v
 */
static void eqFunction_31(DATA *data)
{
  $Pv1B = ($PsineVoltage1$Pv - $Presistor11$Pv);
}
/*
 equation index: 32
 type: SIMPLE_ASSIGN
 basicTransformer._dv = v1B - v2B
 */
static void eqFunction_32(DATA *data)
{
  $PbasicTransformer$Pdv = ($Pv1B - $Pv2B);
}
/*
 equation index: 33
 type: LINEAR
 
 <var>der(basicTransformer._i2)</var>
 <var>der(basicTransformer._i1)</var>
 <row>
   <cell>-basicTransformer.dv</cell>
   <cell>-v1B</cell>
 </row>
 <matrix>
   <cell row="0" col="0">
     <residual>-0.03958979209410897</residual>
   </cell><cell row="0" col="1">
     <residual>-0.08037324626140714</residual>
   </cell><cell row="1" col="0">
     <residual>-0.07957747154594767</residual>
   </cell><cell row="1" col="1">
     <residual>-0.15995071780735481</residual>
   </cell>
 </matrix>
 */
static void eqFunction_33(DATA *data)
{
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_TICK_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,33).profileBlockIndex);
  #endif
  /* Linear equation system */
  solve_linear_system(data, 0);
  $P$DER$PbasicTransformer$Pi2 = data->simulationInfo.linearSystemData[0].x[0];
  $P$DER$PbasicTransformer$Pi1 = data->simulationInfo.linearSystemData[0].x[1];
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ACC_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,33).profileBlockIndex);
  #endif
}
/*
 equation index: 34
 type: SIMPLE_ASSIGN
 resistor11._LossPower = resistor11.v * basicTransformer.i1
 */
static void eqFunction_34(DATA *data)
{
  $Presistor11$PLossPower = ($Presistor11$Pv * $PbasicTransformer$Pi1);
}
/*
 equation index: 35
 type: SIMPLE_ASSIGN
 i1B = basicTransformer.i1
 */
static void eqFunction_35(DATA *data)
{
  $Pi1B = $PbasicTransformer$Pi1;
}
/*
 equation index: 36
 type: SIMPLE_ASSIGN
 L2sigma = DIVISION(0.05, n ^ 2.0 * f * 6.283185307179586, #SHARED_LITERAL_3(String)#)
 */
static void eqFunction_36(DATA *data)
{
  modelica_real tmp6;
  modelica_real tmp7;
  tmp6 = $Pn;
  tmp7 = DIVISION(0.05, ((tmp6 * tmp6) * ($Pf * 6.283185307179586)), _OMC_LIT3);
  $PL2sigma = tmp7;
}
/*
 equation index: 37
 type: SIMPLE_ASSIGN
 Lm1 = DIVISION(10.0, f * 6.283185307179586, #SHARED_LITERAL_4(String)#)
 */
static void eqFunction_37(DATA *data)
{
  modelica_real tmp8;
  tmp8 = DIVISION(10.0, ($Pf * 6.283185307179586), _OMC_LIT4);
  $PLm1 = tmp8;
}
/*
 equation index: 38
 type: SIMPLE_ASSIGN
 L1sigma = DIVISION(0.05, f * 6.283185307179586, #SHARED_LITERAL_5(String)#)
 */
static void eqFunction_38(DATA *data)
{
  modelica_real tmp9;
  tmp9 = DIVISION(0.05, ($Pf * 6.283185307179586), _OMC_LIT5);
  $PL1sigma = tmp9;
}
/*
 equation index: 42
 type: SIMPLE_ASSIGN
 ground11._p._v = 0.0
 */
static void eqFunction_42(DATA *data)
{
  $Pground11$Pp$Pv = 0.0;
}
/*
 equation index: 41
 type: SIMPLE_ASSIGN
 ground12._p._v = 0.0
 */
static void eqFunction_41(DATA *data)
{
  $Pground12$Pp$Pv = 0.0;
}
/*
 equation index: 40
 type: SIMPLE_ASSIGN
 ground11._p._i = 0.0
 */
static void eqFunction_40(DATA *data)
{
  $Pground11$Pp$Pi = 0.0;
}
/*
 equation index: 39
 type: SIMPLE_ASSIGN
 ground12._p._i = 0.0
 */
static void eqFunction_39(DATA *data)
{
  $Pground12$Pp$Pi = 0.0;
}
const int useSymbolicInitialization = 1; /* true */
const int useHomotopy = 0; /* false */
int functionInitialEquations(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  data->simulationInfo.discreteCall = 1;
  eqFunction_1(data);
  restore_memory_state(mem_state);
  eqFunction_2(data);
  restore_memory_state(mem_state);
  eqFunction_3(data);
  restore_memory_state(mem_state);
  eqFunction_4(data);
  restore_memory_state(mem_state);
  eqFunction_5(data);
  restore_memory_state(mem_state);
  eqFunction_6(data);
  restore_memory_state(mem_state);
  eqFunction_7(data);
  restore_memory_state(mem_state);
  eqFunction_8(data);
  restore_memory_state(mem_state);
  eqFunction_9(data);
  restore_memory_state(mem_state);
  eqFunction_10(data);
  restore_memory_state(mem_state);
  eqFunction_11(data);
  restore_memory_state(mem_state);
  eqFunction_12(data);
  restore_memory_state(mem_state);
  eqFunction_13(data);
  restore_memory_state(mem_state);
  eqFunction_14(data);
  restore_memory_state(mem_state);
  eqFunction_15(data);
  restore_memory_state(mem_state);
  eqFunction_16(data);
  restore_memory_state(mem_state);
  eqFunction_17(data);
  restore_memory_state(mem_state);
  eqFunction_18(data);
  restore_memory_state(mem_state);
  eqFunction_19(data);
  restore_memory_state(mem_state);
  eqFunction_20(data);
  restore_memory_state(mem_state);
  eqFunction_21(data);
  restore_memory_state(mem_state);
  eqFunction_22(data);
  restore_memory_state(mem_state);
  eqFunction_23(data);
  restore_memory_state(mem_state);
  eqFunction_24(data);
  restore_memory_state(mem_state);
  eqFunction_25(data);
  restore_memory_state(mem_state);
  eqFunction_26(data);
  restore_memory_state(mem_state);
  eqFunction_27(data);
  restore_memory_state(mem_state);
  eqFunction_28(data);
  restore_memory_state(mem_state);
  eqFunction_29(data);
  restore_memory_state(mem_state);
  eqFunction_30(data);
  restore_memory_state(mem_state);
  eqFunction_31(data);
  restore_memory_state(mem_state);
  eqFunction_32(data);
  restore_memory_state(mem_state);
  eqFunction_33(data);
  restore_memory_state(mem_state);
  eqFunction_34(data);
  restore_memory_state(mem_state);
  eqFunction_35(data);
  restore_memory_state(mem_state);
  eqFunction_36(data);
  restore_memory_state(mem_state);
  eqFunction_37(data);
  restore_memory_state(mem_state);
  eqFunction_38(data);
  restore_memory_state(mem_state);
  eqFunction_42(data);
  restore_memory_state(mem_state);
  eqFunction_41(data);
  restore_memory_state(mem_state);
  eqFunction_40(data);
  restore_memory_state(mem_state);
  eqFunction_39(data);
  restore_memory_state(mem_state);
  data->simulationInfo.discreteCall = 0;
  
  return 0;
}

int functionInlineEquations(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


/*
 equation index: 58
 type: SIMPLE_ASSIGN
 ground12._p._i = 0.0
 */
static void eqFunction_58(DATA *data)
{
  $Pground12$Pp$Pi = 0.0;
}
/*
 equation index: 59
 type: SIMPLE_ASSIGN
 ground11._p._i = 0.0
 */
static void eqFunction_59(DATA *data)
{
  $Pground11$Pp$Pi = 0.0;
}
/*
 equation index: 60
 type: SIMPLE_ASSIGN
 ground12._p._v = 0.0
 */
static void eqFunction_60(DATA *data)
{
  $Pground12$Pp$Pv = 0.0;
}
/*
 equation index: 61
 type: SIMPLE_ASSIGN
 ground11._p._v = 0.0
 */
static void eqFunction_61(DATA *data)
{
  $Pground11$Pp$Pv = 0.0;
}
/*
 equation index: 62
 type: SIMPLE_ASSIGN
 L1sigma = DIVISION(0.05, f * 6.283185307179586, #SHARED_LITERAL_5(String)#)
 */
static void eqFunction_62(DATA *data)
{
  modelica_real tmp0;
  tmp0 = DIVISION(0.05, ($Pf * 6.283185307179586), _OMC_LIT5);
  $PL1sigma = tmp0;
}
/*
 equation index: 63
 type: SIMPLE_ASSIGN
 Lm1 = DIVISION(10.0, f * 6.283185307179586, #SHARED_LITERAL_4(String)#)
 */
static void eqFunction_63(DATA *data)
{
  modelica_real tmp1;
  tmp1 = DIVISION(10.0, ($Pf * 6.283185307179586), _OMC_LIT4);
  $PLm1 = tmp1;
}
/*
 equation index: 64
 type: SIMPLE_ASSIGN
 L2sigma = DIVISION(0.05, n ^ 2.0 * f * 6.283185307179586, #SHARED_LITERAL_3(String)#)
 */
static void eqFunction_64(DATA *data)
{
  modelica_real tmp2;
  modelica_real tmp3;
  tmp2 = $Pn;
  tmp3 = DIVISION(0.05, ((tmp2 * tmp2) * ($Pf * 6.283185307179586)), _OMC_LIT3);
  $PL2sigma = tmp3;
}
/*
 equation index: 65
 type: SIMPLE_ASSIGN
 R2 = DIVISION(0.01, n ^ 2.0, #SHARED_LITERAL_2(String)#)
 */
static void eqFunction_65(DATA *data)
{
  modelica_real tmp4;
  modelica_real tmp5;
  tmp4 = $Pn;
  tmp5 = DIVISION(0.01, (tmp4 * tmp4), _OMC_LIT2);
  $PR2 = tmp5;
}
/*
 equation index: 66
 type: SIMPLE_ASSIGN
 RL = n ^ -2.0
 */
static void eqFunction_66(DATA *data)
{
  $PRL = real_int_pow($Pn, -2);
}
/*
 equation index: 67
 type: SIMPLE_ASSIGN
 sineVoltage1._offset = Vdc
 */
static void eqFunction_67(DATA *data)
{
  $PsineVoltage1$Poffset = $PVdc;
}
/*
 equation index: 68
 type: SIMPLE_ASSIGN
 sineVoltage1._V = Vpeak
 */
static void eqFunction_68(DATA *data)
{
  $PsineVoltage1$PV = $PVpeak;
}
/*
 equation index: 69
 type: SIMPLE_ASSIGN
 sineVoltage1._phase = phi0
 */
static void eqFunction_69(DATA *data)
{
  $PsineVoltage1$Pphase = $Pphi0;
}
/*
 equation index: 70
 type: SIMPLE_ASSIGN
 sineVoltage1._freqHz = f
 */
static void eqFunction_70(DATA *data)
{
  $PsineVoltage1$PfreqHz = $Pf;
}
/*
 equation index: 71
 type: SIMPLE_ASSIGN
 sineVoltage1._signalSource._amplitude = sineVoltage1.V
 */
static void eqFunction_71(DATA *data)
{
  $PsineVoltage1$PsignalSource$Pamplitude = $PsineVoltage1$PV;
}
/*
 equation index: 72
 type: SIMPLE_ASSIGN
 sineVoltage1._signalSource._freqHz = sineVoltage1.freqHz
 */
static void eqFunction_72(DATA *data)
{
  $PsineVoltage1$PsignalSource$PfreqHz = $PsineVoltage1$PfreqHz;
}
/*
 equation index: 73
 type: SIMPLE_ASSIGN
 sineVoltage1._signalSource._phase = sineVoltage1.phase
 */
static void eqFunction_73(DATA *data)
{
  $PsineVoltage1$PsignalSource$Pphase = $PsineVoltage1$Pphase;
}
/*
 equation index: 74
 type: SIMPLE_ASSIGN
 sineVoltage1._signalSource._offset = sineVoltage1.offset
 */
static void eqFunction_74(DATA *data)
{
  $PsineVoltage1$PsignalSource$Poffset = $PsineVoltage1$Poffset;
}
/*
 equation index: 75
 type: SIMPLE_ASSIGN
 sineVoltage1._signalSource._startTime = sineVoltage1.startTime
 */
static void eqFunction_75(DATA *data)
{
  $PsineVoltage1$PsignalSource$PstartTime = $PsineVoltage1$PstartTime;
}
/*
 equation index: 76
 type: SIMPLE_ASSIGN
 resistor11._R = R1
 */
static void eqFunction_76(DATA *data)
{
  $Presistor11$PR = $PR1;
}
/*
 equation index: 77
 type: SIMPLE_ASSIGN
 resistor11._T = resistor11.T_ref
 */
static void eqFunction_77(DATA *data)
{
  $Presistor11$PT = $Presistor11$PT_ref;
}
/*
 equation index: 78
 type: SIMPLE_ASSIGN
 resistor11._R_actual = resistor11.R * (1.0 + resistor11.alpha * (resistor11.T - resistor11.T_ref))
 */
static void eqFunction_78(DATA *data)
{
  $Presistor11$PR_actual = ($Presistor11$PR * (1.0 + ($Presistor11$Palpha * ($Presistor11$PT - $Presistor11$PT_ref))));
}
/*
 equation index: 79
 type: SIMPLE_ASSIGN
 load1._R = RL
 */
static void eqFunction_79(DATA *data)
{
  $Pload1$PR = $PRL;
}
/*
 equation index: 80
 type: SIMPLE_ASSIGN
 load1._T = load1.T_ref
 */
static void eqFunction_80(DATA *data)
{
  $Pload1$PT = $Pload1$PT_ref;
}
/*
 equation index: 81
 type: SIMPLE_ASSIGN
 load1._R_actual = load1.R * (1.0 + load1.alpha * (load1.T - load1.T_ref))
 */
static void eqFunction_81(DATA *data)
{
  $Pload1$PR_actual = ($Pload1$PR * (1.0 + ($Pload1$Palpha * ($Pload1$PT - $Pload1$PT_ref))));
}
/*
 equation index: 82
 type: SIMPLE_ASSIGN
 resistor12._R = R2
 */
static void eqFunction_82(DATA *data)
{
  $Presistor12$PR = $PR2;
}
/*
 equation index: 83
 type: SIMPLE_ASSIGN
 resistor12._T = resistor12.T_ref
 */
static void eqFunction_83(DATA *data)
{
  $Presistor12$PT = $Presistor12$PT_ref;
}
/*
 equation index: 84
 type: SIMPLE_ASSIGN
 resistor12._R_actual = resistor12.R * (1.0 + resistor12.alpha * (resistor12.T - resistor12.T_ref))
 */
static void eqFunction_84(DATA *data)
{
  $Presistor12$PR_actual = ($Presistor12$PR * (1.0 + ($Presistor12$Palpha * ($Presistor12$PT - $Presistor12$PT_ref))));
}
/*
 equation index: 85
 type: ALGORITHM
 
   assert(resistor12.T >= 0.0, "Variable resistor12.T out of [min, max] interval: resistor12.T >= 0.0 has value: " + String(resistor12.T, "g"));
 */
static void eqFunction_85(DATA *data)
{
  modelica_boolean tmp6;
  modelica_string tmp7;
  modelica_string tmp8;
  static int tmp9 = 0;
  if(!tmp9)
  {
    tmp6 = GreaterEq($Presistor12$PT,0.0);
    if(!tmp6)
    {
      tmp7 = modelica_real_to_modelica_string_format($Presistor12$PT, "g");
      tmp8 = cat_modelica_string("Variable resistor12.T out of [min, max] interval: resistor12.T >= 0.0 has value: ",tmp7);
      FILE_INFO info = {"C:\\OpenModelica1.9.0\\lib\\omlibrary\\Modelica 3.2.1\\Electrical\\Analog\\Interfaces.mo",306,5,307,99,0};
      omc_assert_warning(info, tmp8);
      tmp9 = 1;
    }
  }
}
/*
 equation index: 86
 type: ALGORITHM
 
   assert(resistor12.T_ref >= 0.0, "Variable resistor12.T_ref out of [min, max] interval: resistor12.T_ref >= 0.0 has value: " + String(resistor12.T_ref, "g"));
 */
static void eqFunction_86(DATA *data)
{
  modelica_boolean tmp10;
  modelica_string tmp11;
  modelica_string tmp12;
  static int tmp13 = 0;
  if(!tmp13)
  {
    tmp10 = GreaterEq($Presistor12$PT_ref,0.0);
    if(!tmp10)
    {
      tmp11 = modelica_real_to_modelica_string_format($Presistor12$PT_ref, "g");
      tmp12 = cat_modelica_string("Variable resistor12.T_ref out of [min, max] interval: resistor12.T_ref >= 0.0 has value: ",tmp11);
      FILE_INFO info = {"C:\\OpenModelica1.9.0\\lib\\omlibrary\\Modelica 3.2.1\\Electrical\\Analog\\Basic.mo",64,3,64,78,0};
      omc_assert_warning(info, tmp12);
      tmp13 = 1;
    }
  }
}
/*
 equation index: 87
 type: ALGORITHM
 
   assert(load1.T >= 0.0, "Variable load1.T out of [min, max] interval: load1.T >= 0.0 has value: " + String(load1.T, "g"));
 */
static void eqFunction_87(DATA *data)
{
  modelica_boolean tmp14;
  modelica_string tmp15;
  modelica_string tmp16;
  static int tmp17 = 0;
  if(!tmp17)
  {
    tmp14 = GreaterEq($Pload1$PT,0.0);
    if(!tmp14)
    {
      tmp15 = modelica_real_to_modelica_string_format($Pload1$PT, "g");
      tmp16 = cat_modelica_string("Variable load1.T out of [min, max] interval: load1.T >= 0.0 has value: ",tmp15);
      FILE_INFO info = {"C:\\OpenModelica1.9.0\\lib\\omlibrary\\Modelica 3.2.1\\Electrical\\Analog\\Interfaces.mo",306,5,307,99,0};
      omc_assert_warning(info, tmp16);
      tmp17 = 1;
    }
  }
}
/*
 equation index: 88
 type: ALGORITHM
 
   assert(load1.T_ref >= 0.0, "Variable load1.T_ref out of [min, max] interval: load1.T_ref >= 0.0 has value: " + String(load1.T_ref, "g"));
 */
static void eqFunction_88(DATA *data)
{
  modelica_boolean tmp18;
  modelica_string tmp19;
  modelica_string tmp20;
  static int tmp21 = 0;
  if(!tmp21)
  {
    tmp18 = GreaterEq($Pload1$PT_ref,0.0);
    if(!tmp18)
    {
      tmp19 = modelica_real_to_modelica_string_format($Pload1$PT_ref, "g");
      tmp20 = cat_modelica_string("Variable load1.T_ref out of [min, max] interval: load1.T_ref >= 0.0 has value: ",tmp19);
      FILE_INFO info = {"C:\\OpenModelica1.9.0\\lib\\omlibrary\\Modelica 3.2.1\\Electrical\\Analog\\Basic.mo",64,3,64,78,0};
      omc_assert_warning(info, tmp20);
      tmp21 = 1;
    }
  }
}
/*
 equation index: 89
 type: ALGORITHM
 
   assert(resistor11.T >= 0.0, "Variable resistor11.T out of [min, max] interval: resistor11.T >= 0.0 has value: " + String(resistor11.T, "g"));
 */
static void eqFunction_89(DATA *data)
{
  modelica_boolean tmp22;
  modelica_string tmp23;
  modelica_string tmp24;
  static int tmp25 = 0;
  if(!tmp25)
  {
    tmp22 = GreaterEq($Presistor11$PT,0.0);
    if(!tmp22)
    {
      tmp23 = modelica_real_to_modelica_string_format($Presistor11$PT, "g");
      tmp24 = cat_modelica_string("Variable resistor11.T out of [min, max] interval: resistor11.T >= 0.0 has value: ",tmp23);
      FILE_INFO info = {"C:\\OpenModelica1.9.0\\lib\\omlibrary\\Modelica 3.2.1\\Electrical\\Analog\\Interfaces.mo",306,5,307,99,0};
      omc_assert_warning(info, tmp24);
      tmp25 = 1;
    }
  }
}
/*
 equation index: 90
 type: ALGORITHM
 
   assert(resistor11.T_ref >= 0.0, "Variable resistor11.T_ref out of [min, max] interval: resistor11.T_ref >= 0.0 has value: " + String(resistor11.T_ref, "g"));
 */
static void eqFunction_90(DATA *data)
{
  modelica_boolean tmp26;
  modelica_string tmp27;
  modelica_string tmp28;
  static int tmp29 = 0;
  if(!tmp29)
  {
    tmp26 = GreaterEq($Presistor11$PT_ref,0.0);
    if(!tmp26)
    {
      tmp27 = modelica_real_to_modelica_string_format($Presistor11$PT_ref, "g");
      tmp28 = cat_modelica_string("Variable resistor11.T_ref out of [min, max] interval: resistor11.T_ref >= 0.0 has value: ",tmp27);
      FILE_INFO info = {"C:\\OpenModelica1.9.0\\lib\\omlibrary\\Modelica 3.2.1\\Electrical\\Analog\\Basic.mo",64,3,64,78,0};
      omc_assert_warning(info, tmp28);
      tmp29 = 1;
    }
  }
}
int updateBoundParameters(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  eqFunction_58(data);
  restore_memory_state(mem_state);
  eqFunction_59(data);
  restore_memory_state(mem_state);
  eqFunction_60(data);
  restore_memory_state(mem_state);
  eqFunction_61(data);
  restore_memory_state(mem_state);
  eqFunction_62(data);
  restore_memory_state(mem_state);
  eqFunction_63(data);
  restore_memory_state(mem_state);
  eqFunction_64(data);
  restore_memory_state(mem_state);
  eqFunction_65(data);
  restore_memory_state(mem_state);
  eqFunction_66(data);
  restore_memory_state(mem_state);
  eqFunction_67(data);
  restore_memory_state(mem_state);
  eqFunction_68(data);
  restore_memory_state(mem_state);
  eqFunction_69(data);
  restore_memory_state(mem_state);
  eqFunction_70(data);
  restore_memory_state(mem_state);
  eqFunction_71(data);
  restore_memory_state(mem_state);
  eqFunction_72(data);
  restore_memory_state(mem_state);
  eqFunction_73(data);
  restore_memory_state(mem_state);
  eqFunction_74(data);
  restore_memory_state(mem_state);
  eqFunction_75(data);
  restore_memory_state(mem_state);
  eqFunction_76(data);
  restore_memory_state(mem_state);
  eqFunction_77(data);
  restore_memory_state(mem_state);
  eqFunction_78(data);
  restore_memory_state(mem_state);
  eqFunction_79(data);
  restore_memory_state(mem_state);
  eqFunction_80(data);
  restore_memory_state(mem_state);
  eqFunction_81(data);
  restore_memory_state(mem_state);
  eqFunction_82(data);
  restore_memory_state(mem_state);
  eqFunction_83(data);
  restore_memory_state(mem_state);
  eqFunction_84(data);
  restore_memory_state(mem_state);
  eqFunction_85(data);
  restore_memory_state(mem_state);
  eqFunction_86(data);
  restore_memory_state(mem_state);
  eqFunction_87(data);
  restore_memory_state(mem_state);
  eqFunction_88(data);
  restore_memory_state(mem_state);
  eqFunction_89(data);
  restore_memory_state(mem_state);
  eqFunction_90(data);
  restore_memory_state(mem_state);
  
  return 0;
}


/*
 equation index: 45
 type: SIMPLE_ASSIGN
 resistor11._v = resistor11.R_actual * basicTransformer.i1
 */
static void eqFunction_45(DATA *data)
{
  $Presistor11$Pv = ($Presistor11$PR_actual * $PbasicTransformer$Pi1);
}
/*
 equation index: 46
 type: SIMPLE_ASSIGN
 resistor11._LossPower = resistor11.v * basicTransformer.i1
 */
static void eqFunction_46(DATA *data)
{
  $Presistor11$PLossPower = ($Presistor11$Pv * $PbasicTransformer$Pi1);
}
/*
 equation index: 47
 type: SIMPLE_ASSIGN
 sineVoltage1._v = sineVoltage1.signalSource.offset + (if time < sineVoltage1.signalSource.startTime then 0.0 else sineVoltage1.signalSource.amplitude * sin(6.283185307179586 * sineVoltage1.signalSource.freqHz * (time - sineVoltage1.signalSource.startTime) + sineVoltage1.signalSource.phase))
 */
static void eqFunction_47(DATA *data)
{
  modelica_boolean tmp30;
  modelica_real tmp31;
  modelica_boolean tmp32;
  modelica_real tmp33;
  RELATIONHYSTERESIS(tmp30, time, $PsineVoltage1$PsignalSource$PstartTime, 0, Less);
  tmp32 = (modelica_boolean)tmp30;
  if(tmp32)
  {
    tmp33 = 0.0;
  }
  else
  {
    tmp31 = sin(((6.283185307179586 * ($PsineVoltage1$PsignalSource$PfreqHz * (time - $PsineVoltage1$PsignalSource$PstartTime))) + $PsineVoltage1$PsignalSource$Pphase));
    tmp33 = ($PsineVoltage1$PsignalSource$Pamplitude * tmp31);
  }
  $PsineVoltage1$Pv = ($PsineVoltage1$PsignalSource$Poffset + tmp33);
}
/*
 equation index: 48
 type: SIMPLE_ASSIGN
 v1B = sineVoltage1.v - resistor11.v
 */
static void eqFunction_48(DATA *data)
{
  $Pv1B = ($PsineVoltage1$Pv - $Presistor11$Pv);
}
/*
 equation index: 49
 type: SIMPLE_ASSIGN
 resistor12._v = (-resistor12.R_actual) * basicTransformer.i2
 */
static void eqFunction_49(DATA *data)
{
  $Presistor12$Pv = ((-$Presistor12$PR_actual) * $PbasicTransformer$Pi2);
}
/*
 equation index: 50
 type: SIMPLE_ASSIGN
 resistor12._LossPower = (-resistor12.v) * basicTransformer.i2
 */
static void eqFunction_50(DATA *data)
{
  $Presistor12$PLossPower = ((-$Presistor12$Pv) * $PbasicTransformer$Pi2);
}
/*
 equation index: 51
 type: SIMPLE_ASSIGN
 load1._v = (-load1.R_actual) * basicTransformer.i2
 */
static void eqFunction_51(DATA *data)
{
  $Pload1$Pv = ((-$Pload1$PR_actual) * $PbasicTransformer$Pi2);
}
/*
 equation index: 52
 type: SIMPLE_ASSIGN
 load1._LossPower = (-load1.v) * basicTransformer.i2
 */
static void eqFunction_52(DATA *data)
{
  $Pload1$PLossPower = ((-$Pload1$Pv) * $PbasicTransformer$Pi2);
}
/*
 equation index: 53
 type: SIMPLE_ASSIGN
 v2B = resistor12.v + load1.v
 */
static void eqFunction_53(DATA *data)
{
  $Pv2B = ($Presistor12$Pv + $Pload1$Pv);
}
/*
 equation index: 54
 type: SIMPLE_ASSIGN
 basicTransformer._dv = v1B - v2B
 */
static void eqFunction_54(DATA *data)
{
  $PbasicTransformer$Pdv = ($Pv1B - $Pv2B);
}
/*
 equation index: 55
 type: LINEAR
 
 <var>der(basicTransformer._i2)</var>
 <var>der(basicTransformer._i1)</var>
 <row>
   <cell>-basicTransformer.dv</cell>
   <cell>-v1B</cell>
 </row>
 <matrix>
   <cell row="0" col="0">
     <residual>-0.03958979209410897</residual>
   </cell><cell row="0" col="1">
     <residual>-0.08037324626140714</residual>
   </cell><cell row="1" col="0">
     <residual>-0.07957747154594767</residual>
   </cell><cell row="1" col="1">
     <residual>-0.15995071780735481</residual>
   </cell>
 </matrix>
 */
static void eqFunction_55(DATA *data)
{
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_TICK_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,55).profileBlockIndex);
  #endif
  /* Linear equation system */
  solve_linear_system(data, 1);
  $P$DER$PbasicTransformer$Pi2 = data->simulationInfo.linearSystemData[1].x[0];
  $P$DER$PbasicTransformer$Pi1 = data->simulationInfo.linearSystemData[1].x[1];
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ACC_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,55).profileBlockIndex);
  #endif
}
/*
 equation index: 56
 type: SIMPLE_ASSIGN
 i2B = -basicTransformer.i2
 */
static void eqFunction_56(DATA *data)
{
  $Pi2B = (-$PbasicTransformer$Pi2);
}
/*
 equation index: 57
 type: SIMPLE_ASSIGN
 i1B = basicTransformer.i1
 */
static void eqFunction_57(DATA *data)
{
  $Pi1B = $PbasicTransformer$Pi1;
}
/*
 equation index: 93
 type: ALGORITHM
 
   assert(1.0 + resistor11.alpha * (resistor11.T - resistor11.T_ref) >= 0.000000000000001, "Temperature outside scope of model!");
 */
static void eqFunction_93(DATA *data)
{
  modelica_boolean tmp34;
  tmp34 = GreaterEq((1.0 + ($Presistor11$Palpha * ($Presistor11$PT - $Presistor11$PT_ref))),0.000000000000001);
  if(!tmp34)
  {
      FILE_INFO info = {"C:\\OpenModelica1.9.0\\lib\\omlibrary\\Modelica 3.2.1\\Electrical\\Analog\\Basic.mo",74,3,74,108,0};
      omc_assert(info, "Temperature outside scope of model!");
  }
}
/*
 equation index: 92
 type: ALGORITHM
 
   assert(1.0 + resistor12.alpha * (resistor12.T - resistor12.T_ref) >= 0.000000000000001, "Temperature outside scope of model!");
 */
static void eqFunction_92(DATA *data)
{
  modelica_boolean tmp35;
  tmp35 = GreaterEq((1.0 + ($Presistor12$Palpha * ($Presistor12$PT - $Presistor12$PT_ref))),0.000000000000001);
  if(!tmp35)
  {
      FILE_INFO info = {"C:\\OpenModelica1.9.0\\lib\\omlibrary\\Modelica 3.2.1\\Electrical\\Analog\\Basic.mo",74,3,74,108,0};
      omc_assert(info, "Temperature outside scope of model!");
  }
}
/*
 equation index: 91
 type: ALGORITHM
 
   assert(1.0 + load1.alpha * (load1.T - load1.T_ref) >= 0.000000000000001, "Temperature outside scope of model!");
 */
static void eqFunction_91(DATA *data)
{
  modelica_boolean tmp36;
  tmp36 = GreaterEq((1.0 + ($Pload1$Palpha * ($Pload1$PT - $Pload1$PT_ref))),0.000000000000001);
  if(!tmp36)
  {
      FILE_INFO info = {"C:\\OpenModelica1.9.0\\lib\\omlibrary\\Modelica 3.2.1\\Electrical\\Analog\\Basic.mo",74,3,74,108,0};
      omc_assert(info, "Temperature outside scope of model!");
  }
}
int functionDAE(DATA *data)
{
  state mem_state;
  data->simulationInfo.needToIterate = 0;
  data->simulationInfo.discreteCall = 1;
  mem_state = get_memory_state();
  eqFunction_45(data);
  eqFunction_46(data);
  eqFunction_47(data);
  eqFunction_48(data);
  eqFunction_49(data);
  eqFunction_50(data);
  eqFunction_51(data);
  eqFunction_52(data);
  eqFunction_53(data);
  eqFunction_54(data);
  eqFunction_55(data);
  eqFunction_56(data);
  eqFunction_57(data);
  eqFunction_93(data);
  eqFunction_92(data);
  eqFunction_91(data);
  restore_memory_state(mem_state);
  
  return 0;
}

static void functionODE_system0(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(45);
  #endif
  eqFunction_45(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(45);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(47);
  #endif
  eqFunction_47(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(47);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(48);
  #endif
  eqFunction_48(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(48);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(49);
  #endif
  eqFunction_49(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(49);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(51);
  #endif
  eqFunction_51(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(51);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(53);
  #endif
  eqFunction_53(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(53);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(54);
  #endif
  eqFunction_54(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(54);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(55);
  #endif
  eqFunction_55(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(55);
  #endif
  restore_memory_state(mem_state);
}

void function_initMemoryState()
{
#ifdef _OPENMP
  push_memory_states(omp_get_max_threads());
  get_thread_index = omp_get_thread_num;
#else
  push_memory_states(1);
#endif
}

int functionODE(DATA *data)
{
#ifdef _OMC_MEASURE_TIME
  rt_tick(SIM_TIMER_FUNCTION_ODE);
#endif

  state mem_state; /* We need to have separate memory pools for separate systems... */
  mem_state = get_memory_state();
  
  data->simulationInfo.discreteCall = 0;
  functionODE_system0(data);
  restore_memory_state(mem_state);
#ifdef _OMC_MEASURE_TIME
  rt_accumulate(SIM_TIMER_FUNCTION_ODE);
#endif

  return 0;
}

#include <simulation_inline_solver.h>
const char *_omc_force_solver=_OMC_FORCE_SOLVER;
const int inline_work_states_ndims=_OMC_SOLVER_WORK_STATES_NDIMS;
int functionODE_inline(DATA* data, double stepSize)
{
  return 0;
}

static void functionAlg_system0(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(46);
  #endif
  eqFunction_46(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(46);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(50);
  #endif
  eqFunction_50(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(50);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(52);
  #endif
  eqFunction_52(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(52);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(56);
  #endif
  eqFunction_56(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(56);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(57);
  #endif
  eqFunction_57(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(57);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(93);
  #endif
  eqFunction_93(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(93);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(92);
  #endif
  eqFunction_92(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(92);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(91);
  #endif
  eqFunction_91(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(91);
  #endif
  restore_memory_state(mem_state);
}
/* for continuous time variables */
int functionAlgebraics(DATA *data)
{
  data->simulationInfo.discreteCall = 0;
  functionAlg_system0(data);
  return 0;
}

const char *zeroCrossingDescription[] =
{
  "time < sineVoltage1.signalSource.startTime", 
};

int function_ZeroCrossings(DATA *data, double *gout, double *t)
{
  state mem_state;
  modelica_boolean tmp3;
  
  mem_state = get_memory_state();
  tmp3 = LessZC(time,$PsineVoltage1$PsignalSource$PstartTime, data->simulationInfo.hysteresisEnabled[0]);
  ZEROCROSSING(0, (tmp3)?1:-1);
  restore_memory_state(mem_state);
  
  return 0;
}

const char *relationDescription[] =
{
  "time < sineVoltage1.signalSource.startTime", 
};

int function_updateRelations(DATA *data, int evalforZeroCross)
{
  state mem_state;
  modelica_boolean tmp4;
  
  mem_state = get_memory_state();
  if(evalforZeroCross)
  {
    tmp4 = LessZC(time,$PsineVoltage1$PsignalSource$PstartTime, data->simulationInfo.hysteresisEnabled[0]);
    data->simulationInfo.relations[0] = tmp4;
  }
  else
  {
    data->simulationInfo.relations[0] = (time < $PsineVoltage1$PsignalSource$PstartTime);
  }
  restore_memory_state(mem_state);
  
  return 0;
}

int checkForDiscreteChanges(DATA *data)
{
  int needToIterate = 0;

  DEBUG(LOG_EVENTS, "check for discrete changes");
  INDENT(LOG_EVENTS);
  RELEASE(LOG_EVENTS);
  
  return needToIterate;
}

/* function to check assert after a step is done */
int checkForAsserts(DATA *data)
{

  
  return 0;
}

/* initial mixed systems */
/* inline mixed systems */
/* parameter mixed systems */
/* model mixed systems */
/* jacobians mixed systems */

/* funtion initialize mixed systems */
void initialMixedSystem(MIXED_SYSTEM_DATA* mixedSystemData)
{
  /* initial mixed systems */
  /* inline mixed systems */
  /* parameter mixed systems */
  /* model mixed systems */
  /* jacobians mixed systems */
}

int initialAnalyticJacobianG(void* inData)
{
  return 1;
}
int initialAnalyticJacobianA(void* inData)
{
  DATA* data = ((DATA*)inData);
  int index = INDEX_JAC_A;
  
  int i;
  
  data->simulationInfo.analyticJacobians[index].sizeCols = 2;
  data->simulationInfo.analyticJacobians[index].sizeRows = 2;
  data->simulationInfo.analyticJacobians[index].seedVars = (modelica_real*) calloc(2,sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].resultVars = (modelica_real*) malloc(2*sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].tmpVars = (modelica_real*) malloc(0*sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex = (unsigned int*) malloc(2*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.index = (unsigned int*) malloc(4*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols = (unsigned int*) malloc(2*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.maxColors = 2;
  data->simulationInfo.analyticJacobians[index].jacobian = NULL;
  
  /* write column ptr of compressed sparse column*/
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PbasicTransformer$Pi1$pDERA$indexdiff] = 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PbasicTransformer$Pi2$pDERA$indexdiff] = 2;
  for(i=1;i<2;++i)
      data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[i] += data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[i-1];
  
  
  /* write index */
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PbasicTransformer$Pi1$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+0] = $PbasicTransformer$Pi2$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PbasicTransformer$Pi1$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+1] = $PbasicTransformer$Pi1$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PbasicTransformer$Pi2$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+0] = $PbasicTransformer$Pi2$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PbasicTransformer$Pi2$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+1] = $PbasicTransformer$Pi1$pDERA$indexdiffed;
  
  /* write color array */
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$PbasicTransformer$Pi1$pDERA$indexdiff] = 1;
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$PbasicTransformer$Pi2$pDERA$indexdiff] = 2;
  
  return 0;
}
int initialAnalyticJacobianB(void* inData)
{
  return 1;
}
int initialAnalyticJacobianC(void* inData)
{
  return 1;
}
int initialAnalyticJacobianD(void* inData)
{
  return 1;
}

int functionJacG_column(void* data)
{
  return 0;
}
int functionJacA_column(void* inData)
{
  state mem_state;
  DATA* data = ((DATA*)inData);
  int index = INDEX_JAC_A;
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  return 0;
}
int functionJacB_column(void* data)
{
  return 0;
}
int functionJacC_column(void* data)
{
  return 0;
}
int functionJacD_column(void* data)
{
  return 0;
}
int mayer(DATA* data, modelica_real* res){return -1;}
     int lagrange(DATA* data, modelica_real* res){return -1;}
const char *linear_model_frame =
  "model linear_SimpleTransformerPinney\n  parameter Integer n = 2; // states \n  parameter Integer k = 0; // top-level inputs \n  parameter Integer l = 4; // top-level outputs \n"
  "  parameter Real x0[2] = {%s};\n"
  "  parameter Real u0[0] = {%s};\n"
  "  parameter Real A[2,2] = [%s];\n"
  "  parameter Real B[2,0] = zeros(2,0);%s\n"
  "  parameter Real C[4,2] = [%s];\n"
  "  parameter Real D[4,0] = zeros(4,0);%s\n"
  "  Real x[2](start=x0);\n"
  "  input Real u[0];\n"
  "  output Real y[4];\n"
  "\n  Real x_PbasicTransformerPi2 = x[1];\n  Real x_PbasicTransformerPi1 = x[2];\n      Real y_Pi2B = y[1];\n  Real y_Pv2B = y[2];\n  Real y_Pi1B = y[3];\n  Real y_Pv1B = y[4];\n  \n"
  "equation\n  der(x) = A * x + B * u;\n  y = C * x + D * u;\nend linear_SimpleTransformerPinney;\n"
;

#ifdef __cplusplus
}
#endif

/* forward the main in the simulation runtime */
extern int _main_SimulationRuntime(int argc, char**argv, DATA *data);

/* call the simulation runtime main from our main! */
int main(int argc, char**argv)
{
  DATA data;
  setupDataStruc(&data);
  return _main_SimulationRuntime(argc, argv, &data);
}

